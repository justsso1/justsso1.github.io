<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Justsso的博客</title>
  
  
  <link href="https://justsso1.github.io/atom.xml" rel="self"/>
  
  <link href="https://justsso1.github.io/"/>
  <updated>2024-10-12T08:40:56.550Z</updated>
  <id>https://justsso1.github.io/</id>
  
  <author>
    <name>justsso</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊react fiber架构</title>
    <link href="https://justsso1.github.io/2021/05/02/%E8%81%8A%E8%81%8Areact%20fiber%E6%9E%B6%E6%9E%84/"/>
    <id>https://justsso1.github.io/2021/05/02/%E8%81%8A%E8%81%8Areact%20fiber%E6%9E%B6%E6%9E%84/</id>
    <published>2021-05-01T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章的大纲也就是写作的思路如下：</p><ol><li>react fiber架构是什么？</li><li>react fiber出现的时间节点</li><li>为什么要有fiber架构，解决了什么问题？</li><li>react fiber架构是怎么做的？实现原理</li></ol><p>react fiber是一种表示react节点的数据结构，现在我们所说的react fiber通常是指一种架构，react在16版本以后采用fiber架构</p><p>react fiber是在v16出现的，重写了v15中的底层，并且对外输出的api保持不变。</p><p>那么v15有什么问题呢，才会被推翻，被fiber架构取代。</p><p>v15中的render渲染是栈调和的，基于栈和深度递归，一直递归到最底层才会返回，如果执行的时间超过16ms(浏览器1s60帧)，就会出现卡顿现象。所以必须要解决这个问题。<br>我们希望react调和是怎样的呢，我们希望它可以暂停，在当前可用时间小于一帧的情况下，暂停，然后还能继续恢复。然后还有在有更高优先级的时候，我们希望它可以先去处理更高优先级，处理完了之后再来接着处理这个问题。<br>基于我们想要实现的效果，react采用了更先进的理念，纤程（比线程更小的单位），自己实现纤程，做到可以暂停，可以继续的架构，这底层的结构就叫fiber</p><p>那么fiber是怎么做的呢，可以实现可中断、可继续。fiber分为两部分 render和commit阶段，render阶段是可以停下来，再接着执行的，所以可能会被执行多次，而commit会和底层的dom操作有关，是不能被停下来的。</p><p>随着fiber架构思想的出现，fiber还带来”周边“的变化，那就是生命周期的变化，直接说是 react 15中的compomentWillDidMount componentWillUpdate componentWillRecivedProps 因为这三个生命周期是在render阶段，又可能会被重复执行，而开发者又有时会滥用，把一些副作用的代码写在这三个生命周期中。<br>所以react团队去掉了这三个生命周期，加入了getDerivedStateFromProps getSnapshotBeforUpdate 这两个静态方法，在静态方法中是拿不到this的</p><hr><p>react hooks的设计动机与工作模式</p><p>hooks是只能在function组件中使用，到现在react 团队都是在推崇使用function组件的。那么为什么是function 组件了呢？<br>因为function组件更加符合react的理念，那就是  UI &#x3D; f(data)，在function 中渲染可以读取到data。函数组件会捕获render内部的状态，这是和class组件最大的不同。</p><p>Hooks本质:一套能够使函数组件更强大、更灵活的”钩子“</p><p>函数组件比起类组件”少”了很多东西，比如生命周期、对state的管理。React-Hooks的出现，就是为了帮助函数组件补齐这些（相对于类组件来说，但生命周期这些也不是必须，只是完成一件事情的步骤代号而已）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章的大纲也就是写作的思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;react fiber架构是什么？&lt;/li&gt;
&lt;li&gt;react fiber出现的时间节点&lt;/li&gt;
&lt;li&gt;为什么要有fiber架构，解决了什么问题？&lt;/li&gt;
&lt;li&gt;react fiber架构是怎么做的？</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【转载】JavaScript模块简史</title>
    <link href="https://justsso1.github.io/2020/08/09/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91JavaScript%E6%A8%A1%E5%9D%97%E7%AE%80%E5%8F%B2/"/>
    <id>https://justsso1.github.io/2020/08/09/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91JavaScript%E6%A8%A1%E5%9D%97%E7%AE%80%E5%8F%B2/</id>
    <published>2020-08-08T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.543Z</updated>
    
    <content type="html"><![CDATA[<p>你是否是 JavaScript 新手？并且对模块，模块加载器和模块打包器感到困惑吗？或者你已经编写了一段时间的 JavaScript ，但是没法掌握模块的一些术语？你是否听过 CommonJS、AMD、Browserify、SystemJS、Webpack、JSPM 等等术语，但是不理解我们为什么需要它们？</p><p>我会试着解释他们是什么，他们试图解决什么问题，以及他们如何解决这个问题。</p><p>示例应用程序<br><img src="/../imgs/module/module.png"></p><p>(该图为应用程序运行界面)</p><p>在这篇文章中，我将使用一个简单的 web 应用程序来演示模块的概念。应用程序在浏览器中显示数组的和。该应用程序由4个函数和一个 index.html文件组成。<br><img src="/../imgs/module/daimazucheng.png"><br>(该图为函数的依赖示意图)</p><p>main 函数计算数组中数字的和，然后把答案显示在 span#answer 中。sum 函数依赖于两个函数：add 和 reduce。add 函数做它名字所做的操作；把两个数相加。reduce 函数遍历数组，并且调用 iteratee 回调函数。</p><p>花点时间理解下面的代码。我将会重复多次使用相同的函数。</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Modules<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">      The Answer is</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1-main.js </span></span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2-sum.js </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 3-add.js </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4-reduce.js </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, iteratee</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    length = arr.<span class="property">length</span>,</span><br><span class="line">    memo = arr[index];</span><br><span class="line">  <span class="keyword">for</span>(index += <span class="number">1</span>; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看如何把这些代码片段整合在一起，来构建一个应用程序。</p><h3 id="使用内嵌脚本"><a href="#使用内嵌脚本" class="headerlink" title="使用内嵌脚本"></a>使用内嵌脚本</h3><p>内嵌脚本就是在 <script></script> 标记之间添加 JavaScript 代码。这是我开始学 JavaScript 时的做法。我相信大多数 JavaScript 开发者在其生命中至少做过一次这样的事情。</p><p>这是一个很好的入门办法。没有外部文件或依赖关系需要担心。但是这也导致了不可维护的代码，因为：</p><p>缺乏代码可重用性：如果需要添加另一个页面，需要从这个页面中获得一些函数，我们就不得不复制粘贴代码。<br>缺乏依赖解析：你必须保证 main 函数之前已经添加了 add、reduce 和 sum 函数。<br>全局命名空间污染：所有的函数和变量将都将驻留在全局作用域中。</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Modules<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">      The Answer is</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> a + b;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, iteratee</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> index = <span class="number">0</span>,</span></span><br><span class="line"><span class="language-javascript">          length = arr.<span class="property">length</span>,</span></span><br><span class="line"><span class="language-javascript">          memo = arr[index];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span>(index += <span class="number">1</span>; index &lt; length; index += <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          memo = <span class="title function_">iteratee</span>(memo, arr[index])</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> memo;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/* Main Function */</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> answer = <span class="title function_">sum</span>(values)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Script-标签引入-JavaScript-文件"><a href="#Script-标签引入-JavaScript-文件" class="headerlink" title="Script 标签引入 JavaScript 文件"></a>Script 标签引入 JavaScript 文件</h3><p>这是从嵌入脚本的一个自然过渡。现在我们将大段的 JavaScript 分成更小的代码片段，并用 <script src=“...”> 标签加载它们。</p><p>通过将文件分成多个 JavaScript 文件，我们可以重用这些代码。我们不再需要在不同的 html 页面之间复制和粘贴代码。我们只需要将该文件用 script 标签加载就可以了。尽管这是更好的方法，但仍然有以下问题：</p><ul><li>缺乏依赖解析：文件的顺序很重要。你必须保证在加载 main.js 文件之前已经加载了 add.js、reduce.js 和 sum.js 文件。</li><li>全局命令空间污染：所有的函数和变量依然在全局作用域中。</li></ul><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 0-index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Modules<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">      The Answer is</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./add.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./reduce.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./sum.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;  <span class="keyword">return</span> a + b;&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduce.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, iteratee</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    length = arr.<span class="property">length</span>,</span><br><span class="line">    memo = arr[index];</span><br><span class="line"> </span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br></pre></td></tr></table></figure><h3 id="模块对象和-IIFE-模块模式"><a href="#模块对象和-IIFE-模块模式" class="headerlink" title="模块对象和 IIFE(模块模式)"></a>模块对象和 IIFE(模块模式)</h3><p>通过使用模块对象和 立即调用的函数表达式(IIFE) ，我们可以减少对全局作用域的污染。在这种方法中，我们只向全局作用域公开一个对象。该对象包含了我们在应用程序中需要的所有方法和值。在本例中，我们只向全局作用域公开了 myApp 对象。所有的函数都将被保存在 myApp 对象中。</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01-my-app.js </span></span><br><span class="line"><span class="keyword">var</span> myApp = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 02-add.js</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  myApp.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 03-reduce.js </span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  myApp.<span class="property">reduce</span> = <span class="keyword">function</span>(<span class="params">arr, iteratee</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">      length = arr.<span class="property">length</span>,</span><br><span class="line">      memo = arr[index];</span><br><span class="line">  </span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">      memo = <span class="title function_">iteratee</span>(memo, arr[index])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 04-sum.js</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  myApp.<span class="property">sum</span> = <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> myApp.<span class="title function_">reduce</span>(arr, myUtil.<span class="property">add</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 05-main.js</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">app</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line">  <span class="keyword">var</span> answer = app.<span class="title function_">sum</span>(values)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br><span class="line">&#125;)(myApp);</span><br></pre></td></tr></table></figure><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 06-index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Modules<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">      The Answer is</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./my-app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./add.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./reduce.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./sum.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意，除了 my-app.js 之外，其它每个文件都被封装成了 IIFE 格式。</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即调用的函数表达式(IIFE) 格式</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/*... your code goes here ...*/</span> &#125;)();</span><br></pre></td></tr></table></figure><p>通过将每个文件封装到 IIFE 中，所有的本地变量都保留在函数作用域内。因此，函数中的所有变量都将保持在函数作用域内，而不会污染全局作用域。</p><p>我们通过将它们附加到myApp对象来公开添加、减少和sum函数。我们通过引用myApp对象来访问这些函数</p><p>我们通过将 add、reduce 和 sum 函数附加在 myApp 对象上，从而对外公开它们。我们通过引用 myApp 对象来访问这些函数：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myApp.<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">myApp.<span class="title function_">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">myApp.<span class="title function_">reduce</span>(add, value);</span><br></pre></td></tr></table></figure><p>我们还可以通过 IIFE 的参数，传递 myApp 全局对象，就像 main.js 文件中所示一样。通过将该对象作为参数传递给 IIFE ，我们就可以为该对象选择一个较短的别名。而我们的代码会更简洁一些。</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="comment">// obj is new veryLongNameOfGlobalObject</span></span><br><span class="line">&#125;)(veryLongNameOfGloablObject);</span><br></pre></td></tr></table></figure><p>与前面的例子相比，IIFE 是一个巨大的改进。大多数流行的 JavaScript 库，如 jQuery ，都使用这种模式。它公开了一个全局对象 $，所有的函数都在 $ 对象中。</p><p>然而，这并不能算是一个完美的解决方案。这种方法仍然面临与上一节相同的问题。</p><ul><li>缺乏依赖解析：文件的顺序依然重要，myApp.js 必须出现在所有其它文件之前加载，main.js 必须处在所有其它库文件之后。</li><li>全局命令空间污染：现在全局变量的数量变成了 1，但是还不是 0 。</li></ul><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>2009年，有人讨论将 JavaScript 引入服务器端。因此 ServerJS 诞生了。随后，ServerJS 将其名称改为 CommonJS 。</p><p>CommonJS 不是一个 JavaScript 库。它是一个标准化组织。它就像 ECMA 或 W3C 一样。ECMA 定义了 JavaScript 的语言规范。W3C定义了 JavaScript web API ，比如 DOM 或 DOM 事件。 CommonJS 的目标是为 web 服务器、桌面和命令行应用程序定义一套通用的 API 。</p><p>CommonJS 还定义了模块 API 。因为在服务器应用程序中没有 HTML 页面和 </script><script> 标签，所以为模块提供一些清晰的 API 是很有意义的。模块需要被公开(<strong>export</strong>)以供其它模块使用，并且可以访问(<strong>import</strong>)。它的导出模块语法如下：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;  </span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义和输出了一个模块。代码保存在 add.js 文件中。</p><p>要使用或导入 add 模块，您需要 require 函数，使用文件名或模块名作为参数。下面的语法描述了如何将一个模块导入到代码中：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;./add&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果您在 NodeJS 上编写了代码，那么这种语法可能看起来很熟悉。这是因为 NodeJS 实现了 CommonJS 风格的模块API。</p><h3 id="异步模块定义-AMD"><a href="#异步模块定义-AMD" class="headerlink" title="异步模块定义(AMD)"></a>异步模块定义(AMD)</h3><p>CommonJs 风格的模块定义的问题在于它是同步的。当你调用 var add=require('add'); 时，系统将暂停，直到模块 准备(ready) 完成。这意味着当所有的模块都加载时，这一行代码将冻结浏览器(注：意思为除了加载该文件，浏览器什么事情也不做)。因此，这可能不是为浏览器端应用程序定义模块的最佳方式。</p><p>为了把服务器端用的模块语法转换给浏览器使用，CommonJS 提出了几种模块格式，“Module/Transfer” 。其中之一，即 “Module/Transfer/C“，后来成为 异步模块定义(AMD) 。</p><p>AMD具有以下格式：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([‘add’, ‘reduce’], <span class="keyword">function</span>(<span class="params">add, reduce</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>define 函数(或关键字)将依赖项列表和回调函数作为参数。回调函数的参数与数组中的依赖是相同的顺序。这相当于导入模块。并且回调函数返回一个值，即是你导出的值。</p><p>CommonJS 和 AMD 解决了模块模式中剩下的两个问题：依赖解析 和 全局作用域污染 。我们只需要处理每个模块或每个文件的依赖关系就可以了。<br>并且不再有全局作用域污染。</p><h3 id="RequireJS"><a href="#RequireJS" class="headerlink" title="RequireJS"></a>RequireJS</h3><p>在我们的浏览器应用程序中，AMD 可以把我们从 script 标签和全局污染中解救出来。那么，我们该如何使用它呢？这里 RequireJS 就可以帮助我们了。RequireJS 是一个 JavaScript 模块加载器(module loader) 。它可以根据需要异步加载模块。</p><p>尽管 RequireJS 的名字中含有 require，但是它的目标却并非要去支持 CommonJS 的 require 语法。使用 RequireJS，您可以编写 AMD 风格的模块。</p><p>在编写自己的应用程序之前，你将不得不从 RequireJS 网站 下载 require.js 文件。如下代码是用 RequireJS 编写的示例应用程序。</p><p>下面是 AMD 风格的应用程序示例<br>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 0-index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Modules<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">      The Answer is</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">&quot;main&quot;</span> <span class="attr">src</span>=<span class="string">&quot;require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;sum&#x27;</span>], <span class="keyword">function</span>(<span class="params">sum</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line">  <span class="keyword">var</span> answer = <span class="title function_">sum</span>(values)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;reduce&#x27;</span>], <span class="keyword">function</span>(<span class="params">add, reduce</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="title function_">define</span>([], <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce.js</span></span><br><span class="line"><span class="title function_">define</span>([], <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> reduce = <span class="keyword">function</span>(<span class="params">arr, iteratee</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">      length = arr.<span class="property">length</span>,</span><br><span class="line">      memo = arr[index];</span><br><span class="line"> </span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">      memo = <span class="title function_">iteratee</span>(memo, arr[index])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> reduce;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意在 index.html 中只有一个 script 标签。<br>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">”main”</span> <span class="attr">src</span>=<span class="string">”require.js”</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个标签加载 <code>require.js</code> 库到页面，data-main 属性告诉 RequieJS 应用程序的入口点在哪里。默认情况下，它假定所有文件都有 .js 文件扩展名，所以省略 .js 文件扩展名是可以的。在 RequireJS 加载了 main.js 文件之后，就会加载该文件的依赖，以及依赖的依赖，等等。浏览器的开发者工具会显示所有文件以如下顺序加载(如图)：<br><img src="/../imgs/module/amd%E6%A8%A1%E5%BC%8F%E4%B8%8Bjs%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.png"></p><p>浏览器加载 index.html，而 index.html 又加载 require.js 。剩下的文件及其依赖都是由 require.js 负责加载。</p><p>RequireJS 和 AMD 解决了我们以前所遇到的所有问题。然而，它也带来了一些不那么严重的问题。</p><ul><li>AMD 的语法过于冗余。因为所有东西都封装在 define 函数中，所以我们的代码有一些额外的缩进。对于一个小文件来说，这不是什么大问题，但是对于一个大型的代码库来说，这可能是一种精神上的负担。</li><li>数组中的依赖列表必须与函数的参数列表匹配。如果存在许多依赖项，则很难维护依赖项的顺序。如果您的模块中有几十个依赖项，并且如果你不得不在中间删除某个依赖，那么就很难找到匹配的模块和参数。</li><li>在当前浏览器下（HTTP 1.1），加载很多小文件会降低性能。</li></ul><h3 id="Browserify"><a href="#Browserify" class="headerlink" title="Browserify"></a>Browserify</h3><p>由于上述这些原因，有些人想要使用 CommonJS 语法来替换。但 CommonJS 语法是用于服务端，并且是同步的，对吗？这时 Browserify 就来解救我们了！通过 Browserify ，你可以在浏览器应用程序中使用 CommonJS 模块。Browserify 是一个 模块打包器(module bundler) 。Browserify 遍历代码的依赖树，并将依赖树中的所有模块打包成一个文件。</p><p>不同于 RequireJS ，但是 Browserify 是一个命令行工具，需要 NodeJS 和 NPM 来安装它。如果系统中安装了 NodeJS ，就可以用如下命令来安装 Browserify：</p><p>CommandLine 代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g browserify</span><br></pre></td></tr></table></figure><p>让我们看一下我们用 CommonJS 语法编写的示例应用程序。</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 0-index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Modules<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">      The Answer is</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="built_in">require</span>(<span class="string">&#x27;./sum&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum.js</span></span><br><span class="line"><span class="keyword">var</span> reduce = <span class="built_in">require</span>(<span class="string">&#x27;./reduce&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;./add&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Javascript</span><br><span class="line">//add.js</span><br><span class="line">module.exports = function add(a,b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduce.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, iteratee</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    length = arr.<span class="property">length</span>,</span><br><span class="line">    memo = arr[index];</span><br><span class="line"> </span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可能已经注意到，在 index.html 文件中，script 标记加载了 bundle.js，但是 bundle.js 文件在哪里？一旦我们执行了如下命令，Browserify 就会为我们生成这个文件：</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ browserify main.js -o bundle.js</span><br></pre></td></tr></table></figure><p>Browserify 解析 main.js 中的 require() 函数调用，并遍历项目中的依赖树。然后将依赖树打包到一个文件中。</p><p>Browserify 生成如下 bundle.js 文件的代码：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">e</span>(<span class="params">t,n,r</span>)&#123;<span class="keyword">function</span> <span class="title function_">s</span>(<span class="params">o,u</span>)&#123;<span class="keyword">if</span>(!n[o])&#123;<span class="keyword">if</span>(!t[o])&#123;<span class="keyword">var</span> a=<span class="keyword">typeof</span> <span class="built_in">require</span>==<span class="string">&quot;function&quot;</span>&amp;&amp;<span class="built_in">require</span>;<span class="keyword">if</span>(!u&amp;&amp;a)<span class="keyword">return</span> <span class="title function_">a</span>(o,!<span class="number">0</span>);<span class="keyword">if</span>(i)<span class="keyword">return</span> <span class="title function_">i</span>(o,!<span class="number">0</span>);<span class="keyword">var</span> f=<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cannot find module &#x27;&quot;</span>+o+<span class="string">&quot;&#x27;&quot;</span>);<span class="keyword">throw</span> f.<span class="property">code</span>=<span class="string">&quot;MODULE_NOT_FOUND&quot;</span>,f&#125;<span class="keyword">var</span> l=n[o]=&#123;<span class="attr">exports</span>:&#123;&#125;&#125;;t[o][<span class="number">0</span>].<span class="title function_">call</span>(l.<span class="property">exports</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;<span class="keyword">var</span> n=t[o][<span class="number">1</span>][e];<span class="keyword">return</span> <span class="title function_">s</span>(n?<span class="attr">n</span>:e)&#125;,l,l.<span class="property">exports</span>,e,t,n,r)&#125;<span class="keyword">return</span> n[o].<span class="property">exports</span>&#125;<span class="keyword">var</span> i=<span class="keyword">typeof</span> <span class="built_in">require</span>==<span class="string">&quot;function&quot;</span>&amp;&amp;<span class="built_in">require</span>;<span class="keyword">for</span>(<span class="keyword">var</span> o=<span class="number">0</span>;o&lt;r.<span class="property">length</span>;o++)<span class="title function_">s</span>(r[o]);<span class="keyword">return</span> s&#125;)(&#123;<span class="number">1</span>:[<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="variable language_">module</span>,<span class="built_in">exports</span></span>)&#123;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;,&#123;&#125;],<span class="number">2</span>:[<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="variable language_">module</span>,<span class="built_in">exports</span></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="built_in">require</span>(<span class="string">&#x27;./sum&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br><span class="line"> </span><br><span class="line">&#125;,&#123;<span class="string">&quot;./sum&quot;</span>:<span class="number">4</span>&#125;],<span class="number">3</span>:[<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="variable language_">module</span>,<span class="built_in">exports</span></span>)&#123;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, iteratee</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    length = arr.<span class="property">length</span>,</span><br><span class="line">    memo = arr[index];</span><br><span class="line"> </span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;,&#123;&#125;],<span class="number">4</span>:[<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="variable language_">module</span>,<span class="built_in">exports</span></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> reduce = <span class="built_in">require</span>(<span class="string">&#x27;./reduce&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;./add&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;,&#123;<span class="string">&quot;./add&quot;</span>:<span class="number">1</span>,<span class="string">&quot;./reduce&quot;</span>:<span class="number">3</span>&#125;]&#125;,&#123;&#125;,[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>您不需要逐行地理解这个打包文件。但值得注意的是，所有熟悉的代码、main.js 文件和所有依赖项都包含在这个文件中。</p><h3 id="UMD-–-只是为了让你更困惑"><a href="#UMD-–-只是为了让你更困惑" class="headerlink" title="UMD – 只是为了让你更困惑"></a>UMD – 只是为了让你更困惑</h3><p>现在我们已经学习了 全局对象(Global Object)，CommonJS 和 AMD 风格的模块。也有一些库可以帮助我们直接使用 CommonJS 或者 AMD 。但是，如果您正在编写一个模块，并部署到互联网上，该怎么办呢？你需要编写哪种模块风格呢？</p><p>编写三种不同的模块类型，即 全局模块对象 、CommonJS 和 AMD 。但是你必须维护三个不同的文件。用户将不得不识别他们正在下载的模块的类型。</p><p>通用模块定义(Universal Module Definition) ，即我们通常说的 UMD ，就是用来解决这个特殊问题的。本质上，UMD 是一套用来识别当前环境支持的模块风格的 if/else 语句。</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UMD 风格编写的 sum 模块</span></span><br><span class="line"><span class="comment">//sum.umd.js</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="comment">// AMD</span></span><br><span class="line">        <span class="title function_">define</span>([<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;reduce&#x27;</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Node, CommonJS-like</span></span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;add&#x27;</span>), <span class="built_in">require</span>(<span class="string">&#x27;reduce&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">        root.<span class="property">sum</span> = <span class="title function_">factory</span>(root.<span class="property">add</span>, root.<span class="property">reduce</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">add, reduce</span>) &#123;</span><br><span class="line">    <span class="comment">//  private methods</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//    exposed public methods</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="ES6-模块语法"><a href="#ES6-模块语法" class="headerlink" title="ES6 模块语法"></a>ES6 模块语法</h3><blockquote><p>注：了解更多关于 ES6 模块的信息，建议阅读 ECMAScript 6 Modules(模块)系统及语法详解。</p></blockquote><p>JavaScript 全局模块对象、CommonJS、AMD 和 UMD，我们有太多的选项了。现在或许你会问，下一个项目我该用哪一个呢？答案是一个都不用。</p><p>JavaScript 语言中并没有内置模块系统。这就是为什么我们有这么多不同的导入和导出模块的原因。但这种情况最近发生了变化。 ES6 语言规范中，模块是 JavaScript 的一部分。所以这个问题的答案是，如果你想让你的项目想兼容未来，你需要使用 ES6 模块语法。</p><p>ES6 用 import 和 export 关键字来导入和导出模块。如下是用 ES6 模块语法编写的示例应用程序。</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./sum&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">&#x27;./add&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reduce <span class="keyword">from</span> <span class="string">&#x27;./reduce&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;  </span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduce.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, iteratee</span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>,  length = arr.<span class="property">length</span>,  memo = arr[index];   </span><br><span class="line">  index += <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;    </span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index]);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多关于 ES6 模块的流行语：ES6 模块语法是简洁的。ES6 模块将统治 JavaScript 世界。它是未来。但不幸的是，有一个问题。浏览器还没有为这种新语法做好准备。在撰写文章的时候，只有 Chrome 浏览器支持 import 语句。即使大多数浏览器支持 import 和 export ，如果您的应用程序必须支持较老的浏览器，那么您可能会遇到问题。</p><p>幸运的是，现在已经有很多工具可以用了，这些工具让我们现在就可以用 ES6 模块语法。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 是一个 模块打包器(module bundler) 。就像 Browserify 一样，它会遍历依赖树，然后将其打包到一到多个文件。那么问题来了，如果它和 Browserify 一样，为什么我们需要另一个模块打包器呢？Webpack 可以处理 CommonJS 、 AMD 和 ES6 模块。并且 Webpack 还有更多的灵活性和一些很酷的功能特性，比如：</p><ul><li><strong>代码分离</strong>：当您有多个应用程序共享相同的模块时。Webpack 可以将您的代码打包到两个或更多的文件中。例如，如果您有两个应用程序 app1 和 app2 ，并且都共享许多模块。 使用 Browserify ，你会有 app1.js 和 app2.js 。并且都包含所有依赖关系模块。但是使用 Webpack ，您可以创建 app1.js ，app2.js 和 shared-lib.js。是的，您必须从 html 页面加载 2 个文件。但是使用哈希文件名，浏览器缓存和 CDN ，可以减少初始加载时间。</li><li><strong>加载器</strong>：用自定义加载器，可以加载任何文件到源文件中。用 require() 语法，不仅仅可以加载 JavaScript 文件，还可以加载 CSS、CoffeeScript、Sass、Less、HTML模板、图像，等等。</li><li><strong>插件</strong>：Webpack 插件可以在打包写入到打包文件之前对其进行操作。有很多社区创建的插件。例如，给打包代码添加注释，添加 Source map，将打包文件分离成块等等。</li></ul><p>WebpackDevServer 是一个开发服务器，它可以在源代码改变被检测到时自动打包源代码，并刷新浏览器。它通过提供代码的即时反馈，从而加快开发过程。</p><p>让我们来看看我们如何用 Webpack 来构建示例应用程序。Webpack 需要一点引导和配置。</p><p>因为 Webpack 是 JavaScript 命令行工具，所以需要先安装上 NodeJS 和 NPM 。装好 NPM 后，执行如下命令初始化项目：</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir project; cd project</span><br><span class="line">$ npm init -y</span><br><span class="line">$ npm install -D webpack webpack-dev-server</span><br></pre></td></tr></table></figure><p>您需要一个 webpack 的配置文件。你的配置中至少需要 entry 和 output 两个字段。在 webpack.config.js 中保存以下内容。</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js webpack 的配置文件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;   </span><br><span class="line">  <span class="attr">entry</span>: ‘./app/main.<span class="property">js</span>’,   </span><br><span class="line">  <span class="attr">output</span>: &#123;       </span><br><span class="line">    <span class="attr">filename</span>: ‘bundle.<span class="property">js</span>’   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 package.json 文件，在 script 字段后添加如下行：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    </span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server -progress -colors&quot;</span>,    </span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span> </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>现在在 project/app 目录下添加所有 JavaScript 模块，在 project 目录下添加 index.html。</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 0-index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Modules<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>      </span><br><span class="line">      The Answer is      </span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 03-package.json 特别注意，这行注释不要复制，否则json文件会报错</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jsmodules&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --progress --colors&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^1.12.14&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^1.14.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/add.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/reduce.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">arr, iteratee</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    length = arr.<span class="property">length</span>,</span><br><span class="line">    memo = arr[index];</span><br><span class="line"> </span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/sum.js</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;./reduce&#x27;</span>, <span class="string">&#x27;./add&#x27;</span>], <span class="keyword">function</span>(<span class="params">reduce, add</span>)&#123;</span><br><span class="line">  sum =  <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reduce</span>(arr, add);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/main.js</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="built_in">require</span>(<span class="string">&#x27;./sum&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br></pre></td></tr></table></figure><p>注意 add.js 和 reduce.js 是用 CommonJS 风格写的，而 sum.js 是用 AMD 风格写的。 Webpack 默认是可以处理 CommonJS 和 AMD。如果你用的是 ES6 模块，那就需要安装和配置 babel loader。</p><p>一旦你准备好所有的文件，你可以运行你的应用程序。</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><p>打开浏览器，把 URL 指向 <a href="http://localhost:8080/webpack-dev-server/%EF%BC%8C%E5%A6%82%E5%9B%BE%EF%BC%9A">http://localhost:8080/webpack-dev-server/，如图：</a><br><img src="/../imgs/module/webpack_bundle.png"></p><p>此时，你可以打开你喜欢的编辑器编辑代码。保存文件时，浏览器会自动刷新以显示修改后的结果。</p><p>这里你可能会注意到一件事情，就是找不到 dist/bundle.js 文件。这是因为 Webpack Dev Server 会创建打包文件，但是不会写入到文件系统中，而是放在内存中。</p><p>如果要部署，就得创建打包文件。可以通过键入如下命令创建 bundle.js 文件：</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><p>如果有兴趣学习更多的 Webpack 知识，请参考 Webpack 文档页 。</p><h3 id="Rollup-2015-年-5-月"><a href="#Rollup-2015-年-5-月" class="headerlink" title="Rollup (2015 年 5 月)"></a>Rollup (2015 年 5 月)</h3><blockquote><p>注：Rollup 普及了 JavaScript 圈内一个重要的特性：Tree shaking，即是指消除JavaScript上下文中无用代码，或更精确地说，只保留有用的代码。它依赖于ES6模块 import / export 模块系统的静态结构(static structure)来检测哪一个模块没有被使用，因为，import 和 export 不会在运行时改变。说的再直白一点就是 Tree shaking 从模块包中排除未使用的 exports 项。</p></blockquote><p>webpack 2 内置引入的 Tree-shaking 代码优化技术。 详情阅读 webpack 2 中的 Tree Shaking</p><p>将一个大的 JavaScript 库包含进来，只是为了用它几个函数，你是否有这样的经历？Rollup 是另一个 JavaScript ES6 模块打包器。与 Browserify 和 Webpak 不同，rollup 只包含在项目中用到的代码。如果有大模块，带有很多函数，但是你只是用到少数几个，rollup 只会将需要的函数包含到打包文件中，从而显著减少打包文件大小。</p><p>Rollup 可以被用作为命令行工具。如果有 NodeJS 和 NPM，那么就可以用如下命令安装 rollup：</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g rollup</span><br></pre></td></tr></table></figure><p>Rollup 可以与任何类型的模块风格一起工作。但是，推荐使用 ES6 模块风格，这样就可以利用 tree-shaking 功能。如下是用 ES6 编写的示例应用程序代码：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01-add.js </span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">a,b</span>) =&gt; a + b;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sub</span> = (<span class="params">a,b</span>) =&gt; a - b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> &#123; add, sub &#125;;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="title function_">default</span> (arr, iteratee) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>,</span><br><span class="line">  length = arr.<span class="property">length</span>,</span><br><span class="line">  memo = arr[index];</span><br><span class="line"> </span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./add&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reduce <span class="keyword">from</span> <span class="string">&#x27;./reduce&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="title function_">default</span> (arr) =&gt; <span class="title function_">reduce</span>(arr, add);</span><br></pre></td></tr></table></figure><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./sum&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br></pre></td></tr></table></figure><p>注意，在 add 模块中，我引入了另一个函数 sub()。但是该函数在应用程序中并没有用到。</p><p>现在我们用 rollup 将这些代码打包：</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rollup main.js -o bundle.js</span><br></pre></td></tr></table></figure><p>这会生成像如下的 bundle.js 文件：<br>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">a,b</span>) =&gt; a + b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="title function_">reduce</span> = (<span class="params">arr, iteratee</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>,</span><br><span class="line">  length = arr.<span class="property">length</span>,</span><br><span class="line">  memo = arr[index];</span><br><span class="line"> </span><br><span class="line">  index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; index &lt; length; index += <span class="number">1</span>)&#123;</span><br><span class="line">    memo = <span class="title function_">iteratee</span>(memo, arr[index]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">arr</span>) =&gt; <span class="title function_">reduce</span>(arr, add);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> values = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ];</span><br><span class="line"><span class="keyword">var</span> answer = <span class="title function_">sum</span>(values);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;answer&quot;</span>).<span class="property">innerHTML</span> = answer;</span><br></pre></td></tr></table></figure><p>这里我们可以看到 sub() 函数并没有包含在这个打包文件中。</p><h3 id="SystemJS"><a href="#SystemJS" class="headerlink" title="SystemJS"></a>SystemJS</h3><p>SystemJS 是一个通用的模块加载器，它能在浏览器或者 NodeJS 上动态加载模块，并且支持 CommonJS、AMD、全局模块对象和 ES6 模块。通过使用插件，它不仅可以加载 JavaScript，还可以加载 CoffeeScript 和 TypeScript。</p><p>SystemJS 的另一个优点是，它建立在 ES6 模块加载器之上，所以它的语法和 API 在将来很可能是语言的一部分，这会让我们的代码更不会过时。<br>要异步输入一个模块，可以用如下语法：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">System</span>.<span class="keyword">import</span>(‘<span class="variable language_">module</span>-name’);</span><br></pre></td></tr></table></figure><p>然后我们可以用配置 API 来配置 SystemJS 的行为：</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">System</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">transplier</span>: ‘babel’,</span><br><span class="line">  <span class="attr">baseURL</span>: ‘/app’</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的配置会让 SystemJS 使用 babel 作为 ES6 模块的编译器，并且从 /app 目录加载模块。</p><p>随着现代 JavaScript 应用程序变得越来越大，越来越复杂，开发工作流也是如此。所以我们不仅仅模块加载器，还得去寻找开发服务器、生产的模块打包器以及第三方模块的包管理器。</p><h3 id="JSPM"><a href="#JSPM" class="headerlink" title="JSPM"></a>JSPM</h3><p>JSPM 是 JavaScript 开发工具的瑞士军刀，它是既是包管理器，又是模块加载器，又是模块打包器。</p><p>现代 JavaScript 开发很少只是需要自己的模块，绝大部分时候，我们还需要第三方模块。使用 JSPM，我们可以使用如下的命令，从 NPM 或者 Github 安装第三方模块：</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jspm install npm:package-name or github:package/name</span><br></pre></td></tr></table></figure><p>上述命令会从 npm 或者 github 下载包，并将包安装到 jspm_packages 目录。</p><p>在开发模式下，我们可以使用 jspm-server 。像 Webpack Dev Server 一样，它会检测代码改变，重新加载浏览器来显示改变。与 Webpack Dev Server 不同的是，jspm-server 用的是 SystemJS 模块加载器。所以，每次它检测了文件的改变时，不会将所有文件读取来打包，而是只加载页面所需要的模块。</p><p>在部署时，肯定要打包代码。JSPM 带有打包器，可以用如下命令对代码打包：</p><p>CommandLine 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jspm bundle main.js bundle.js</span><br></pre></td></tr></table></figure><p>在幕后，JSPM 用 rollup 作为它的打包器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我希望本文给了足够的信息来理解 JavaScript 模块的词汇。现在你也许会问，下一个项目我应该用什么呢？不幸的是，我回答不了这个问题。现在你有能力开始自己的探索。希望本文能让你更容易理解我提到的有关工具的文档和文章。</p><p>本文所有的代码示例都可以在 这个 <a href="https://github.com/sungthecoder/js-modules-examples">Github 仓库</a> 中找到。如有任何疑问，请在下面留言。</p><p>原文链接：<a href="https://medium.com/@sungyeol.choi/javascript-module-module-loader-module-bundler-es6-module-confused-yet-6343510e7bde">https://medium.com/@sungyeol.choi/javascript-module-module-loader-module-bundler-es6-module-confused-yet-6343510e7bde</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你是否是 JavaScript 新手？并且对模块，模块加载器和模块打包器感到困惑吗？或者你已经编写了一段时间的 JavaScript ，但是没法掌握模块的一些术语？你是否听过 CommonJS、AMD、Browserify、SystemJS、Webpack、JSPM 等等术</summary>
      
    
    
    
    <category term="前端工程化" scheme="https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="模块化" scheme="https://justsso1.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深讲解数组的reduce用法</title>
    <link href="https://justsso1.github.io/2020/07/13/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%AE%B2%E8%A7%A3%E6%95%B0%E7%BB%84%E7%9A%84reduce%E7%94%A8%E6%B3%95/"/>
    <id>https://justsso1.github.io/2020/07/13/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%AE%B2%E8%A7%A3%E6%95%B0%E7%BB%84%E7%9A%84reduce%E7%94%A8%E6%B3%95/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>数组中的reduce犹如一只魔法棒，通过它可以做一些黑科技一样的事情。本文从api讲解到一般用法再到高级用法，由浅入深的讲一讲数组中的reduce。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">MDN链接</a></p><h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p>reduce的api是这样的，</p><blockquote><p>reduce(callback(accumulator, currentValue[, index, array])[,initialValue])</p></blockquote><ul><li>Callback<ul><li>accumulator 积累的值</li><li>currentValue 当前值<br>  -index 当前下标</li><li>array 当前数组</li></ul></li><li>initialValue 初始值</li></ul><p>reduce接受两个参数，回调函数和初识值，初始值是可选的。回调函数接受4个参数：积累值、当前值、当前下标、当前数组。<br>如果reduce的参数只有一个，那么积累值一开始是数组中第一个值，如果reduce的参数有两个，那么积累值一开始是出入的initialValue初始值。<br>然后在每一次迭代时，返回的值作为下一次迭代的accumulator 积累值。</p><p><strong>重要说明：如果未设置initialValue，那么reduce将使用您的第一个数组值作为第一次迭代的accumulator，从第二个数组元素上开始循环，从index&#x3D;1开始（如果有的话）</strong></p><p>以下是reduce的几种实际应用。</p><ol><li>将数组转化为对象</li></ol><p>将下面的数组转成以id为key的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> userList = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;john&#x27;</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&#x27;john@163.com&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;jerry&#x27;</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&#x27;jerry@163.com&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;nancy&#x27;</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objUserList = userList.<span class="title function_">reduce</span>(keyByUserNameReducer, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">keyByUserNameReducer</span>(<span class="params">acculumator, currentValue, currentIndex, array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;...acculumator, [currentValue.<span class="property">id</span>]: currentValue&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objUserList)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    &#x27;1&#x27;: &#123; id: 1, username: &#x27;john&#x27;, sex: 1, email: &#x27;john@163.com&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//    &#x27;2&#x27;: &#123; id: 2, username: &#x27;jerry&#x27;, sex: 1, email: &#x27;jerry@163.com&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//    &#x27;3&#x27;: &#123; id: 3, username: &#x27;nancy&#x27;, sex: 0, email: &#x27;&#x27; &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将小数组展开成大数组<br>将下面数组按照逗号分割.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileLines = [</span><br><span class="line">    <span class="string">&#x27;Inspector Algar,Inspector Bardle,Mr. Barker,Inspector Barton&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Inspector Baynes,Inspector Bradstreet,Inspector Sam Brown&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Monsieur Dubugue,Birdy Edwards,Inspector Forbes,Inspector Forrester&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Inspector Gregory,Inspector Tobias Gregson,Inspector Hill&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Inspector Stanley Hopkins,Inspector Athelney Jones&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commaArray = fileLines.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acculumator, currentValue, currentIndex, array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> acculumator.<span class="title function_">concat</span>(currentValue.<span class="title function_">split</span>(<span class="regexp">/,/g</span>))</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(commaArray)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Algar&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Bardle&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Mr. Barker&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Barton&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Baynes&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Bradstreet&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Sam Brown&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Monsieur Dubugue&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Birdy Edwards&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Forbes&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Forrester&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Gregory&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Tobias Gregson&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Hill&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Stanley Hopkins&#x27;,</span></span><br><span class="line"><span class="comment">    &#x27;Inspector Athelney Jones&#x27;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>用reduce实现flatMap</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组的flatMap</span></span><br><span class="line"><span class="comment">// flatMap的底层的操作：先使用map操作，然后对得到的数组仅展开一层再得到一个数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;今天天气不错&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;早上好&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> flatMapArr = arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flatMapArr) <span class="comment">// [&#x27;今&#x27;, &#x27;天&#x27;, &#x27;天&#x27;,&#x27;气&#x27;, &#x27;不&#x27;, &#x27;错&#x27;,&#x27;早&#x27;, &#x27;上&#x27;, &#x27;好&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的reduce实现数组的flatMap</span></span><br><span class="line"><span class="keyword">let</span> reduceFlatMap = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acculumator, currentValue, currentIndex, array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...acculumator, ...currentValue.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)]</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reduceFlatMap) <span class="comment">// [&#x27;今&#x27;, &#x27;天&#x27;, &#x27;天&#x27;,&#x27;气&#x27;, &#x27;不&#x27;, &#x27;错&#x27;,&#x27;早&#x27;, &#x27;上&#x27;, &#x27;好&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>按顺序执行异步函数</li></ol><p>根据userList数组的name属性去依次请求数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> asyncReducer = userList.<span class="title function_">reduce</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">acculumator, currentValue, currentIndex, array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">await</span> acculumator.<span class="title function_">then</span>()</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 用 setTimeout 模拟请求数组</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">`to=&gt;<span class="subst">$&#123;currentValue.username&#125;</span>`</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;...obj, [currentValue.<span class="property">username</span>]: re&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123;&#125;))</span><br><span class="line">asyncReducer.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3s之后打印：</span></span><br><span class="line"><span class="comment">// &#123; john: &#x27;to=&gt;john&#x27;, jerry: &#x27;to=&gt;jerry&#x27;, nancy: &#x27;to=&gt;nancy&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>记住在处理对象数组时要指定一个initialValue</li><li>数字数组使用reduce代码干净，请尽量不要把reduce函数过于复杂</li><li>不要忘记在回调函数中返回，否则最后得到的值将可能出现错误</li><li>回调函数的第三个参数index访问迭代次数</li><li>reduce处理时会跳过数组空值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组中的reduce犹如一只魔法棒，通过它可以做一些黑科技一样的事情。本文从api讲解到一般用法再到高级用法，由浅入深的讲一讲数组中的reduce。&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScrip</summary>
      
    
    
    
    
    <category term="数组" scheme="https://justsso1.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中的安全</title>
    <link href="https://justsso1.github.io/2020/06/17/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%AE%89%E5%85%A8/"/>
    <id>https://justsso1.github.io/2020/06/17/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%AE%89%E5%85%A8/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器中的安全"><a href="#浏览器中的安全" class="headerlink" title="浏览器中的安全"></a>浏览器中的安全</h1><p>浏览器中的安全分为三大块。Web网页安全，浏览器网络 安全和浏览系统安全。</p><p>安全策略：同源策略（Same-Origin policy）。如果两个url，协议相同、域名相同、端口相同，那么这两个url是同源的。浏览器认为两个相同的源之间是可以互相访问资源和操作dom的。两个不同的源之间想要访问资源或操作dom，那么会有一套安全机制制约，我们把这叫做同源策略。</p><p>同源策略会隔离不同源的DOM、，页面数据安全和网络通信，进而实现web页面的安全性。</p><ol><li>页面中可以引用第三方资源，不过这也暴露了很多诸多XSS的安全问题，比如页面加载了一个恶意脚本，该脚本会窃取用户的cookie信息。为了解决XSS攻击，浏览器中增加了CSP（内容安全策略），CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器能够执行哪些内联JavaScript代码。</li><li>使用XMLHttpRequest和Fetch都是无法直接进行跨域请求的，因此浏览器在这种严格模式之上引入了CORS（跨域资源共享），让其可以安全的跨域。</li><li>两个不同的源的DOM是不能互相操作的，因此浏览器中出现了跨文档消息机制，让其可以比较安全的通信。</li></ol><h2 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h2><p>XSS(Cross Site Scripting)跨站脚本攻击，主要是网站加载了一些恶意脚本。恶意脚本会做以下恶事，窃取用户的cookie信息，监听用户行为，比如获取用户的输入信息；在页面生成广告。</p><h3 id="恶意脚本是怎么被注入的"><a href="#恶意脚本是怎么被注入的" class="headerlink" title="恶意脚本是怎么被注入的:"></a>恶意脚本是怎么被注入的:</h3><ul><li>存储型XSS</li></ul><p>黑客将恶意脚本存储到正常服务器中，当用户请求到包含有恶意脚本的网页时，用户的浏览器就会执行恶意脚本，恶意脚本窃取用户cookie发送到黑客服务器</p><p>以喜马拉雅为例，黑客将一张专辑的名字命名为<code>&lt;script src=&quot;aaa.com/b.js&quot;&gt;&lt;/script&gt;</code>，服务器将这个名字存储到数据库了，然后普通用户看这个专辑时，浏览器就会请求恶意脚本，恶意脚本会读取用户的cookie，这样用户cookie被盗用，黑客可以冒用用户登录做一些恶事了。</p><ul><li>反射型XSS</li></ul><p>恶意脚本属于用户发送给服务器端请求的一部分，然后服务器端再将恶意脚本返回给浏览器端，当恶意JavaScript脚本在用户页面中被执行时，黑客就可以利用该恶意脚本做一些事情。<br>比如一个不明链接，该链接的query中包含<code>&lt;script&gt;alert(&quot;你被攻击了&quot;)&lt;/script&gt;</code>，那么当用户不小心点了这个链接，发送到服务器，服务器收到请求后，又将恶意代码发送给了浏览器端，这样浏览器端就读取并执行了<code>&lt;script&gt;alert(&quot;你被攻击了&quot;)&lt;/script&gt;</code></p><ul><li>基于DOM的XSS</li></ul><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p><p>存储型XSS和反射性XSS是服务器的安全漏洞，基于DOM的XSS是浏览器的安全漏洞。不论哪种XSS，都是要先在浏览器中注入恶意脚本，然后通过恶意脚本再将用户信息发送到黑客服务器上。所以关键还是得浏览器端阻止恶意脚本的注入和恶意消息的发送。</p><p>基于XSS攻击，我们应该怎么防控呢？</p><ul><li>服务器对于输入脚本做过滤，转码</li><li>前端符合CSP规范</li><li><strong>cookie 中有 HttpOnly属性</strong>，针对cookie 使用httponly，禁止JavaScript操作cookie。</li></ul><p>说道CSP，要仔细聊聊具体要怎么做，才叫符合CSP规范呢？<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></p><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>CSRF(Cross Site Request Forgerys)跨站请求伪造，关键的点有，目标服务器存在漏洞、用户登录过网站并有登录态、用户被诱导进入黑客网站并用用户的登录态发送了伪造请求</p><p>CSSRF攻击，主要是利用用户登录，请求服务器的漏洞接口，所以我们的主力放在用户登录态和服务器上做以下几点来防范：</p><ul><li>从用户登录态着手，用户的登录态和<code>cookie</code>有着紧密的联系，如果我们让第三方网站读取不到用户的登录态，也就构不成危害操作了。<code>cookie</code>的<code>Samesite</code>可以做到禁止某些<code>cookie</code>发送。</li></ul><p>Samesite 选项通常有Strict Lax none 三个值</p><pre><code>1. Strict最严格，禁止第三方Cookie2. Lax 宽松，第三方站点的get方式可以携带cookie，通过 img、iframe 等标签加载的 UR禁止第三方cookie3. 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</code></pre><ul><li><p>服务器检查发起请求的网站来源，通过http头的referer和origin 检查请求来源网站是不是可靠的，进行过滤.<br>Origin只有域名，referer有域名和具体地址</p></li><li><p>服务器增加CSRF token，浏览器向服务器发起请求，服务器将csrf token注入到浏览器端，如果浏览器发送的请求不包含csrf token的话，那么服务器将验证token不合法，会拒绝请求。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器中的安全&quot;&gt;&lt;a href=&quot;#浏览器中的安全&quot; class=&quot;headerlink&quot; title=&quot;浏览器中的安全&quot;&gt;&lt;/a&gt;浏览器中的安全&lt;/h1&gt;&lt;p&gt;浏览器中的安全分为三大块。Web网页安全，浏览器网络 安全和浏览系统安全。&lt;/p&gt;
&lt;p&gt;安全策略：</summary>
      
    
    
    
    <category term="浏览器" scheme="https://justsso1.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="安全" scheme="https://justsso1.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Chrome开发者工具</title>
    <link href="https://justsso1.github.io/2020/06/04/%E6%B5%8F%E8%A7%88%E5%99%A8-Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    <id>https://justsso1.github.io/2020/06/04/%E6%B5%8F%E8%A7%88%E5%99%A8-Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</id>
    <published>2020-06-03T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome开发者工具：利用网络面板做性能分析</p><p>渲染流水线：CSS如何影响首次加载时的白屏时间</p><p>如何系统地优化页面？</p><p>虚拟dom</p><p>当页面dom节点很多时，js操作真实的dom会触发重排重绘合成等一系列操作，很影响页面性能。所以需要虚拟dom来做真实dom的缓存层，当页面有变化时，会比较前后两颗虚拟dom，找出真正需要变化的点，然后更新它，然后再更新真实的dom,这样可以减少不必要的渲染，提高性能。</p><p>两个虚拟dom的比较过程，在react中更新的机制叫做filber reconciler。以前用的是reconciler算法，reconciler算法使用递归比较，当虚拟dom比较复杂时，会带来问题，比较函数会占据主线程过久，导致其他任务等待，造成页面卡顿。所以react团队更新了reconciler算法，叫做filber reconciler，类似于“协程”，执行一段时间会出让主线程，不会占用主线程过久。</p><p>虚拟dom更新使用的算法是diff算法。</p><p>mvc mvvm</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Chrome开发者工具：利用网络面板做性能分析&lt;/p&gt;
&lt;p&gt;渲染流水线：CSS如何影响首次加载时的白屏时间&lt;/p&gt;
&lt;p&gt;如何系统地优化页面？&lt;/p&gt;
&lt;p&gt;虚拟dom&lt;/p&gt;
&lt;p&gt;当页面dom节点很多时，js操作真实的dom会触发重排重绘合成等一系列操作，很影响页面性</summary>
      
    
    
    
    <category term="浏览器" scheme="https://justsso1.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="开发者工具" scheme="https://justsso1.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>事件循环机制[Node.js]篇</title>
    <link href="https://justsso1.github.io/2020/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6[Node.js%E7%AF%87]/"/>
    <id>https://justsso1.github.io/2020/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6[Node.js%E7%AF%87]/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://lynnelv.github.io/js-event-loop-browser">浏览器篇</a>已经对事件循环机制和一些相关的概念作了详细介绍，但主要是针对浏览器端的研究，Node环境是否也一样呢？先看一个demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>肉眼编译运行一下，蒽，在浏览器的结果就是下面这个了，道理都懂，就不累述了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><p>那么Node下执行看看，咦。。。奇怪，跟浏览器的运行结果并不一样~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><p>例子说明，浏览器和 Node.js 的事件循环机制是有区别的，一起来看个究竟吧~</p><h2 id="Node-js的事件处理"><a href="#Node-js的事件处理" class="headerlink" title="Node.js的事件处理"></a>Node.js的事件处理</h2><p><a href="https://en.wikipedia.org/wiki/Node.js">Node.js</a>采用V8作为js的解析引擎，而I&#x2F;O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现，<a href="https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c#L348-L397">核心源码参考</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uv_run</span><span class="params">(<span class="type">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> timeout;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="type">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = <span class="built_in">uv__loop_alive</span>(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    <span class="built_in">uv__update_time</span>(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">uv__update_time</span>(loop);</span><br><span class="line">    <span class="comment">// timers阶段</span></span><br><span class="line">    <span class="built_in">uv__run_timers</span>(loop);</span><br><span class="line">    <span class="comment">// I/O callbacks阶段</span></span><br><span class="line">    ran_pending = <span class="built_in">uv__run_pending</span>(loop);</span><br><span class="line">    <span class="comment">// idle阶段</span></span><br><span class="line">    <span class="built_in">uv__run_idle</span>(loop);</span><br><span class="line">    <span class="comment">// prepare阶段</span></span><br><span class="line">    <span class="built_in">uv__run_prepare</span>(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = <span class="built_in">uv_backend_timeout</span>(loop);</span><br><span class="line">    <span class="comment">// poll阶段</span></span><br><span class="line">    <span class="built_in">uv__io_poll</span>(loop, timeout);</span><br><span class="line">    <span class="comment">// check阶段</span></span><br><span class="line">    <span class="built_in">uv__run_check</span>(loop);</span><br><span class="line">    <span class="comment">// close callbacks阶段</span></span><br><span class="line">    <span class="built_in">uv__run_closing_handles</span>(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="built_in">uv__update_time</span>(loop);</span><br><span class="line">      <span class="built_in">uv__run_timers</span>(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = <span class="built_in">uv__loop_alive</span>(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">Node.js</a>官方介绍，每次事件循环都包含了6个阶段，对应到 libuv 源码中的实现，如下图所示</p><p><img src="/Users/ssojust/gitproject/blogs/imgs/event_loop/node-libuv.png"></p><ul><li><strong>timers 阶段</strong>：这个阶段执行timer（<code>setTimeout</code>、<code>setInterval</code>）的回调</li><li><strong>I&#x2F;O callbacks 阶段</strong>：执行一些系统调用错误，比如网络通信的错误回调</li><li><strong>idle, prepare 阶段</strong>：仅node内部使用</li><li><strong>poll 阶段</strong>：获取新的I&#x2F;O事件, 适当的条件下node将阻塞在这里</li><li><strong>check 阶段</strong>：执行 <code>setImmediate()</code> 的回调</li><li><strong>close callbacks 阶段</strong>：执行 <code>socket</code> 的 <code>close</code> 事件回调</li></ul><p>我们重点看<code>timers</code>、<code>poll</code>、<code>check</code>这3个阶段就好，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p><h3 id="timers-阶段"><a href="#timers-阶段" class="headerlink" title="timers 阶段"></a>timers 阶段</h3><p>timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，<code>setTimeout()</code> 和 <code>setImmediate()</code> 的执行顺序是不确定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是把它们放到一个I&#x2F;O回调里面，就一定是 <code>setImmediate()</code> 先执行，因为poll阶段后面就是check阶段。</p><h3 id="poll-阶段"><a href="#poll-阶段" class="headerlink" title="poll 阶段"></a>poll 阶段</h3><p>poll 阶段主要有2个功能：</p><ul><li>处理 poll 队列的事件</li><li>当有已超时的 timer，执行它的回调函数</li></ul><p>even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的<code>setImmediate()</code>，分两种情况：</p><ol><li>若有预设的<code>setImmediate()</code>, event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</li><li>若没有预设的<code>setImmediate()</code>，event loop将阻塞在该阶段等待</li></ol><p>注意一个细节，没有<code>setImmediate()</code>会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</p><h3 id="check-阶段"><a href="#check-阶段" class="headerlink" title="check 阶段"></a>check 阶段</h3><p><code>setImmediate()</code>的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>event loop 的每个阶段都有一个任务队列</li><li>当 event loop 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段</li><li>当所有阶段被顺序执行一次后，称 event loop 完成了一个 tick</li></ul><p>讲得好有道理，可是没有demo我还是理解不全啊，憋急，now！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;readFile&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果应该都没有疑问了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readFile</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><h2 id="Node-js-与浏览器的-Event-Loop-差异"><a href="#Node-js-与浏览器的-Event-Loop-差异" class="headerlink" title="Node.js 与浏览器的 Event Loop 差异"></a>Node.js 与浏览器的 Event Loop 差异</h2><p>回顾上一篇，浏览器环境下，<code>microtask</code>的任务队列是每个<code>macrotask</code>执行完之后执行。</p><p><img src="/Users/ssojust/gitproject/blogs/imgs/event_loop/ma(i)crotask.png"></p><p>而在Node.js中，<code>microtask</code>会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行<code>microtask</code>队列的任务。</p><p><img src="/Users/ssojust/gitproject/blogs/imgs/event_loop/ma(i)crotask-in-node.png"></p><h2 id="demo回顾"><a href="#demo回顾" class="headerlink" title="demo回顾"></a>demo回顾</h2><p>回顾文章最开始的demo，全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；</p><p><img src="/Users/ssojust/gitproject/blogs/imgs/event_loop/node-excute-animate.gif"></p><p>首先进入timers阶段，执行timer1的回调函数，打印<code>timer1</code>，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印<code>timer2</code>；</p><p>至此，timer阶段执行结束，event loop进入下一个阶段之前，执行<code>microtask</code>队列的所有任务，依次打印<code>promise1</code>、<code>promise2</code>。</p><p>对比浏览器端的处理过程：</p><p><img src="/Users/ssojust/gitproject/blogs/imgs/event_loop/browser-excute-animate.gif"></p><h3 id="process-nextTick-VS-setImmediate"><a href="#process-nextTick-VS-setImmediate" class="headerlink" title="process.nextTick() VS setImmediate()"></a>process.nextTick() VS setImmediate()</h3><blockquote><p>In essence, the names should be swapped. process.nextTick() fires more immediately than setImmediate()</p></blockquote><p>来自官方文档有意思的一句话，从语义角度看，<code>setImmediate()</code> 应该比 <code>process.nextTick()</code> 先执行才对，而事实相反，命名是历史原因也很难再变。</p><p><code>process.nextTick()</code> 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 <code>process.nextTick()</code>，会导致出现I&#x2F;O starving（饥饿）的问题，比如下面例子的readFile已经完成，但它的回调一直无法执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"><span class="keyword">let</span> endtime</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;text.txt&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  endtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finish reading time: &#x27;</span>, endtime - starttime)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handler</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index++ &gt;= <span class="number">1000</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`nextTick <span class="subst">$&#123;index&#125;</span>`</span>)</span><br><span class="line">  process.<span class="title function_">nextTick</span>(handler)</span><br><span class="line">  <span class="comment">// console.log(`setImmediate $&#123;index&#125;`)</span></span><br><span class="line">  <span class="comment">// setImmediate(handler)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handler</span>()</span><br></pre></td></tr></table></figure><p><code>process.nextTick()</code>的运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nextTick 1</span><br><span class="line">nextTick 2</span><br><span class="line">......</span><br><span class="line">nextTick 999</span><br><span class="line">nextTick 1000</span><br><span class="line">finish reading time: 170</span><br></pre></td></tr></table></figure><p>替换成<code>setImmediate()</code>，运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setImmediate 1</span><br><span class="line">setImmediate 2</span><br><span class="line">finish reading time: 80</span><br><span class="line">......</span><br><span class="line">setImmediate 999</span><br><span class="line">setImmediate 1000</span><br></pre></td></tr></table></figure><p>这是因为嵌套调用的 <code>setImmediate()</code> 回调，被排到了下一次event loop才执行，所以不会出现阻塞。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>Node.js 的事件循环分为6个阶段</p></li><li><p>浏览器和Node 环境下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">microtask</span><br></pre></td></tr></table></figure><p>任务队列的执行时机不同</p><ul><li>Node.js中，<code>microtask</code> 在事件循环的各个阶段之间执行</li><li>浏览器端，<code>microtask</code> 在事件循环的 <code>macrotask</code> 执行完之后执行</li></ul></li><li><p>递归的调用<code>process.nextTick()</code>会导致I&#x2F;O starving，官方推荐使用<code>setImmediate()</code></p></li></ol><p>[参考资料]</p><ol><li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">event-loop-timers-and-nexttick</a></li><li><a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf">Node.js Event Loop 的理解 Timers，process.nextTick()</a></li><li><a href="https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c">libuv&#x2F;core.c</a></li><li><a href="https://github.com/nodejs/node/blob/master/lib/internal/process/next_tick.js">nodejs&#x2F;next_tick.js</a></li><li><a href="http://lynnelv.github.io/js-event-loop-browser">深入理解js事件循环机制（浏览器篇）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;http://lynnelv.github.io/js-event-loop-browser&quot;&gt;浏览器篇&lt;/a&gt;已经对事件循环机制和一些相关的概念作了详细介绍，但主要是针对浏览器端的研究，Node环境是否也一样呢？先看一个demo：&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【转载】深入理解js事件循环机制[浏览器篇]</title>
    <link href="https://justsso1.github.io/2020/05/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6[%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87]/"/>
    <id>https://justsso1.github.io/2020/05/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6[%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87]/</id>
    <published>2020-05-30T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解js事件循环机制-浏览器篇"><a href="#深入理解js事件循环机制-浏览器篇" class="headerlink" title="深入理解js事件循环机制[浏览器篇]"></a>深入理解js事件循环机制[浏览器篇]</h1><p>事件循环是JavaScript语言在处理多任务时的一种机制，由于JavaScript是单线程，所以当有异步任务发生时，需要一种机制来协调任务触发，避免等待太久，就好比交通规则一样。JavaScript解析引擎结合所在的宿主环境（本文讲浏览器何NodeJS）<br>产生了各自的事件循环机制。抛开环境谈运行，和抛开计量谈毒性一样，所以一定要区分清楚是在哪里运行，在浏览器还是NodeJS。<br>浏览器中的事件循环由H5规范约定、由各浏览器厂商实现；而NodeJS中的事件循环由libuv自己实现的。</p><p>Event Loop在浏览器下和Node js环境下各有一套规则。</p><p>众所周知，javascript是单线程语言。单线程是什么？单线程是指js引擎中负责解析执行js代码的线程只有一个（主线程）即每次只能做一件事。那单线程是怎么做到异步的呢？</p><p>js的任务分为 <em>同步</em> 和 <em>异步</em> 两种，它们的处理方式也不同，<strong>同步任务</strong>是直接在主线程上排队执行，<strong>异步任务</strong>则会被放到任务队列中，若有多个任务（异步任务）则要在任务队列中排队等待，任务队列类似一个缓冲区，任务下一步会被移到<strong>调用栈</strong>（call stack），然后主线程执行调用栈的任务。</p><p>单线程是指js引擎中负责解析执行js代码的线程只有一个（<strong>主线程</strong>），即每次只能做一件事，而我们知道一个ajax请求，主线程在等待它响应的同时是会去做其它事的，浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求的方式是异步的。</p><p><u>总而言之，检查调用栈是否为空，以及确定把哪个task加入调用栈的这个过程就是<strong>事件循环</strong>，而<strong>js实现异步的核心就是事件循环</strong>。</u></p><p><strong>事件循环机制是为了处理异步操作的行为，所以这里是的[任务队列]是存储异步操作完成之后的回调函数的地方。 按异步操作的完成先后插入队列。</strong></p><p>因此setTime(fn, 0)就会及时插入队列，但不会立即执行。</p><h3 id="调用栈和任务队列"><a href="#调用栈和任务队列" class="headerlink" title="调用栈和任务队列"></a>调用栈和任务队列</h3><p>顾名思义，调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。</p><p>下图就是调用栈和任务队列的关系图</p><p><img src="/imgs/event_loop/callstack.png"></p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>关于事件循环，<a href="https://www.w3.org/TR/html5/webappapis.html#event-loop">HTML规范</a>的介绍</p><blockquote><p>There must be at least one event loop per user agent, and at most one event loop per unit of related similar-origin browsing contexts.<br>An event loop has one or more task queues.<br>Each task is defined as coming from a specific task source.</p></blockquote><p>从规范理解，浏览器至少有一个事件循环，一个事件循环至少有一个任务队列（macrotask），每个外任务都有自己的分组，浏览器会为不同的任务组设置优先级。</p><h3 id="macrotask-microtask"><a href="#macrotask-microtask" class="headerlink" title="macrotask &amp; microtask"></a>macrotask &amp; microtask</h3><p>规范有提到两个概念，但没有详细介绍，查阅一些资料大概可总结如下：</p><blockquote><p><strong>macrotask</strong>：包含执行整体的js代码，事件回调，XHR回调，定时器（setTimeout&#x2F;setInterval&#x2F;setImmediate），IO操作，UI render</p></blockquote><blockquote><p><strong>microtask</strong>：更新应用程序状态的任务，包括promise回调，MutationObserver，process.nextTick，Object.observe</p></blockquote><p>其中<code>setImmediate</code>和<code>process.nextTick</code>是nodejs的实现，在<a href="http://lynnelv.github.io/js-event-loop-nodejs">nodejs篇</a>会详细介绍。</p><h3 id="事件处理过程"><a href="#事件处理过程" class="headerlink" title="事件处理过程"></a>事件处理过程</h3><p>关于<code>macrotask</code>和<code>microtask</code>的理解，光这样看会有些晦涩难懂，结合事件循坏的机制理解清晰很多，下面这张图可以说是介绍得非常清楚了。</p><p><img src="/imgs/event_loop/event-loop.jpg"></p><p>总结起来，一次事件循环的步骤包括：</p><ol><li>检查macrotask队列是否为空，非空则到2，为空则到3</li><li>执行macrotask中的一个任务</li><li>继续检查microtask队列是否为空，若有则到4，否则到5</li><li>取出microtask中的任务执行，执行完成返回到步骤3</li><li>执行视图更新</li></ol><h3 id="mactotask-microtask的执行顺序"><a href="#mactotask-microtask的执行顺序" class="headerlink" title="mactotask &amp; microtask的执行顺序"></a>mactotask &amp; microtask的执行顺序</h3><p><img src="/imgs/event_loop/ma(i)crotask.png"></p><p>读完这么多干巴巴的概念介绍，还不如看一段代码感受下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>打印台输出的log顺序是什么？结合上述的步骤分析，系不系so easy~</p><p><img src="/imgs/event_loop/browser-deom1-excute-animate.gif"></p><p>首先，全局代码（main()）压入调用栈执行，打印<code>start</code>；</p><p>接下来setTimeout压入macrotask队列，promise.then回调放入microtask队列，最后执行console.log(‘end’)，打印出<code>end</code>；</p><p>至此，调用栈中的代码被执行完成，回顾macrotask的定义，我们知道全局代码属于macrotask，macrotask执行完，那接下来就是执行microtask队列的任务了，执行promise回调打印<code>promise1</code>；</p><p>promise回调函数默认返回undefined，promise状态变为fullfill触发接下来的then回调，继续压入microtask队列，<strong>event loop会把当前的microtask队列一直执行完</strong>，此时执行第二个promise.then回调打印出<code>promise2</code>；</p><p>这时microtask队列已经为空，从上面的流程图可以知道，接下来主线程会去做一些UI渲染工作（不一定会做），然后开始下一轮event loop，执行setTimeout的回调，打印出<code>setTimeout</code>；</p><p>这个过程会不断重复，也就是所谓的<strong>事件循环</strong>。</p><h3 id="视图渲染的时机"><a href="#视图渲染的时机" class="headerlink" title="视图渲染的时机"></a>视图渲染的时机</h3><p>回顾上面的事件循环示意图，update rendering（视图渲染）发生在本轮事件循环的microtask队列被执行完之后，也就是说执行任务的耗时会影响视图渲染的时机。通常浏览器以每秒60帧（60fps）的速率刷新页面，据说这个帧率最适合人眼交互，大概16.7ms渲染一帧，所以如果要让用户觉得顺畅，单个macrotask及它相关的所有microtask最好能在16.7ms内完成。</p><p>但也不是每轮事件循环都会执行视图更新，浏览器有自己的优化策略，例如把几次的视图更新累积到一起重绘，重绘之前会通知requestAnimationFrame执行回调函数，也就是说requestAnimationFrame回调的执行时机是在一次或多次事件循环的UI render阶段。</p><p>以下代码可以验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;requestAnimationFrame&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise 1&#x27;</span>)</span><br><span class="line"><span class="title function_">resolve</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise 2&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果截图如下:</p><p><img src="/imgs/event_loop/requestAnimationFrame-run-result1.png"></p><p>可以看到，结果1中<code>requestAnimationFrame()</code>是在一次事件循环后执行，而在结果2，它的执行则是在三次事件循环结束后。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>事件循环是js实现异步的核心</p></li><li><p>每轮事件循环分为3个步骤：</p><blockquote><p>a) 执行macrotask队列的一个任务<br>b) 执行完当前microtask队列的所有任务<br>c) UI render</p></blockquote></li><li><p>浏览器只保证<code>requestAnimationFrame</code>的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定</p></li></ol><p>[参考资料]</p><ol><li><a href="https://www.w3.org/TR/html5/webappapis.html#event-loops">event-loops</a></li><li><a href="http://ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues">sec-jobs-and-job-queues</a></li><li><a href="https://promisesaplus.com/#notes">Promises&#x2F;A+</a></li><li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&utm_medium=email">Tasks, microtasks, queues and schedules</a></li><li><a href="https://zhuanlan.zhihu.com/p/24460769">HTML系列：macrotask和microtask</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解js事件循环机制-浏览器篇&quot;&gt;&lt;a href=&quot;#深入理解js事件循环机制-浏览器篇&quot; class=&quot;headerlink&quot; title=&quot;深入理解js事件循环机制[浏览器篇]&quot;&gt;&lt;/a&gt;深入理解js事件循环机制[浏览器篇]&lt;/h1&gt;&lt;p&gt;事件循环是Jav</summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
    <category term="事件循环" scheme="https://justsso1.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>Koa2的中间件原理</title>
    <link href="https://justsso1.github.io/2020/05/29/Koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://justsso1.github.io/2020/05/29/Koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-28T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.538Z</updated>
    
    <content type="html"><![CDATA[<p>koa2中间价的理论模型是洋葱模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1 &#x27;</span>)</span><br><span class="line">    next &amp;&amp; <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">    next &amp;&amp; <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn3&#x27;</span>)</span><br><span class="line">    next &amp;&amp; <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn3 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> middleware = [fn1, fn2, fn3]</span><br><span class="line"><span class="comment">//中间件的第二个参数都是next，且是一个函数，函数要返回要传递的函数，这样才不能在第二层传递时执行。 还有函数类型要是一个promise，才可以被await；所以使用了Promise.resolve()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose2</span>(<span class="params">middleware</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">h</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params">index</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> fn = middleware[index]</span><br><span class="line">            <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return fn(function next() &#123;</span></span><br><span class="line">            <span class="comment">//     return Promise.resolve(h(index + 1))</span></span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(</span><br><span class="line">                <span class="title function_">fn</span>(<span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">h</span>(index+<span class="number">1</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> finalFn = <span class="title function_">compose2</span>(middleware)</span><br><span class="line"><span class="title function_">finalFn</span>()</span><br><span class="line"><span class="comment">/*希望打印</span></span><br><span class="line"><span class="comment">fn1</span></span><br><span class="line"><span class="comment">fn2</span></span><br><span class="line"><span class="comment">fn3</span></span><br><span class="line"><span class="comment">fn3 end</span></span><br><span class="line"><span class="comment">fn2 end</span></span><br><span class="line"><span class="comment">fn1 end</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;koa2中间价的理论模型是洋葱模式。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
    <category term="koa2中间件" scheme="https://justsso1.github.io/tags/koa2%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>用npm script打造超溜的前端工作流2</title>
    <link href="https://justsso1.github.io/2020/05/14/%E7%94%A8npm%20script%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%812/"/>
    <id>https://justsso1.github.io/2020/05/14/%E7%94%A8npm%20script%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%812/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>^版本号： 会匹配到主版本号（第一位数字）中最新的版本。例如： ^3.4.1 会匹配到3.x.x的最新版本，不会匹配到4.0.0<br>~版本号：会匹配到第二位数字中最新的版本。例如： ～1.15.2会匹配到 1.15.x的最新版本，不会匹配到1.16.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;^版本号： 会匹配到主版本号（第一位数字）中最新的版本。例如： ^3.4.1 会匹配到3.x.x的最新版本，不会匹配到4.0.0&lt;br&gt;~版本号：会匹配到第二位数字中最新的版本。例如： ～1.15.2会匹配到 1.15.x的最新版本，不会匹配到1.16.0&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="npm" scheme="https://justsso1.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>用npm script打造超溜的前端工作流1</title>
    <link href="https://justsso1.github.io/2020/05/13/%E7%94%A8npm%20script%20%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%811/"/>
    <id>https://justsso1.github.io/2020/05/13/%E7%94%A8npm%20script%20%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%811/</id>
    <published>2020-05-12T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>1.1 初识 npm script<br>首先介绍创建 package.json 文件的科学方法，目标是掌握 npm init 命令。然后，通过在终端中运行自动生成的 test 命令，详细讲解 npm 脚本基本执行流程。 然后，动手给项目增加 eslint 命令，熟悉创建自定义命令的基本流程。</p><p>用 npm init 快速创建项目<br>开始探索 npm script 之前，我们先聊聊这些 scripts 所依赖的文件 package.json，以它为基础的 npm 则是 node.js 社区蓬勃发展的顶梁柱。</p><p>npm 为我们提供了快速创建 package.json 文件的命令 npm init，执行该命令会问几个基本问题，如包名称、版本号、作者信息、入口文件、仓库地址、许可协议等，多数问题已经提供了默认值，你可以在问题后敲回车接受默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package name: (hello-npm-script)</span><br><span class="line">version: (0.1.0)</span><br><span class="line">description: hello npm script</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords: npm, script</span><br><span class="line">license: (MIT)</span><br></pre></td></tr></table></figure><p>上面的例子指定了描述（description）和关键字（keywords）两个字段，基本问题问完之后 npm 会把 package.json 文件内容打出来供你确认：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hello-npm-script&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;hello npm script&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;npm&quot;,</span><br><span class="line">    &quot;script&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;wangshijun &lt;wangshijun2010@gmail.com&gt; (https://github.com/wangshijun)&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按回车确认就能把package.json 的内容写到文件系统，如果要修改 package.json，可以直接用编辑器编辑，或者再次运行 npm init，npm 默认不会覆盖修改里面已经存在的信息。</p><blockquote><p>TIP#1: 嫌上面的初始化方式太啰嗦？你可以使用 npm init -f（意指 –force，或者使用 –yes）告诉 npm 直接跳过参数问答环节，快速生成 package.json。</p></blockquote><p>初始化 package.json 时的字段默认值是可以自己配置的，细心的同学可能已经发现，我上面的默认版本号是 0.1.0，而 npm 默认的版本号是 0.0.1，可以用下面的命令去修改默认配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm config set init.author.email &quot;wangshijun2010@gmail.com&quot;</span><br><span class="line">npm config set init.author.name &quot;wangshijun&quot;</span><br><span class="line">npm config set init.author.url &quot;http://github.com/wangshijun&quot;</span><br><span class="line">npm config set init.license &quot;MIT&quot;</span><br><span class="line">npm config set init.version &quot;0.1.0&quot;</span><br></pre></td></tr></table></figure><blockquote><p>TIP#2: 将默认配置和 -f 参数结合使用，能让你用最短的时间创建 package.json，快去自己试试吧。</p></blockquote><p>严肃的工程师都会使用 Git 对源代码进行版本管理，在 npm init 的基础上，你可以使用 git init 来初始化 git 仓库，不再展开。</p><p>纸上得来终觉浅，想掌握 npm script，请打开终端，执行下列命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir hello-npm-script &amp;&amp; cd $_</span><br><span class="line">npm init</span><br><span class="line">npm init -f</span><br></pre></td></tr></table></figure><h3 id="用-npm-run-执行任意命令"><a href="#用-npm-run-执行任意命令" class="headerlink" title="用 npm run 执行任意命令"></a>用 npm run 执行任意命令</h3><p>npm 是如何管理和执行各种 scripts 的呢？作为 npm 内置的核心功能之一，npm run 实际上是 npm run-script 命令的简写。当我们运行 npm run xxx 时，基本步骤如下：</p><ol><li>从 package.json 文件中读取 scripts 对象里面的全部配置；</li><li>以传给 npm run 的第一个参数作为键，本例中为 xxx，在 scripts 对象里面获取对应的值作为接下来要执行的命令，如果没找到直接报错；</li><li>在系统默认的 shell 中执行上述命令，系统默认 shell 通常是 bash，windows 环境下可能略有不同，稍后再讲。</li></ol><p>注意，上面这是简化的流程，更复杂的钩子机制后面章节单独介绍。</p><p>举例来说，如果 package.json 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hello-npm-script&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;latest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;eslint **.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不带任何参数执行 npm run，它会列出可执行的所有命令，比如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available scripts in the myproject package:</span><br><span class="line">  eslint</span><br><span class="line">    eslint **.js</span><br></pre></td></tr></table></figure><p>如果运行 npm run eslint，npm 会在 shell 中运行 eslint **.js。</p><p>有没有好奇过上面的 eslint 命令是从哪里来的？其实，npm 在执行指定 script 之前会把 node_modules&#x2F;.bin 加到环境变量 $PATH 的前面，这意味着任何内含可执行文件的 npm 依赖都可以在 npm script 中直接调用，换句话说，你不需要在 npm script 中加上可执行文件的完整路径，比如 .&#x2F;node_modules&#x2F;.bin&#x2F;eslint **.js。</p><h3 id="创建自定义-npm-script"><a href="#创建自定义-npm-script" class="headerlink" title="创建自定义 npm script"></a>创建自定义 npm script</h3><p>知道如何运行 npm script 之后，接下来我们在 hello-npm-script 项目中添加有实际用途的 eslint 脚本，eslint 是社区中接受度比较高的 javascript 风格检查工具，有大把现成的规则集可供你选择，比如 google、 airbnb。</p><p>在新项目或者任何现有项目中添加 eslint 自定义脚本的步骤如下：</p><ol><li>准备被检查的代码</li></ol><p>要做代码检查，我们必须有代码，创建 index.js 文件，输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const str = &#x27;some value&#x27;;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(&#x27;some log&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加 eslint 依赖</li></ol><p>执行如下命令将 eslint 添加为 devDependencies：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint -D</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化 eslint 配置<br>用 eslint 做检查需要配置规则集，存放规则集的文件就是配置文件，使用如下文件生成配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/eslint --init</span><br></pre></td></tr></table></figure><blockquote><p>TIP#3: 把 eslint 安装为项目依赖而非全局命令，项目可移植性更高。</p></blockquote><p>在命令行提示中选择 Answer questions about your style，如下图回答几个问题，答案可以根据自己的偏好：<br><img src="/../imgs/eslint.png"></p><p>回车后根目录下就有了 .eslintrc.js 配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    es6: true,</span><br><span class="line">    node: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: &#x27;eslint:recommended&#x27;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    indent: [&#x27;error&#x27;, 4],</span><br><span class="line">    &#x27;linebreak-style&#x27;: [&#x27;error&#x27;, &#x27;unix&#x27;],</span><br><span class="line">    quotes: [&#x27;error&#x27;, &#x27;single&#x27;],</span><br><span class="line">    semi: [&#x27;error&#x27;, &#x27;always&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加 eslint 命令<br>在 package.json 的 scripts 字段中新增命令 eslint：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动修改 package.json 时一定要注意语法正确。</p><ol start="5"><li>运行 eslint 命令</li></ol><p>执行 npm run eslint，可以看到，按照官方推荐规则代码里有 3 处不符合规范的地方：</p><p>20171205 增补：eslint 完成 react、vue.js 代码的检查<br>如果需要结合 eslint 检查主流前端框架 react、vue.js，下面提供两条线索，因为官方仓库的 README 就可以作为入门文档，仔细读读相信绝大多数同学都能配置好。</p><p>使用 eslint-plugin-react 检查 react 代码，使用 react-plugin-react-native 检查 react-native 代码，如果你比较懒，可以直接使用 eslint-config-airbnb，里面内置了 eslint-plugin-react，新人常遇到 peerDependencies 安装失败问题可参照 npmjs 主页上的如下方法解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  export PKG=eslint-config-airbnb;</span><br><span class="line">  npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &#x27;s/[\&#123;\&#125;,]//g ; s/: /@/g&#x27; | xargs npm install --save-dev &quot;$PKG@latest&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>推荐使用 vue.js 官方的 eslint 插件：eslint-plugin-vue 来检查 vue.js 代码，具体的配置方法官方 README 写的清晰明了，这里就不赘述了。</p><p>上面的几种 eslint 规则集的官方仓库都列出了各自支持的规则，如果你需要关闭某些规则，可以直接在自己的 .eslintrc* 里面的 rules 中配置，比如我们仓库里面的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    es6: true,</span><br><span class="line">    node: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: &#x27;eslint:recommended&#x27;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    indent: [&#x27;error&#x27;, 2],</span><br><span class="line">    &#x27;linebreak-style&#x27;: [&#x27;error&#x27;, &#x27;unix&#x27;],</span><br><span class="line">    quotes: [&#x27;error&#x27;, &#x27;single&#x27;],</span><br><span class="line">    semi: [&#x27;error&#x27;, &#x27;always&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>20171205 增补：eslint 完成 react、vue.js 代码的检查<br>如果需要结合 eslint 检查主流前端框架 react、vue.js，下面提供两条线索，因为官方仓库的 README 就可以作为入门文档，仔细读读相信绝大多数同学都能配置好。</p><p>使用 eslint-plugin-react 检查 react 代码，使用 react-plugin-react-native 检查 react-native 代码，如果你比较懒，可以直接使用 eslint-config-airbnb，里面内置了 eslint-plugin-react，新人常遇到 peerDependencies 安装失败问题可参照 npmjs 主页上的如下方法解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  export PKG=eslint-config-airbnb;</span><br><span class="line">  npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &#x27;s/[\&#123;\&#125;,]//g ; s/: /@/g&#x27; | xargs npm install --save-dev &quot;$PKG@latest&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>推荐使用 vue.js 官方的 eslint 插件：eslint-plugin-vue 来检查 vue.js 代码，具体的配置方法官方 README 写的清晰明了，这里就不赘述了。</p><p>上面的几种 eslint 规则集的官方仓库都列出了各自支持的规则，如果你需要关闭某些规则，可以直接在自己的 .eslintrc* 里面的 rules 中配置，比如我们仓库里面的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    es6: true,</span><br><span class="line">    node: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: &#x27;eslint:recommended&#x27;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    indent: [&#x27;error&#x27;, 2],</span><br><span class="line">    &#x27;linebreak-style&#x27;: [&#x27;error&#x27;, &#x27;unix&#x27;],</span><br><span class="line">    quotes: [&#x27;error&#x27;, &#x27;single&#x27;],</span><br><span class="line">    semi: [&#x27;error&#x27;, &#x27;always&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-运行多个-npm-script-的各种姿势"><a href="#1-2-运行多个-npm-script-的各种姿势" class="headerlink" title="1.2 运行多个 npm script 的各种姿势"></a>1.2 运行多个 npm script 的各种姿势</h3><p>前端项目通常会包括多个 npm script，对多个命令进行编排是很自然的需求，有时候需要将多个命令串行，即脚本遵循严格的执行顺序；有时候则需要让它们并行来提高速度，比如不相互阻塞的 npm script。社区中也有比 npm 内置的多命令运行机制更好用的解决方案：npm-run-all。</p><h4 id="哪来那么多命令？"><a href="#哪来那么多命令？" class="headerlink" title="哪来那么多命令？"></a>哪来那么多命令？</h4><p>通常来说，前端项目会包含 js、css、less、scss、json、markdown 等格式的文件，为保障代码质量，给不同的代码添加检查是很有必要的，代码检查不仅保障代码没有低级的语法错误，还可确保代码都遵守社区的最佳实践和一致的编码风格，在团队协作中尤其有用，即使是个人项目，加上代码检查，也会提高你的效率和质量。</p><p>我通常会给前端项目加上下面 4 种代码检查：</p><ul><li><p>eslint，可定制的 js 代码检查，1.1 中有详细的配置步骤；</p></li><li><p>stylelint，可定制的样式文件检查，支持 css、less、scss；</p></li><li><p>jsonlint，json 文件语法检查，踩过坑的同学会清楚，json 文件语法错误会知道导致各种失败；</p></li><li><p>markdownlint-cli，Markdown 文件最佳实践检查，个人偏好；<br>需要注意的是，html 代码也应该检查，但是工具支持薄弱，就略过不表。此外，为代码添加必要的单元测试也是质量保障的重要手段，常用的单测技术栈是：</p></li><li><p>mocha，测试用例组织，测试用例运行和结果收集的框架；</p></li><li><p>chai，测试断言库，必要的时候可以结合 sinon 使用；<br>TIP#4：测试工具如 tap、ava 也都提供了命令行接口，能很好的集成到 npm script 中，原理是相通的。</p></li></ul><p>包含了基本的代码检查、单元测试命令的 package.json 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hello-npm-script&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;lint:js&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">    &quot;lint:css&quot;: &quot;stylelint *.less&quot;,</span><br><span class="line">    &quot;lint:json&quot;: &quot;jsonlint --quiet *.json&quot;,</span><br><span class="line">    &quot;lint:markdown&quot;: &quot;markdownlint --config .markdownlint.json *.md&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;mocha tests/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;chai&quot;: &quot;^4.1.2&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^4.11.0&quot;,</span><br><span class="line">    &quot;jsonlint&quot;: &quot;^1.6.2&quot;,</span><br><span class="line">    &quot;markdownlint-cli&quot;: &quot;^0.5.0&quot;,</span><br><span class="line">    &quot;mocha&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">    &quot;stylelint&quot;: &quot;^8.2.0&quot;,</span><br><span class="line">    &quot;stylelint-config-standard&quot;: &quot;^17.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="让多个-npm-script-串行？"><a href="#让多个-npm-script-串行？" class="headerlink" title="让多个 npm script 串行？"></a>让多个 npm script 串行？</h4><p>在我们运行测试之前确保我们的代码都通过代码检查会是比较不错的实践，这也是让多个 npm script 串行的典型用例，实现方式也比较简单，只需要用 &amp;&amp; 符号把多条 npm script 按先后顺序串起来即可，具体到我们的项目，修改如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">index c904250..023d71e 100644</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -8,7 +8,7 @@</span><br><span class="line">-    &quot;test&quot;: &quot;mocha tests/&quot;</span><br><span class="line">+    &quot;test&quot;: &quot;npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown &amp;&amp; mocha tests/&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>然后直接执行 npm test 或 npm t，从输出可以看到子命令的执行顺序是严格按照我们在 scripts 中声明的先后顺序来的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint ==&gt; stylelint ==&gt; jsonlint ==&gt; markdownlint ==&gt; mocha</span><br></pre></td></tr></table></figure><p>需要注意的是，串行执行的时候如果前序命令失败（通常进程退出码非0），后续全部命令都会终止，我们可以尝试在 index.js 中引入错误（删掉行末的分号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/index.js b/index.js</span><br><span class="line">index ab8bd0e..b817ea4 100644</span><br><span class="line">--- a/index.js</span><br><span class="line">+++ b/index.js</span><br><span class="line">@@ -4,7 +4,7 @@ const add = (a, b) =&gt; &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return NaN;</span><br><span class="line">-&#125;;</span><br><span class="line">+&#125;</span><br><span class="line"></span><br><span class="line"> module.exports = &#123; add  &#125;;</span><br></pre></td></tr></table></figure><p> 然后重新运行 npm t，结果如下，npm run lint:js 失败之后，后续命令都没有执行：</p><h4 id="让多个-npm-script-并行？"><a href="#让多个-npm-script-并行？" class="headerlink" title="让多个 npm script 并行？"></a>让多个 npm script 并行？</h4><p>在严格串行的情况下，我们必须要确保代码中没有编码规范问题才能运行测试，在某些时候可能并不是我们想要的，因为我们真正需要的是，代码变更时同时给出测试结果和测试运行结果。这就需要把子命令的运行从串行改成并行，实现方式更简单，把连接多条命令的 &amp;&amp; 符号替换成 &amp; 即可。</p><p>代码变更如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">index 023d71e..2d9bd6f 100644</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -8,7 +8,7 @@</span><br><span class="line">-    &quot;test&quot;: &quot;npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown &amp;&amp; mocha tests/&quot;</span><br><span class="line">+    &quot;test&quot;: &quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>重新运行 npm t，我们得到如下结果：<br><img src="/imgs/npm/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.png"></p><p>细心的同学可能已经发现上图中哪里不对，npm run lint:js 的结果在进程退出之后才输出，如果你自己运行，不一定能稳定复现这个问题，但 npm 内置支持的多条命令并行跟 js 里面同时发起多个异步请求非常类似，它只负责触发多条命令，而不管结果的收集，如果并行的命令执行时间差异非常大，上面的问题就会稳定复现。怎么解决这个问题呢？</p><p>答案也很简单，在命令的增加 &amp; wait 即可，这样我们的 test 命令长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/ &amp; wait</span><br></pre></td></tr></table></figure><p>加上 wait 的额外好处是，如果我们在任何子命令中启动了长时间运行的进程，比如启用了 mocha 的 –watch 配置，可以使用 ctrl + c 来结束进程，如果没加的话，你就没办法直接结束启动到后台的进程。</p><h3 id="有没有更好的管理方式？"><a href="#有没有更好的管理方式？" class="headerlink" title="有没有更好的管理方式？"></a>有没有更好的管理方式？</h3><p>有强迫症的同学可能会觉得像上面这样用原生方式来运行多条命令很臃肿，幸运的是，我们可以使用 npm-run-all 实现更轻量和简洁的多命令运行。</p><p>用如下命令将 npm-run-all 添加到项目依赖中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i npm-run-all -D</span><br><span class="line">然后修改 package.json 实现多命令的串行执行：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">index b3b1272..83974d6 100644</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -8,7 +8,8 @@</span><br><span class="line">-    &quot;test&quot;: &quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/ &amp; wait&quot;</span><br><span class="line">+    &quot;mocha&quot;: &quot;mocha tests/&quot;,</span><br><span class="line">+    &quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown mocha&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>npm-run-all 还支持通配符匹配分组的 npm script，上面的脚本可以进一步简化成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">index 83974d6..7b327cd 100644</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -9,7 +9,7 @@</span><br><span class="line">-    &quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown mocha&quot;</span><br><span class="line">+    &quot;test&quot;: &quot;npm-run-all lint:* mocha&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>如何让多个 npm script 并行执行？也很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">index 7b327cd..c32da1c 100644</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -9,7 +9,7 @@</span><br><span class="line">-    &quot;test&quot;: &quot;npm-run-all lint:* mocha&quot;</span><br><span class="line">+    &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>并行执行的时候，我们并不需要在后面增加 &amp; wait，因为 npm-run-all 已经帮我们做了。</p><blockquote><p>TIP#5：npm-run-all 还提供了很多配置项支持更复杂的命令编排，比如多个命令并行之后接串行的命令，感兴趣的同学请阅读文档，自己玩儿。</p></blockquote><h3 id="1-3-给-npm-script-传递参数和添加注释"><a href="#1-3-给-npm-script-传递参数和添加注释" class="headerlink" title="1.3 给 npm script 传递参数和添加注释"></a>1.3 给 npm script 传递参数和添加注释</h3><p>本小节会介绍 3 个知识点：给 npm script 传递参数以减少重复的 npm script；增加注释提高 npm script 脚本的可读性；控制运行时日志输出能让你专注在重要信息上。</p><p>给 npm script 传递参数<br>eslint 内置了代码风格自动修复模式，只需给它传入 –fix 参数即可，在 scripts 中声明检查代码命令的同时你可能也需要声明修复代码的命令，面对这种需求，大多数同学可能会忍不住复制粘贴，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">index c32da1c..b6fb03e 100644</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -5,6 +5,7 @@</span><br><span class="line">     &quot;lint:js&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">+    &quot;lint:js:fix&quot;: &quot;eslint *.js --fix&quot;,</span><br></pre></td></tr></table></figure><p>在 lint:js 命令比较短的时候复制粘贴的方法简单粗暴有效，但是当 lint:js 命令变的很长之后，难免后续会有人改了 lint:js 而忘记修改 lint:js:fix（别问我为啥，我就是踩着坑过来的），更健壮的做法是，在运行 npm script 时给定额外的参数，代码修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -5,6 +5,7 @@</span><br><span class="line">     &quot;lint:js&quot;: &quot;eslint *.js&quot;,</span><br><span class="line">+    &quot;lint:js:fix&quot;: &quot;npm run lint:js -- --fix&quot;,</span><br></pre></td></tr></table></figure><p>要格外注意 –fix 参数前面的 – 分隔符，意指要给 npm run lint:js 实际指向的命令传递额外的参数。</p><p>运行效果如下图：<br><img src="/imgs/npm/npm_fix.png"><br>上图第2个红色框里面是实际执行的命令，可以看到 –fix 参数附加在了后面。</p><blockquote><p>TIP#6：如果你不想单独声明 lint:js:fix 命令，在需要的时候直接运行： npm run lint:js – –fix 来实现同样的效果。</p></blockquote><p>问题来了，如果我想为 mocha 命令增加 –watch 模式方便在开发时立即看到测试结果，该怎么做呢？相信读到这里你心中已经有了答案。</p><p>:stuck_out_tongue:</p><h3 id="给-npm-script-添加注释"><a href="#给-npm-script-添加注释" class="headerlink" title="给 npm script 添加注释"></a>给 npm script 添加注释</h3><p>如果 package.json 中的 scripts 越来越多，或者出现复杂的编排命令，你可能需要给它们添加注释以保障代码可读性，但 json 天然是不支持添加注释的，下面是 2 种比较 trick 的方式。</p><p>第一种方式是，package.json 中可以增加 &#x2F;&#x2F; 为键的值，注释就可以写在对应的值里面，npm 会忽略这种键，比如，我们想要给 test 命令添加注释，按如下方式添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -10,6 +10,7 @@</span><br><span class="line">+    &quot;//&quot;: &quot;运行所有代码检查和单元测试&quot;,</span><br><span class="line">     &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot;</span><br></pre></td></tr></table></figure><p>这种方式的明显不足是，npm run 列出来的命令列表不能把注释和实际命令对应上，如果你声明了多个，npm run 只会列出最后那个，如下图：<br><img src="/imgs/npm/npm4.png"><br>另外一种方式是直接在 script 声明中做手脚，因为命令的本质是 shell 命令（适用于 linux 平台），我们可以在命令前面加上注释，具体做法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -10,8 +10,7 @@</span><br><span class="line">-    &quot;//&quot;: &quot;运行所有代码检查和单元测试&quot;,</span><br><span class="line">-    &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot;</span><br><span class="line">+    &quot;test&quot;: &quot;# 运行所有代码检查和单元测试 \n    npm-run-all --parallel lint:* mocha&quot;</span><br></pre></td></tr></table></figure><p>注意注释后面的换行符 \n 和多余的空格，换行符是用于将注释和命令分隔开，这样命令就相当于微型的 shell 脚本，多余的空格是为了控制缩进，也可以用制表符 \t 替代。这种做法能让 npm run 列出来的命令更美观，但是 scripts 声明阅读起来不那么整齐美观。</p><p><img src="/imgs/npm/npm5.png"></p><p>上面两种方式都有明显的缺陷，个人建议的更优方案还是把复杂的命令剥离到单独的文件中管理，在单独的文件中可以自由给它添加注释，详见后续章节。</p><h3 id="调整-npm-script-运行时日志输出"><a href="#调整-npm-script-运行时日志输出" class="headerlink" title="调整 npm script 运行时日志输出"></a>调整 npm script 运行时日志输出</h3><p>在运行 npm script 出现问题时你需要有能力去调试它，某些情况下你需要让 npm script 以静默的方式运行，这类需求可通过控制运行时日志输出级别来实现。</p><p>日志级别控制参数有好几个，简单举例如下：</p><h4 id="默认日志输出级别"><a href="#默认日志输出级别" class="headerlink" title="默认日志输出级别"></a>默认日志输出级别</h4><p>即不加任何日志控制参数得到的输出，可能是你最常用的，能看到执行的命令、命令执行的结果。</p><h4 id="显示尽可能少的有用信息"><a href="#显示尽可能少的有用信息" class="headerlink" title="显示尽可能少的有用信息"></a>显示尽可能少的有用信息</h4><p>结合其他工具调用 npm script 的时候比较有用，需要使用 –loglevel silent，或者 –silent，或者更简单的 -s 来控制，这个日志级别的输出实例如下（只有命令本身的输出，读起来非常的简洁）：</p><p><img src="/imgs/npm/npm6.png"></p><p>如果执行各种 lint script 的时候启用了 -s 配置，代码都符合规范的话，你不会看到任何输出，这就是没有消息是最好的消息的由来，哈哈！</p><h3 id="npm7npm显示尽可能多的运行时状态"><a href="#npm7npm显示尽可能多的运行时状态" class="headerlink" title="npm7npm显示尽可能多的运行时状态"></a>npm7npm显示尽可能多的运行时状态</h3><p>排查脚本问题的时候比较有用，需要使用 –loglevel verbose，或者 –verbose，或者更简单的 -d 来控制，这个日志级别的输出实例如下（详细打印出了每个步骤的参数、返回值，下面的截图只是部分）：</p><p><img src="/imgs/npm/npm7.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.1 初识 npm script&lt;br&gt;首先介绍创建 package.json 文件的科学方法，目标是掌握 npm init 命令。然后，通过在终端中运行自动生成的 test 命令，详细讲解 npm 脚本基本执行流程。 然后，动手给项目增加 eslint 命令，熟悉创建自</summary>
      
    
    
    
    <category term="前端工程化" scheme="https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="npm" scheme="https://justsso1.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>前端异常</title>
    <link href="https://justsso1.github.io/2020/05/11/%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8/"/>
    <id>https://justsso1.github.io/2020/05/11/%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8/</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2024-10-16T04:06:40.993Z</updated>
    
    <content type="html"><![CDATA[<p>做好前端异常，才能安心的放假啊</p><h2 id="一、为什么要处理异常？"><a href="#一、为什么要处理异常？" class="headerlink" title="一、为什么要处理异常？"></a>一、为什么要处理异常？</h2><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。<br>增强用户体验；<br>远程定位问题；<br>未雨绸缪，及早发现问题；<br>无法复线问题，尤其是移动端，机型，系统都是问题；<br>完善的前端方案，前端监控系统；<br>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。<br>异常是不可控的，因此做好前端异常的处理异常重要。</p><h2 id="二、需要处理哪些异常？"><a href="#二、需要处理哪些异常？" class="headerlink" title="二、需要处理哪些异常？"></a>二、需要处理哪些异常？</h2><p>前端要处理的异常分类：</p><ul><li>js 语法错误、代码异常</li><li>ajax请求异常</li><li>静态资源加载异常</li><li>Promise异常</li><li>Iframe异常</li><li>跨域script error</li><li>崩溃和卡顿</li></ul><h2 id="三、Try-Catch-的误区"><a href="#三、Try-Catch-的误区" class="headerlink" title="三、Try-Catch 的误区"></a>三、Try-Catch 的误区</h2><p>Try Catch只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nam)</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常&#x27;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常 <span class="title class_">ReferenceError</span>: nam is not defined</span><br></pre></td></tr></table></figure><p>try catch 捕获不到异步的异常</p><h2 id="九、iframe-异常"><a href="#九、iframe-异常" class="headerlink" title="九、iframe 异常"></a>九、iframe 异常</h2><p>对于 iframe 的异常捕获，我们还得借力 window.onerror：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的例子可能如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;./iframe.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">frames</span>[<span class="number">0</span>].<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到 iframe 异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="十、Script-error"><a href="#十、Script-error" class="headerlink" title="十、Script error"></a>十、Script error</h2><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：<br>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p><p>或者动态去添加 js 脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(‘script’);</span><br><span class="line">script.<span class="property">crossOrigin</span> = ‘anonymous’;</span><br><span class="line">script.<span class="property">src</span> = url;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>特别注意，服务器端需要设置：<code>Access-Control-Allow-Origin</code><br>此外，我们也可以试试这个-解决 Script Error 的另类思路：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> originAddEventListener = <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span>;</span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span> = <span class="keyword">function</span> (<span class="params">type, listener, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedListener = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> listener.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> originAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, type, wrappedListener, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下：<br>改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> originAddEventListener = <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span>;</span><br><span class="line">   <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span> = <span class="keyword">function</span> (<span class="params">type, listener, options</span>) &#123;</span><br><span class="line">+    <span class="comment">// 捕获添加事件时的堆栈</span></span><br><span class="line">+    <span class="keyword">const</span> addStack = <span class="title function_">newError</span>(<span class="string">`Event (<span class="subst">$&#123;type&#125;</span>)`</span>).<span class="property">stack</span>;</span><br><span class="line">     <span class="keyword">const</span> wrappedListener = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> listener.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">+        <span class="comment">// 异常发生时，扩展堆栈</span></span><br><span class="line">+        err.<span class="property">stack</span> += <span class="string">&#x27;\n&#x27;</span> + addStack;</span><br><span class="line">         <span class="keyword">throw</span> err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> originAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure><h2 id="十一、崩溃和卡顿"><a href="#十一、崩溃和卡顿" class="headerlink" title="十一、崩溃和卡顿"></a>十一、崩溃和卡顿</h2><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？<br>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。<br>利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;good_exit&#x27;</span>, <span class="string">&#x27;pending&#x27;</span>);</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;time_before_crash&#x27;</span>, <span class="title function_">newDate</span>().<span class="title function_">toString</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;good_exit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;good_exit&#x27;</span>) &amp;&amp;</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;good_exit&#x27;</span>) !== <span class="string">&#x27;true&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        insert crash logging code here</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Hey, welcome back from your crash, looks like you crashed on: &#x27;</span> + <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;time_before_crash&#x27;</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：<br>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</p><h2 id="十二、错误上报"><a href="#十二、错误上报" class="headerlink" title="十二、错误上报"></a>十二、错误上报</h2><p>1.通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。<br>2.动态创建 img 标签的形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">report</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> reportUrl = ‘<span class="attr">http</span>:<span class="comment">//jartto.wang/report&#x27;;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = $&#123;reportUrl&#125;?logs=$&#123;error&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reporter</span>.<span class="property">send</span> = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line"><span class="comment">// 只采集 30%</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line"><span class="title function_">send</span>(data) <span class="comment">// 上报错误信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p><h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？<br>可疑区域增加 Try-Catch<br>全局监控 JS 异常 window.onerror<br>全局监控静态资源异常 window.addEventListener<br>捕获没有 Catch 的 Promise 异常：unhandledrejection<br>VUE errorHandler 和 React componentDidCatch<br>监控网页崩溃：window 对象的 load 和 beforeunload<br>跨域 crossOrigin 解决<br>其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><h2 id="十四、参考"><a href="#十四、参考" class="headerlink" title="十四、参考"></a>十四、参考</h2><p>Logging Information on Browser Crashes <a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/">http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/</a><br>前端代码异常监控实战 <a href="https://github.com/happylindz/blog/issues/5">https://github.com/happylindz/blog/issues/5</a><br>Error Boundaries <a href="https://blog.csdn.net/a986597353/article/details/78469979">https://blog.csdn.net/a986597353/article/details/78469979</a><br>前端监控知识点 <a href="https://github.com/RicardoCao-Biker/Front-End-Monitoring/blob/master/BasicKnowledge.md">https://github.com/RicardoCao-Biker/Front-End-Monitoring/blob/master/BasicKnowledge.md</a><br>Capture and report JavaScript errors with window.onerror <a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror">https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做好前端异常，才能安心的放假啊&lt;/p&gt;
&lt;h2 id=&quot;一、为什么要处理异常？&quot;&gt;&lt;a href=&quot;#一、为什么要处理异常？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要处理异常？&quot;&gt;&lt;/a&gt;一、为什么要处理异常？&lt;/h2&gt;&lt;p&gt;异常是不可控的，会影响</summary>
      
    
    
    
    <category term="前端工程化" scheme="https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="异常" scheme="https://justsso1.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>块级作用：var缺陷以及为什么要引入let和const</title>
    <link href="https://justsso1.github.io/2020/05/11/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9Avar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5let%E5%92%8Cconst/"/>
    <id>https://justsso1.github.io/2020/05/11/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9Avar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5let%E5%92%8Cconst/</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。<br>Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。&lt;br&gt;Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>爬虫所用到的知识</title>
    <link href="https://justsso1.github.io/2020/05/11/%E7%88%AC%E8%99%AB%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://justsso1.github.io/2020/05/11/%E7%88%AC%E8%99%AB%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2024-10-16T04:06:39.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node爬虫"><a href="#node爬虫" class="headerlink" title="node爬虫"></a>node爬虫</h1><p>爬虫要遵守Robots协议，也就是爬虫协议，爬虫程序在爬取网站数据之前，会先看看是否存在robots.txt文件，假如有，会在这个文件允许的<br>范围内进行爬取。像百度、谷歌都是遵循这一协议的。</p><p>根据我的经验，爬虫会有一下几种类型：</p><h2 id="爬网页"><a href="#爬网页" class="headerlink" title="爬网页"></a>爬网页</h2><p>用到的模块request网络请求网页，cheerio类似于jQuery的语法解析网页。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getWordFromIciBa</span>(<span class="params">english</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        request.<span class="title function_">get</span>(<span class="string">`https://www.iciba.com/<span class="subst">$&#123;english&#125;</span>`</span>, <span class="function">(<span class="params">err, response, body</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!err &amp;&amp; response.<span class="property">statusCode</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> $ = cheerio.<span class="title function_">load</span>(body.<span class="title function_">toString</span>())</span><br><span class="line">                <span class="keyword">let</span> yinbiao = $(<span class="string">&#x27;div.base-speak&gt;span:nth-child(2)&#x27;</span>).<span class="title function_">text</span>().<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">slice</span>(<span class="number">1</span>) <span class="comment">//美式音标</span></span><br><span class="line">                <span class="keyword">let</span> chinese = $(<span class="string">&#x27;ul.switch_part li&#x27;</span>).<span class="title function_">text</span>().<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment">//中文释义</span></span><br><span class="line">                <span class="title function_">resolve</span>(&#123;</span><br><span class="line">                     <span class="attr">us_phonetic</span>: yinbiao,</span><br><span class="line">                     <span class="attr">chinese</span>: chinese</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h2><p>用到的模块superagent，需要登录时，在请求头中添加cookie。<br>例子：爬取qq空间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://user.qzone.qq.com/proxy/domain/taotao.qq.com/cgi-bin/emotion_cgi_msglist_v6&#x27;</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="string">&#x27;_preloadCallback&#x27;</span></span><br><span class="line"><span class="keyword">let</span> func2 = <span class="string">&#x27;_preloadCallback&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fix</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">await</span> superagent.<span class="title function_">get</span>(url).<span class="title function_">set</span>(<span class="string">&#x27;cookie&#x27;</span>, <span class="string">&#x27;528226249_todaycount=0; 528226249_totalcount=29294; pgv_pvi=5218883584; pgv_si=s8073185280; qz_screen=1440x900; pgv_pvid=7967706718; pgv_info=ssid=s5682998744; QZ_FE_WEBP_SUPPORT=1; cpu_performance_v8=1; RK=oPRBCnNXSR; ptcz=fb06e745fbe330fe99a3447722d205f58030819c78f46a2e842af1b1d423faed; __Q_w_s_hat_seed=1; __Q_w_s__QZN_TodoMsgCnt=1; Loading=Yes; ptui_loginuin=528226249@qq.com; uin=o0528226249; skey=@TaX0jGEVu; p_uin=o0528226249; pt4_token=1o3CiF3KorxeXMslISpIWHSkWu6wYMVGXfrSCs6aJHM_; p_skey=a1MbdGhwOcH7Ax2IE1Ixy-N4kuO6G-khvzM1nx4u*Bo_&#x27;</span>)</span><br><span class="line">            .<span class="title function_">query</span>(&#123;</span><br><span class="line">                <span class="attr">uin</span>: <span class="number">528226249</span>,</span><br><span class="line">                <span class="attr">ftype</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">sort</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">pos</span>: pos,</span><br><span class="line">                <span class="attr">num</span>: num,</span><br><span class="line">                <span class="attr">replynum</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">g_tk</span>: <span class="number">846558423</span>,</span><br><span class="line">                <span class="attr">callback</span>: <span class="string">&#x27;_preloadCallback&#x27;</span>,</span><br><span class="line">                <span class="attr">code_version</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">format</span>: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">                <span class="attr">need_private_comment</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">qzonetoken</span>: <span class="string">&#x27;656e856329ef0609bdae4fceadd676c8312e4371446fdd95f3f3e8cbe482db5a6c0941fadacf72&#x27;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">let</span> text = res.<span class="property">res</span>.<span class="property">text</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span><br><span class="line">        text = text.<span class="title function_">slice</span>(<span class="number">17</span>)</span><br><span class="line">        text = text.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text)</span><br><span class="line">        <span class="keyword">let</span> msglist = obj.<span class="property">msglist</span></span><br><span class="line">        <span class="comment">// console.log(msglist)</span></span><br><span class="line"></span><br><span class="line">        msglist.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="comment">// item 为每一条说说</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="导出excel"><a href="#导出excel" class="headerlink" title="导出excel"></a>导出excel</h2><p>用到的模块node-xlsx，将数据写入xlsx文件中。可以参考文档： <a href="https://www.npmjs.com/package/node-xlsx">https://www.npmjs.com/package/node-xlsx</a></p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xlsx = <span class="built_in">require</span>(<span class="string">&#x27;node-xlsx&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> data = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="string">&#x27;sheetjs&#x27;</span>], [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2014-02-19T14:30Z&#x27;</span>), <span class="string">&#x27;0.3&#x27;</span>], [<span class="string">&#x27;baz&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;qux&#x27;</span>]];</span><br><span class="line"><span class="keyword">const</span> options = &#123;<span class="string">&#x27;!cols&#x27;</span>: [&#123;<span class="attr">wch</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">wch</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">wch</span>: <span class="number">60</span>&#125;]&#125;;</span><br><span class="line"> <span class="keyword">let</span> buffer = xlsx.<span class="title function_">build</span>([&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sheet1&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: data </span><br><span class="line">&#125;], options)</span><br><span class="line"></span><br><span class="line"> fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./my_xlsx.xlsx&#x27;</span>, buffer, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Write to my_xlsx.xlsx has finished&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse a file</span></span><br><span class="line"><span class="keyword">const</span> workSheetsFromFile = xlsx.<span class="title function_">parse</span>(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/no_word.xlsx`</span>);</span><br><span class="line"><span class="keyword">const</span> workSheetsFromBuffer = xlsx.<span class="title function_">parse</span>(fs.<span class="title function_">readFileSync</span>(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/no_word.xlsx`</span>));</span><br></pre></td></tr></table></figure><p>以上是我做Node爬虫遇到的几种类型，以后遇到了新的再补充到下面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;node爬虫&quot;&gt;&lt;a href=&quot;#node爬虫&quot; class=&quot;headerlink&quot; title=&quot;node爬虫&quot;&gt;&lt;/a&gt;node爬虫&lt;/h1&gt;&lt;p&gt;爬虫要遵守Robots协议，也就是爬虫协议，爬虫程序在爬取网站数据之前，会先看看是否存在robots.txt</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://justsso1.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>在JavaScript中使用ES6 Proxy做类型安全</title>
    <link href="https://justsso1.github.io/2020/04/28/%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8ES6%20Proxy%E5%81%9A%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/"/>
    <id>https://justsso1.github.io/2020/04/28/%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8ES6%20Proxy%E5%81%9A%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-04-27T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.548Z</updated>
    
    <content type="html"><![CDATA[<p>当前，大多数解决JavaScript中类型安全不足的解决方案都是基于静态类型检查和类型推断。TypeScript和Flow通过添加静态类型注释来拓展JavaScript，并且可以在编译时验证您的代码，并使用相同的抽象语法树来输出最终的JS代码。由于IDE可以依靠静态分析来提供自动完成和开发辅助，因此，这对于改善开发人员的体验非常有效。但是，关于类型安全，仍然存在一个主要缺陷：一旦使用JavaScript进行编译并在浏览器中运行，就不再保证所使用的变量具有预期的类型。</p><p>欺骗TypeScript非常容易。基本上，任何可以避免静态分析的操作都可能在不通知TypeScript的情况下潜在的更改变量的类型：</p><ul><li>使用方括号和一个代表属性的变量来检索属性</li><li>通过HTML事件属性，setTimeout或Function构造函数进行动态代码评估</li><li>全局变量与外部库或浏览器扩展冲突</li><li>一个内置原型，该原型已被库或polyfill意外修改、<br>TypeScript开发人员试图避免上面的这些模式，并认为这是最佳实践。但是，由于开发人员对静态类型系统的信任，这可能导致一些混乱的问题，而忘记了它实际上最终是在计算机上运行的动态脚本语言。</li></ul><p>JS中还有另一种类型安全的方法被遗忘了，可能值得更多关注：JavaScript本身中的强类型检查。</p><p>由于ECMAScript5和属性getters&#x2F;setters，我们可以控制对对象属性进行的分配。看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _name = <span class="string">&#x27;joe&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> _name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;传入类型不是字符串&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _name = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">user.<span class="property">name</span> = <span class="number">123</span> <span class="comment">//Error: 传入类型不是字符串</span></span><br></pre></td></tr></table></figure><p>只要你知道对象的所有属性名称并且始终在对象上定义它们，你就可以对对象属性进行简单的类型检查。setters还有其他的缺陷：他们无法捕获对象属性的所有操作，能很容易的通过Object.defineProperty()之类的方法推翻。</p><p>这使我们进入了ES6&#x2F;ES2015最被低估的功能之一：Proxy对象。Proxy包裹目标对象，并充当透明传递。开发人员可以通过设置陷阱来拦截对该对象执行的所有操作。这正是为我们的代码带来强大的类型检查所需要的。</p><p>让我们用<strong>Proxy</strong>重写之前的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;<span class="attr">_name</span>: <span class="string">&#x27;joe&#x27;</span>&#125;, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, p, value, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p === <span class="string">&#x27;_name&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;传入类型不是字符串&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">user.<span class="property">_name</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">user.<span class="property">_name</span> = <span class="number">456</span> <span class="comment">//Error: 传入类型不是字符串</span></span><br></pre></td></tr></table></figure><p>在这里，我们仅对set操作进行了拦截，但是同样的，我们还可以对defineProperty、deleteProperty以及任何其他可以使用我们的属性值发生变化的陷阱进行拦截。</p><p>与<code>getters/ setters</code>的主要区别在于，<code>Proxy</code>不需要知道属性名称即可捕获执行的操作。这样就可以对尚未定义的动态属性进行类型检查，还可以编写更多通用的使用程序函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checktype</span>(<span class="params">obj, definition</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">obj, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key <span class="keyword">in</span> definition &amp;&amp; <span class="keyword">typeof</span> value !== definition[key]) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>类型应该是: <span class="subst">$&#123;definition[key]&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="comment">//this 是实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">checktype</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="string">&#x27;number&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> joe = <span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line">joe.<span class="property">name</span> = <span class="string">&#x27;joe&#x27;</span>;</span><br><span class="line">joe.<span class="property">age</span> = <span class="string">&#x27;12&#x27;</span> <span class="comment">//Error: age类型应该是: number</span></span><br></pre></td></tr></table></figure><blockquote><p>(译者的话)注意：这里只能使用 let joe &#x3D; new User(); joe.name &#x3D; ‘joe的形式，而不能使用let joe &#x3D; new User({name: 11,age: ‘23’})，因为这样并不会触发 Proxy的set拦截，不会把属性写到this对象上，这样返回的对象是空的，没有属性 User {}</p></blockquote><p>Proxy可以处理任何类型的对象，并且可能对变量的几乎任何操作都可以拦截。这包括function用做apply被调用，可以想象基于这些构建一个完整的类型检查系统。而这正是去年使用ObjectModel所做的事情。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic Models</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PositiveInteger</span> = <span class="title class_">BasicModel</span>(<span class="title class_">Number</span>)</span><br><span class="line">   .<span class="title function_">assert</span>(<span class="title class_">Number</span>.<span class="property">isInteger</span>)</span><br><span class="line">   .<span class="title function_">assert</span>(<span class="function"><span class="params">n</span> =&gt;</span> n &gt;= <span class="number">0</span>, <span class="string">&quot;should be greater or equal to zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object Models</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ObjectModel</span>(&#123; </span><br><span class="line">   <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="title class_">PositiveInteger</span></span><br><span class="line">&#125;)&#123;</span><br><span class="line">   <span class="title function_">greet</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="string">`Hello I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function Models</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greetSomeone</span> = <span class="title class_">FunctionModel</span>(<span class="title class_">Person</span>).<span class="keyword">return</span>(<span class="title class_">String</span>)(<span class="keyword">function</span>(<span class="params">person</span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;person.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; and models for Arrays, Maps, Sets…<br>模型基本上是前面代码示例中类型检查功能的改进版本。 与TypeScript接口类似，它们的作用是确保变量符合模型定义。</p><p>这只是冰山一角。 因为所有这些都是在运行时完成的，所以我们可以想象出静态类型检查解决方案无法实现的所有用例：</p><ul><li>验证来自REST API的JSON形式，并自动将嵌套数据转换为适当的JS类</li><li>检查来自localStorage或IndexedDB的内容的有效性</li><li>通过类型检查内置浏览器API来执行功能检测</li><li>快速将类型定义添加到来自CDN的外部库</li></ul><p>现在我们的类型已从静态分析中解脱出来，我们甚至可以想象类型定义会根据应用程序的状态而变化：例如，一旦用户权限更改，便会立即向User实例添加新控件。</p><p>如果可以科学上网的话，可以观看视频 <a href="https://www.youtube.com/embed/zmojfyNH_EE">https://www.youtube.com/embed/zmojfyNH_EE</a></p><p>这些只是动态类型检查系统相对于静态检查的许多好处中的几个。 除此之外，它不需要学习新的语言或添加编译步骤。 它只是一个小的普通JavaScript库。</p><p>Proxy现在具有不错的浏览器支持，我认为是时候扩大我们对JavaScript类型安全性的了解了。 TypeScript和Flow提供了出色的开发人员体验，ObjectModel并不打算取代它们，但是仍有进行创新和尝试新方法的空间。</p><blockquote><p>（译者的话）虽然本文最后介绍了ObjectModel这个库，它是一个动态的类型检查js库，底层依赖的是ES6的Proxy，这说明，Proxy真的很强大，可以看看这个库的源码学习将Proxy用到实际工作中。<br>现在ObjectModel 4.0已经发布，采用ES Module，使用ES2018写的，所以源码也是学习JS的很好的例子。</p></blockquote><p>原文地址：<br><a href="https://medium.com/@SylvainPV/type-safety-in-javascript-using-es6-proxies-eee8fbbbd600">https://medium.com/@SylvainPV/type-safety-in-javascript-using-es6-proxies-eee8fbbbd600</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当前，大多数解决JavaScript中类型安全不足的解决方案都是基于静态类型检查和类型推断。TypeScript和Flow通过添加静态类型注释来拓展JavaScript，并且可以在编译时验证您的代码，并使用相同的抽象语法树来输出最终的JS代码。由于IDE可以依靠静态分析来提</summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
    <category term="proxy" scheme="https://justsso1.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>元编程是什么</title>
    <link href="https://justsso1.github.io/2020/04/27/%E5%85%83%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://justsso1.github.io/2020/04/27/%E5%85%83%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-04-26T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.543Z</updated>
    
    <content type="html"><![CDATA[<p>元编程的目标是利用语言自身的内省能力使代码的其余部分更具描述性、表达性和灵活性。</p><p>ES6在JavaScript现有的基础上为元编程新增了一些形式&#x2F;特性。如下：</p><p>函数名称<br>程序中有多种方式可以表达一个函数，函数的”名称”应该是说什么并非总是清晰无疑的。</p><p>有词法名称的函数<br>在ES6中， 默认情况下函数的词法名称（如果有的话）也会被设为它的name属性。如果函数设定了name值，那么这个值通常也就是开发者中栈踪迹使用的名称。<br>没有词法名称的函数<br>推导。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; .. &#125;); <span class="comment">// name: </span></span><br><span class="line">(<span class="keyword">function</span>*()&#123; .. &#125;); <span class="comment">// name: </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">foo</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; .. &#125;; <span class="comment">// name: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Awesome</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; .. &#125; <span class="comment">// name: Awesome </span></span><br><span class="line"> <span class="title function_">funny</span>(<span class="params"></span>) &#123; .. &#125; <span class="comment">// name: funny </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">class</span> <span class="title class_">Awesome</span> &#123; .. &#125;; <span class="comment">// name: Awesome </span></span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line"> <span class="title function_">foo</span>(<span class="params"></span>) &#123; .. &#125;, <span class="comment">// name: foo </span></span><br><span class="line"> *<span class="title function_">bar</span>(<span class="params"></span>) &#123; .. &#125;, <span class="comment">// name: bar </span></span><br><span class="line"> <span class="attr">baz</span>: <span class="function">() =&gt;</span> &#123; .. &#125;, <span class="comment">// name: baz </span></span><br><span class="line"> <span class="attr">bam</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; .. &#125;, <span class="comment">// name: bam </span></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">qux</span>() &#123; .. &#125;, <span class="comment">// name: get qux </span></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">fuz</span>() &#123; .. &#125;, <span class="comment">// name: set fuz </span></span><br><span class="line"> [<span class="string">&quot;b&quot;</span> + <span class="string">&quot;iz&quot;</span>]: </span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123; .. &#125;, <span class="comment">// name: biz </span></span><br><span class="line"> [<span class="title class_">Symbol</span>( <span class="string">&quot;buz&quot;</span> )]: </span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123; .. &#125; <span class="comment">// name: [buz] </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> x = o.<span class="property">foo</span>.<span class="title function_">bind</span>( o ); <span class="comment">// name: bound foo </span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; .. &#125;).<span class="title function_">bind</span>( o ); <span class="comment">// name: bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; .. &#125; <span class="comment">// name: default </span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Function</span>(); <span class="comment">// name: anonymous </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">GeneratorFunction</span> = </span><br><span class="line"><span class="keyword">function</span>*()&#123;&#125;.<span class="property">__proto__</span>.<span class="property">constructor</span>; </span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="title class_">GeneratorFunction</span>(); <span class="comment">// name: anonymous</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>name</code> 属性不可写，但可配置，也就是说如果需要的话，可使用 Object.defineProperty(..) 来手动修改。</p><h3 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h3><p><code>new.target</code> 元属性，关键字new用于属性访问的上下文。</p><h3 id="公开符号"><a href="#公开符号" class="headerlink" title="公开符号"></a>公开符号</h3><h4 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h4><p>调用<code>…</code>展开和<code>for…of</code>循环时，会自动使用Symbol.iterator。</p><p><code>Symbol.iterator</code>表示任意对象身上的一个专门位置（属性），语言机制自动在这个位置上寻找一个方法，这个方法<br>构造一个迭代器来消耗这个对象的值。很多对象定义有这个符号的默认值。</p><p>然而，也可以通过定义 Symbol.iterator 属性为任意对象值定义自己的迭代器逻辑，即使<br>这会覆盖默认的迭代器。</p><h4 id="Symbol-toStringTag与Symbol-hashInstance"><a href="#Symbol-toStringTag与Symbol-hashInstance" class="headerlink" title="Symbol.toStringTag与Symbol.hashInstance"></a>Symbol.toStringTag与Symbol.hashInstance</h4><p>最常见的一个元编程任务，就是在一个值上进行内省来找出它是什么种类，这通常是为了确定其上适合执行何种运算。对于对象来说，最常用的内省技术是 toString() 和instanceof。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line">a.<span class="title function_">toString</span>(); <span class="comment">// [object Object] </span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Foo</span>; <span class="comment">// true</span></span><br><span class="line">在 <span class="title class_">ES6</span> 中，可以控制这些操作的行为特性：</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">greeting</span>) &#123; </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">greeting</span> = greeting; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&quot;Foo&quot;</span>; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>( <span class="title class_">Foo</span>, <span class="title class_">Symbol</span>.<span class="property">hasInstance</span>, &#123; </span><br><span class="line"> <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">inst</span>) &#123; </span><br><span class="line"><span class="keyword">return</span> inst.<span class="property">greeting</span> == <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; ); </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Foo</span>( <span class="string">&quot;hello&quot;</span> ), </span><br><span class="line"> b = <span class="keyword">new</span> <span class="title class_">Foo</span>( <span class="string">&quot;world&quot;</span> ); </span><br><span class="line">b[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&quot;cool&quot;</span>; </span><br><span class="line">a.<span class="title function_">toString</span>(); <span class="comment">// [object Foo] </span></span><br><span class="line"><span class="title class_">String</span>( b ); <span class="comment">// [object cool] </span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Foo</span>; <span class="comment">// true </span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">Foo</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>原型（或实例本身）的Symbol.toStringTag符号指定了再[object ___]字符串化使用的字符串值。</p><p>原型（或实例本身）的Symbol.toStringTag符号指定了再[object ___]字符串化使用的字符串值。</p><h4 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h4><p>通过Symbol.species改写类的默认的构造器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cool</span> &#123; </span><br><span class="line"> <span class="comment">// 把@@species推迟到子类</span></span><br><span class="line"><span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125; </span><br><span class="line"> <span class="title function_">again</span>(<span class="params"></span>) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="property">constructor</span>[<span class="title class_">Symbol</span>.<span class="property">species</span>](); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fun</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Cool</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Awesome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Cool</span> &#123; </span><br><span class="line"> <span class="comment">// 强制指定@@species为父构造器</span></span><br><span class="line"><span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Cool</span>; &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Fun</span>(), </span><br><span class="line"> b = <span class="keyword">new</span> <span class="title class_">Awesome</span>(), </span><br><span class="line"> c = a.<span class="title function_">again</span>(), </span><br><span class="line"> d = b.<span class="title function_">again</span>(); </span><br><span class="line">c <span class="keyword">instanceof</span> <span class="title class_">Fun</span>; <span class="comment">// true </span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Awesome</span>; <span class="comment">// false </span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Cool</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>就像前面代码中 Cool 的定义那样，内置原生构造器上 Symbol.species 的默认行为是return this。在用户类上没有默认值，但是就像展示的那样，这个行为特性很容易模拟。</p><p>如果需要定义生成新实例的方法，使用 new this.constructor<a href="..">Symbol.species</a> 模式元编程，而不要硬编码 new this.constructor(..) 或 new XYZ(..)。然后继承类就能够自定义 Symbol.species 来控制由哪个构造器产生这些实例。</p><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>抽象类型转换运算tpPrimitive，它用在对象为了某个操作（比如比较&#x3D;&#x3D;或者相加+）必须被强制转换为一个原生类型值的时候。在ES6之前，没有办法控制这以行为。<br>而在ES6中，在任意对象值上作为属性的符号@@toPrimitivessysmbol都可以通过指定一个方法来定制这个ToPrimitive强制换转。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line">arr + <span class="number">10</span>; <span class="comment">// 1,2,3,4,510 </span></span><br><span class="line">arr[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] = <span class="keyword">function</span>(<span class="params">hint</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (hint == <span class="string">&quot;default&quot;</span> || hint == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line"> <span class="comment">// 求所有数字之和</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>( <span class="keyword">function</span>(<span class="params">acc,curr</span>)&#123; </span><br><span class="line"><span class="keyword">return</span> acc + curr; </span><br><span class="line"> &#125;, <span class="number">0</span> ); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">arr + <span class="number">10</span>; <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>Symbol.toPrimitive方法根据调用ToPrimitive的运算期望的类型，会提供一个提示（hint）指定“string”、“number”或“default”（这应该被解释为”number”）。在前面的代码中，加法 + 运算没有提示（传入 “default”）。而乘法 * 运算提示为 “number”，String(arr)提示为 “string”。</p><p>如果一个对象与另一个非对象值比较，&#x3D;&#x3D; 运算符调用这个对象上的ToPrimitive 方法时不指定提示——如果有 @@toPrimitive 方法的话，调用时提示为 “default”。但是，如果比较的两个值都是对象，&#x3D;&#x3D; 的行为和 &#x3D;&#x3D;&#x3D; 一样，也就是直接比较其引用。这种情况下完全不会调用 @@toPrimitive。</p><h4 id="正则表达式符号"><a href="#正则表达式符号" class="headerlink" title="正则表达式符号"></a>正则表达式符号</h4><p>对于正则表达式对象，有4个公开符号可以被覆盖，他们控制着这些正则表达式在4个对应的同名String.prototypt函数中如何被使用。</p><ul><li>@@match ： 正则表达式的Symbol.match值是一个用于利用给定的正则表达式匹配一个字符串值的部分或全部内容的方法。</li><li>@@replace:正则表达式的Symbol.replace值是一个方法，String.prototypt.replace(..)用它来替换一个字符串内匹配模式的一个或多个字符串序列。</li><li>@@search：正则表达式的Symbol.search值试试一个方法，String.prototype.search(..)用它来在另一个字符串中搜索一个匹配给定正则表达式的子串。</li><li>@@split：正则表达式的Symbol.split值时一个方法，String.prototype.split(..)用它把字符串在匹配给定正则表达式的分隔符处分隔为子串。</li></ul><p>如果你不够艺高人胆大的话，就不要覆盖内置正则表达式算法了！ JavaScript 的正则表达式引擎经过高度优化，所以你自己的用户代码很可能会慢上许多。这类元编程简洁强大，但是只应该在确实需要或能带来收益的时候才使用。</p><h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><p>符号 @@isConcatSpreadable 可以被定义为任意对象（比如数组或其他可迭代对象）的布尔型属性（SymbolisConcatSpreadable），用来指示如果把它传给一个数组的 concat(..) 是否应该将其展开。<br>考虑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], </span><br><span class="line"> b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]; </span><br><span class="line">b[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>; </span><br><span class="line">[].<span class="title function_">concat</span>( a, b ); <span class="comment">// [1,2,3,[4,5,6]]</span></span><br></pre></td></tr></table></figure><h4 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h4><p>符号 @@unscopables 可以被定义为任意对象的对象属性（Symbol.unscopables），用来指示使用 with 语句时哪些属性可以或不可以暴露为词法变量。<br>考虑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span> &#125;, </span><br><span class="line"> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>; </span><br><span class="line">o[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>] = &#123; </span><br><span class="line"> <span class="attr">a</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">b</span>: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">c</span>: <span class="literal">false</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="title function_">with</span> (o) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( a, b, c ); <span class="comment">// 1 20 3 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@@unscopables 对象中的 true 表示这个属性应该是 unscopable 的，因此会从词法作用域变量中被过滤出去。false 表示可以将其包含到词法作用域变量中。strict 模式下不允许 with 语句，因此应当被认为是语言的过时特性。不要使用它。因为应该避免使用 with，所以符号 @@unscopables 也没有太大意义。</p><h3 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h3><p>ES6中新增的最明显的元编程特性之一是Proxy。<br>代理是一种由你创建的特殊的对象，它“封装”另一个普通对象——或者说挡在这个普通对象的前面。你可以在代理对象上注册特殊的处理函数（也就是 trap），代理上执行各种操作的时候会调用这个程序。这些处理函数除了把操作转发给原始目标 &#x2F; 被封装对象之外，还有机会执行额外的逻辑。</p><p>每个代理处理函数在对应的元编程任务执行的时候进行拦截，而每个 Reflect 工具在一个对象上执行相应的元编程任务。每个代理处理函数都有一个自动调用相应的 Reflect 工具的默认定义。几乎可以确定 Proxy 和 Reflect 总是这么协同工<br>作的。</p><p>get(..)<br>通过 [[Get]]，在代理上访问一个属性（Reflect.get(..)、. 属性运算符或 [ .. ] 属性运算符）</p><p>set(..)<br>通过 [[Set]]，在代理上设置一个属性值（Reflect.set(..)、赋值运算符 &#x3D; 或目标为对象属性的解构赋值）</p><p>deleteProperty(..)<br>通 过 [[Delete]]， 从 代 理 对 象 上 删 除 一 个 属 性（Reflect.deleteProperty(..) 或（delete）</p><p>apply(..)（如果目标为函数）<br>通 过 [[Call]]，将代理作为普通函数 &#x2F; 方 法 调 用（Reflect.apply(..)、call(..)、apply(..) 或 (..) 调用运算符）</p><p>construct(..)（如果目标为构造函数）<br>通过 [[Construct]]，将代理作为构造函数调用（Reflect.construct(..) 或 new）</p><p>getOwnPropertyDescriptor(..)<br>通过 [[GetOwnProperty]]，从代理中提取一个属性描述符（Object.getOwnPropertyDescriptor(..)或 Reflect.getOwnPropertyDescriptor(..)）</p><p>defineProperty(..)<br>通过 [[DefineOwnProperty]]，在代理上设置一个属性描述符（Object.defineProperty(..)或 Reflect.defineProperty(..)）</p><p>getPrototypeOf(..)<br>通 过 [[GetPrototypeOf]]，得到代理的 [[Prototype]]（Object.getPrototypeOf(..)、Reflect.getPrototypeOf(..)、proto、Object#isPrototypeOf(..) 或 instanceof）</p><p>setPrototypeOf(..)<br>通 过 [[SetPrototypeOf]]，设置代理的 [[Prototype]]（Object.setPrototypeOf(..)、<br>Reflect.setPrototypeOf(..) 或 proto）</p><p>preventExtensions(..)<br>通过 [[PreventExtensions]]，使得代理变成不可扩展的（Object.prevent Extensions(..)或 Reflect.preventExtensions(..)）</p><p>isExtensible(..)<br>通过 [[IsExtensible]]，检测代理是否可扩展（Object.isExtensible(..) 或 Reflect.isExtensible(..)）</p><p>ownKeys(..)<br>通过 [[OwnPropertyKeys]]，提取代理自己的属性和 &#x2F; 或符号属性（Object.keys(..)、Object.getOwnPropertyNames(..)、Object.getOwnSymbolProperties(..)、Reflect.ownKeys(..) 或 JSON.stringify(..)）enumerate(..)通过 [[Enumerate]]，取得代理拥有的和“继承来的”可枚举属性的迭代器（Reflect.enumerate(..) 或 for..in）</p><p>has(..)<br>通过 [[HasProperty]]，检查代理是否拥有或者“继承了”某个属性（Reflect.has(..)、Object#hasOwnProperty(..) 或 “prop” in obj）</p><p>但是还是有些操作是无法代理的，typeof String() +</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span> &#125;, </span><br><span class="line"> handlers = &#123; .. &#125;, </span><br><span class="line"> pobj = <span class="keyword">new</span> <span class="title class_">Proxy</span>( obj, handlers ); </span><br><span class="line"><span class="keyword">typeof</span> obj; </span><br><span class="line"><span class="title class_">String</span>( obj ); </span><br><span class="line"></span><br><span class="line">obj + <span class="string">&quot;&quot;</span>; </span><br><span class="line">obj == pobj; </span><br><span class="line">obj === pobj</span><br></pre></td></tr></table></figure><p>可取消代理<br>可取消代理用 Proxy.revocable(..) 创建，这是一个普通函数，而不像 Proxy(..) 一样是构<br>造器。除此之外，它接收同样的两个参数：target 和 handlers。和 new Proxy(..) 不一样，Proxy.revocable(..) 的返回值不是代理本身。而是一个有两个<br>属性——proxy 和 revode 的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, </span><br><span class="line"> handlers = &#123; </span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target,key,context</span>) &#123; </span><br><span class="line"> <span class="comment">// 注意：target === obj, </span></span><br><span class="line"> <span class="comment">// context === pobj </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;accessing: &quot;</span>, key ); </span><br><span class="line"><span class="keyword">return</span> target[key]; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;, </span><br><span class="line"> &#123; <span class="attr">proxy</span>: pobj, <span class="attr">revoke</span>: prevoke &#125; = </span><br><span class="line"> <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>( obj, handlers ); </span><br><span class="line">pobj.<span class="property">a</span>; </span><br><span class="line"><span class="comment">// accessing: a </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 然后：</span></span><br><span class="line"><span class="title function_">prevoke</span>(); </span><br><span class="line">pobj.<span class="property">a</span>; </span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;元编程的目标是利用语言自身的内省能力使代码的其余部分更具描述性、表达性和灵活性。&lt;/p&gt;
&lt;p&gt;ES6在JavaScript现有的基础上为元编程新增了一些形式&amp;#x2F;特性。如下：&lt;/p&gt;
&lt;p&gt;函数名称&lt;br&gt;程序中有多种方式可以表达一个函数，函数的”名称”应该是说什么</summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
    <category term="proxy" scheme="https://justsso1.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>Proxy Reflect真的很有用</title>
    <link href="https://justsso1.github.io/2020/04/26/Proxy%E3%80%81Reflect%E7%9C%9F%E7%9A%84%E5%BE%88%E6%9C%89%E7%94%A8/"/>
    <id>https://justsso1.github.io/2020/04/26/Proxy%E3%80%81Reflect%E7%9C%9F%E7%9A%84%E5%BE%88%E6%9C%89%E7%94%A8/</id>
    <published>2020-04-25T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="Proxy是什么"><a href="#Proxy是什么" class="headerlink" title="Proxy是什么"></a>Proxy是什么</h3><p>这里我想简单来说，<code>Proxy</code>是对象的代理器，很好理解，我们有一个很重要的对象，我们不希望别人随便获取修改该对象，我们要保护该对象，用另外一个对象代理它，对真正要操作的对象是一种数据保护和过滤。</p><p><code>Proxy</code>并不是简单的通过我们常见的代码形式如if else对对象进行保护，它是在代码编程层面对对象进行保护，属于“元编程”。比如，在读取或设置对象的属性时，我们可以利用get() set()进行代理，执行函数时（函数本来就是对象）可以使用apply(),函数当作构造器时，可以使用constructor进行拦截。</p><h3 id="Proxy的拦截操作有哪些"><a href="#Proxy的拦截操作有哪些" class="headerlink" title="Proxy的拦截操作有哪些"></a>Proxy的拦截操作有哪些</h3><p>虽然是代理器，但是也不能任由程序员“自由发挥”，所以<code>ES6</code>中对<code>Proxy</code>做了一些限制，<code>Proxy</code>支持的拦截操作有下面这些：</p><ul><li>get(target, propKey, receiver): 拦截对象属性的读取</li><li>set(target, propKey, value, receiver): 拦截对象属性的设置</li><li>has(target, propKey): 拦截<code>propKey in proxy</code>操作，返回一个布尔值</li><li>deleteProperty(target, propKey): 拦截<code>delete proxy[propKey]</code>的操作，返回布尔值</li><li>ownKeys(target): 拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li><li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li><li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li><li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li><li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li><li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li><li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;prototype&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">fproxy.<span class="property">foo</span> === <span class="string">&quot;Hello, foo&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Proxy的应用"><a href="#Proxy的应用" class="headerlink" title="Proxy的应用"></a>Proxy的应用</h3><p>Proxy提供的拦截器很多种，可以根据具体的需求，组合这些拦截器达到自己的目的</p><ul><li><h4 id="防止对象的内部属性-私有属性-被外部读写，达到类型安全"><a href="#防止对象的内部属性-私有属性-被外部读写，达到类型安全" class="headerlink" title="防止对象的内部属性(私有属性)被外部读写，达到类型安全"></a>防止对象的内部属性(私有属性)被外部读写，达到类型安全</h4></li></ul><p>JS对象中的私有属性没有规定，我们都是约定使用前缀是’<em>‘代表私有属性，但还是并不“私有”。可以使用Proxy做到私有属性，在get&#x2F;set属性时，判断首字符是否是’</em>‘,如果是，则剖出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, p, receiver</span>) &#123;</span><br><span class="line">        <span class="title function_">inver</span>(p, <span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> target[p]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, p, value, receiver</span>) &#123;</span><br><span class="line">        <span class="title function_">inver</span>(p, <span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">        target[p] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inver</span>(<span class="params">key, action</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> target = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handle)</span><br><span class="line">    proxy.<span class="property">_prop</span></span><br><span class="line">    proxy.<span class="property">_prop</span> = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e) <span class="comment">// Error: Invalid attempt to get private &quot;_prop&quot; property</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h4 id="使用has方法隐藏某些属性，不被in运算符发现"><a href="#使用has方法隐藏某些属性，不被in运算符发现" class="headerlink" title="使用has方法隐藏某些属性，不被in运算符发现"></a>使用<code>has</code>方法隐藏某些属性，不被<code>in</code>运算符发现</h4></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="title function_">has</span> (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">&#x27;_prop&#x27;</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="中断处理-Proxy-revocable"><a href="#中断处理-Proxy-revocable" class="headerlink" title="中断处理 Proxy.revocable()"></a>中断处理 <code>Proxy.revocable()</code></h4></li></ul><p><code>Proxy.revocable</code>方法返回一个可取消的 Proxy 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><ul><li><h4 id="抽离校验模块，类型检查"><a href="#抽离校验模块，类型检查" class="headerlink" title="抽离校验模块，类型检查"></a>抽离校验模块，类型检查</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let numericDataStore = &#123;  </span><br><span class="line">    count: 0,</span><br><span class="line">    amount: 1234,</span><br><span class="line">    total: 14</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">numericDataStore = new Proxy(numericDataStore, &#123;  </span><br><span class="line">    set(target, key, value, proxy) &#123;</span><br><span class="line">        if (typeof value !== &#x27;number&#x27;) &#123;</span><br><span class="line">            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.set(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 抛出错误，因为 &quot;foo&quot; 不是数值</span><br><span class="line">numericDataStore.count = &quot;foo&quot;;</span><br><span class="line"></span><br><span class="line">// 赋值成功</span><br><span class="line">numericDataStore.count = 333;</span><br></pre></td></tr></table></figure><p>可以查看我的另一篇翻译文章：<a href="https://juejin.im/post/6844904143262318605">在JavaScript中使用ES6 Proxy做类型安全</a><br>Proxy可以做到动态的类型检查</p><ul><li><h4 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h4></li></ul><p>对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;  </span><br><span class="line">    <span class="attr">_apiKey</span>: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    <span class="attr">getUsers</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    <span class="attr">getUser</span>: <span class="keyword">function</span>(<span class="params">userId</span>) &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    <span class="attr">setUser</span>: <span class="keyword">function</span>(<span class="params">userId, config</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logMethodAsync</span>(<span class="params">timestamp, method</span>) &#123;  </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;timestamp&#125;</span> - Logging <span class="subst">$&#123;method&#125;</span> request asynchronously.`</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api = <span class="keyword">new</span> <span class="title class_">Proxy</span>(api, &#123;  </span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, proxy</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = target[key];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...<span class="variable language_">arguments</span></span>) &#123;</span><br><span class="line">            <span class="title function_">logMethodAsync</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), key);</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(value, target, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.<span class="title function_">getUsers</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h4 id="预警和拦截"><a href="#预警和拦截" class="headerlink" title="预警和拦截"></a>预警和拦截</h4></li></ul><p>假设你不想让其他开发者删除 noDelete 属性，还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataStore = &#123;  </span><br><span class="line">    <span class="attr">noDelete</span>: <span class="number">1235</span>,</span><br><span class="line">    <span class="attr">oldMethod</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">/*...*/</span> &#125;,</span><br><span class="line">    <span class="attr">doNotChange</span>: <span class="string">&quot;tried and true&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NODELETE</span> = [<span class="string">&#x27;noDelete&#x27;</span>];  </span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NOCHANGE</span> = [<span class="string">&#x27;doNotChange&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEPRECATED</span> = [<span class="string">&#x27;oldMethod&#x27;</span>];  </span><br><span class="line"></span><br><span class="line">dataStore = <span class="keyword">new</span> <span class="title class_">Proxy</span>(dataStore, &#123;  </span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, proxy</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">NOCHANGE</span>.<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> is immutable.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">NODELETE</span>.<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> cannot be deleted.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, proxy</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">DEPRECATED</span>.<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`Warning! <span class="subst">$&#123;key&#125;</span> is deprecated.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> val = target[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span> ?</span><br><span class="line">            <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">                <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target[key], target, args);</span><br><span class="line">            &#125; :</span><br><span class="line">            val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// these will throw errors or log warnings, respectively</span></span><br><span class="line">dataStore.<span class="property">doNotChange</span> = <span class="string">&quot;foo&quot;</span>;  </span><br><span class="line"><span class="keyword">delete</span> dataStore.<span class="property">noDelete</span>;  </span><br><span class="line">dataStore.<span class="title function_">oldMethod</span>();</span><br></pre></td></tr></table></figure><ul><li><h4 id="过略操作"><a href="#过略操作" class="headerlink" title="过略操作"></a>过略操作</h4></li></ul><p>某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;  </span><br><span class="line">    <span class="attr">getGiantFile</span>: <span class="keyword">function</span>(<span class="params">fileId</span>) &#123;<span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;  </span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, proxy</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> id = args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">let</span> isEnroute = <span class="title function_">checkEnroute</span>(id);</span><br><span class="line">            <span class="keyword">let</span> isDownloading = <span class="title function_">checkStatus</span>(id);      </span><br><span class="line">            <span class="keyword">let</span> cached = <span class="title function_">getCached</span>(id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isEnroute || isDownloading) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上我们可以看出，<code>Proxy</code>对于对象的代理作用很大，可以只对外展示我们允许展示的内容，比如某些属性、某些方法了。<br><code>Proxy</code>s属于元编程了，在框架编写中会用，当框架复杂度很高，封装的对象中肯定有一些内容是作为私有的，不能对外暴露，所以使用<code>Proxy</code>可以保证封装的对象的安全性和独立性。</p><p>即便不在框架中，在我们平时的开发任务中也可以用。比如封装数据库ORM，代理网络请求等等。</p><h3 id="思考：Proxy和TypeScript的关联和区别"><a href="#思考：Proxy和TypeScript的关联和区别" class="headerlink" title="思考：Proxy和TypeScript的关联和区别"></a>思考：Proxy和TypeScript的关联和区别</h3><p>像是set()拦截，我们可以拦截值的类型是否符合我们的要求，比如必须是数值，才会set()操作成功。<code>Proxy</code>和<code>TypeScript</code>同样都可以做到。<br><strong>那他们的区别是什么呢？</strong><br><code>Proxy</code>是类似“元编程”，而<code>TypeScript</code>是JavaScript类型的超集，它可以编译成JS。他们解决问题的层面不一样，<br><code>TypeScript</code>是静态类型检查，在代码编译阶段就可以检测出来，IDE可以为我们报错；而<code>Proxy</code>可以提供动态类型检查，在运行时也能做到类型检查。</p><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>Reflect</code> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>与大多数全局对象不同，<code>Reflect</code>不是一个构造函数。你不能将其与一个new运算符一起使用，或者将<code>Reflect</code>对象作为一个函数来调用。<code>Reflect</code>的所有属性和方法都是静态的（就像Math对象）。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>Reflect</code>是内置对象，在浏览器控制台中输入Reflect查看：<br><img src="https://user-gold-cdn.xitu.io/2020/4/28/171c003a5bee7a02?w=1226&h=612&f=png&s=135140" alt="Reflect"></p><p><code>Reflect</code>对象提供以下静态函数，它们具有与处理器对象（也就是Proxy handle）方法相同的名称。这些方法中的一些与 Object 上的对应方法相同。</p><ul><li>Reflect.apply()<br>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。</li><li>Reflect.construct()<br>对构造函数进行 new 操作，相当于执行 new target(…args)。</li><li>Reflect.defineProperty()<br>和 Object.defineProperty() 类似。</li><li>Reflect.deleteProperty()<br>作为函数的delete操作符，相当于执行 delete target[name]。</li><li>Reflect.enumerate()<br>该方法会返回一个包含有目标对象身上所有可枚举的自身字符串属性以及继承字符串属性的迭代器，for…in 操作遍历到的正是这些属性。</li><li>Reflect.get()<br>获取对象身上某个属性的值，类似于 target[name]。</li><li>Reflect.getOwnPropertyDescriptor()<br>类似于 Object.getOwnPropertyDescriptor()。<br>Reflect.getPrototypeOf()<br>类似于 Object.getPrototypeOf()。<br>Reflect.has()<br>判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。<br>Reflect.isExtensible()<br>类似于 Object.isExtensible().<br>Reflect.ownKeys()<br>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响).<br>Reflect.preventExtensions()<br>类似于 Object.preventExtensions()。返回一个Boolean。<br>Reflect.set()<br>将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。<br>Reflect.setPrototypeOf()<br>类似于 Object.setPrototypeOf()。</li></ul><p>参考链接：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><p><a href="https://medium.com/@SylvainPV/type-safety-in-javascript-using-es6-proxies-eee8fbbbd600">https://medium.com/@SylvainPV/type-safety-in-javascript-using-es6-proxies-eee8fbbbd600</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Proxy&quot;&gt;&lt;a href=&quot;#Proxy&quot; class=&quot;headerlink&quot; title=&quot;Proxy&quot;&gt;&lt;/a&gt;Proxy&lt;/h2&gt;&lt;h3 id=&quot;Proxy是什么&quot;&gt;&lt;a href=&quot;#Proxy是什么&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="proxy" scheme="https://justsso1.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Modules模块系统</title>
    <link href="https://justsso1.github.io/2020/04/26/es6-ES%20Modules%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://justsso1.github.io/2020/04/26/es6-ES%20Modules%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-04-25T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.541Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 Module将每个文件作为一个模块，每个模块拥有自身的作用域。ES6 Module 会自动采用严格模式，</p><p>导出 export<br>在ES6 Module中使用export命令来导出模块。export有两种方式：</p><p>命名导出<br>默认导出<br>一个模块可以有多个命名导出。它有两种不同的写法：</p><p>Javascript</p><p>&#x2F;&#x2F;写法一<br>export const name &#x3D; ‘jack’;<br>export const add &#x3D; function(a,b){return a+b}</p><p>&#x2F;&#x2F;写法二<br>const name &#x3D; ‘jack’;<br>const add &#x3D; (a,b) &#x3D;&gt; a+b<br>export {<br>    name,<br>    add<br>}<br>在使用命名导出时，可以通过as关键字对变量重命名。</p><p>Javascript<br>const name &#x3D; ‘jack’;<br>const add &#x3D; (a,b) &#x3D;&gt; a+b<br>export {<br>    name,<br>    add as getSum<br>}<br>模块的默认导出只能有一个。如：</p><p>Javascript<br>export default {<br>    name: ‘jack’,<br>    add: function(a,b) {<br>      return a+b<br>    }<br>}<br>我们可以将export default理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。</p><p>Javascript<br>&#x2F;&#x2F; 导出字符串<br>export default ‘This is lal.js’</p><p>&#x2F;&#x2F; 导出 class<br>export default class{..}</p><p>&#x2F;&#x2F;导出匿名函数<br>export default function(){..}<br>导入<br>导入对应着导出，也有两种方式。</p><p>导入带有命名导出的模块<br>Javascript<br>&#x2F;&#x2F;lal.js</p><p>const name &#x3D; ‘jack’;<br>const add &#x3D; (a,b) &#x3D;&gt; a+b<br>export {<br>    name,<br>    add<br>}<br>import {name, add} from ‘.&#x2F;lal.js’;<br>加载带有命名导出的模块时，import后面要跟一堆大括号来将导入的变量名包裹起来，并且这些变量名需要与导出的变量名完全一直。导入变量的效果相当于在当前作用域下声明了<br>这些变量（name 和add）,并且不可对其进行更改，也就是所有导入的变量都是只读的。</p><p>与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。</p><p>Javascript<br>import {name, add as Sum} from ‘.&#x2F;lal.js’<br>Sum(2,3)<br>整体导入 import * as A from ‘.&#x2F;a.js’</p><p>对于默认导出的导入<br>Javascript<br>&#x2F;&#x2F;lal.js<br>export default {<br>    name: ‘jack’,<br>    add: function(a,b) {<br>      return a+b<br>    }<br>}</p><p>import A from ‘.&#x2F;lal,js’<br>A.add(2,3)<br>对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（），它指代了lal.js中默认导出的。从原理上可以这样去处理：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ES6 Module将每个文件作为一个模块，每个模块拥有自身的作用域。ES6 Module 会自动采用严格模式，&lt;/p&gt;
&lt;p&gt;导出 export&lt;br&gt;在ES6 Module中使用export命令来导出模块。export有两种方式：&lt;/p&gt;
&lt;p&gt;命名导出&lt;br&gt;默认导出</summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
    <category term="模块化" scheme="https://justsso1.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法糖之箭头函数</title>
    <link href="https://justsso1.github.io/2020/04/19/ES6%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://justsso1.github.io/2020/04/19/ES6%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.532Z</updated>
    
    <content type="html"><![CDATA[<p>普通函数中this的绑定是很复杂多变的，ES6箭头函数&#x3D;&gt;以特定的方式改变this的行为特性，解决this相关编码的<br>一个特殊又常见的痛点。</p><p>箭头函数也不总是比普通函数好，当这个函数越长，&#x3D;&gt;带来的好处越小，这个函数越短，&#x3D;&gt;带来的好处越大。所以<br>只在确实需要简短的在线函数表达式的时候才用&#x3D;&gt;，而对于那些一般长度的函数则无需改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = &#123; </span><br><span class="line">     <span class="attr">makeRequest</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">     <span class="keyword">var</span> self = <span class="variable language_">this</span>; </span><br><span class="line">     btn.<span class="title function_">addEventListener</span>( <span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">        <span class="comment">// .. </span></span><br><span class="line">            self.<span class="title function_">makeRequest</span>(); </span><br><span class="line">        &#125;, <span class="literal">false</span> ); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用var self &#x3D; this这一Hack，然后使用self.makeRequest，因为我们传入addEVentListener的回调函数内部，this绑定和<br>makeRequest()本身的this绑定不一样。普通函数中的this绑定是动态的，我们需要通过self变量依赖词法作用域的可预测性。</p><p>箭头函数中的this绑定不是动态的，而是词法的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = &#123; </span><br><span class="line">     <span class="attr">makeRequest</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">         btn.<span class="title function_">addEventListener</span>( <span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">             <span class="comment">// .. </span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">makeRequest</span>(); </span><br><span class="line">         &#125;, <span class="literal">false</span> ); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们使用<code>=&gt;</code>箭头函数替代普通函数，箭头函数回调中的词法<code>this</code>和<code>makeRequest()</code>中是一样的。&#x3D;&gt;就是var self &#x3D; this的词法替代形式。</p><p>我们使用Babel转换一下：<br><img src="http://cdn.hixiaoya.com/blogs/imgs/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.png"></p><p>发现，在使用&#x3D;&gt;之前，也就是箭头函数的外层，先使用var self &#x3D; this保存了this</p><p>再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = &#123; </span><br><span class="line">     <span class="attr">makeRequest</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">         <span class="comment">// .. </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">helper</span>(); </span><br><span class="line">     &#125;, </span><br><span class="line">     <span class="attr">helper</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">         <span class="comment">// .. </span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;; </span><br><span class="line">controller.<span class="title function_">makeRequest</span>();</span><br></pre></td></tr></table></figure><p>尽管我们以 controller.makeRequest(..) 的形式调用，this.helper 引用还是会失败，因为<br>这里的 this 并不像平常一样指向 controller。那么它指向哪里呢？它是从包围的作用域中<br>词法继承而来的 this。在前面的代码中也就是全局作用域，其中 this 指向那个全局对象。</p><ul><li>箭头函数没有自己的this，只有词法this，继承自父层</li><li>箭头函数没有自己的arguments数组，只有词法arguments，继承自父层</li><li>箭头函数也没有super</li><li>箭头函数也没有new.target</li></ul><p>作用域和作用域链</p><p>一定要记住箭头函数的特点，在适当的地方使用。<br>如果是写对象的方法，要使用普通函数，因为普通函数中有this，一般情况下指向该对象，而箭头函数没有this,则访问不到对象的其他属性了。</p><p>如果返回值是一个简单的表达式，且这个函数内部没有this的引用，且没有自身引用（递归、绑定&#x2F;解绑定，且不会要求函数执行这些，可以使用箭头函数。</p><p>如果函数内部有很多语句，还是要用普通函数，保证可读性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;普通函数中this的绑定是很复杂多变的，ES6箭头函数&amp;#x3D;&amp;gt;以特定的方式改变this的行为特性，解决this相关编码的&lt;br&gt;一个特殊又常见的痛点。&lt;/p&gt;
&lt;p&gt;箭头函数也不总是比普通函数好，当这个函数越长，&amp;#x3D;&amp;gt;带来的好处越小，这个函数越短，</summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>我对模板字符串中标签模板的思考</title>
    <link href="https://justsso1.github.io/2020/04/17/%E6%88%91%E5%AF%B9%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://justsso1.github.io/2020/04/17/%E6%88%91%E5%AF%B9%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串的几个特性：</p><ul><li>可以嵌入变量，或者表达式</li><li>会保留多个空格、换行、缩进</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//嵌入变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Kyle&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( greeting ); <span class="comment">// &quot;Hello Kyle!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多行</span></span><br><span class="line"><span class="keyword">var</span> text = </span><br><span class="line"><span class="string">`Now is the time for all good men </span></span><br><span class="line"><span class="string">to come to the aid of their </span></span><br><span class="line"><span class="string">country!`</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( text ); </span><br><span class="line"><span class="comment">// Now is the time for all good men </span></span><br><span class="line"><span class="comment">// to come to the aid of their </span></span><br><span class="line"><span class="comment">// country!var text = </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入表达式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">upper</span>(<span class="params">s</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">toUpperCase</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> who = <span class="string">&quot;reader&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> text = </span><br><span class="line"><span class="string">`A very <span class="subst">$&#123;upper( <span class="string">&quot;warm&quot;</span> )&#125;</span> welcome </span></span><br><span class="line"><span class="string">to all of you <span class="subst">$&#123;upper( <span class="string">`<span class="subst">$&#123;who&#125;</span>s`</span> )&#125;</span>!`</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( text ); </span><br><span class="line"><span class="comment">// A very WARM welcome </span></span><br><span class="line"><span class="comment">// to all of you READERS!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><blockquote><p>模板字符串还可以跟在一个函数后面，该函数将被调用来处理这个模板字符串。这被称为”标签模板”功能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`123`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>如果模板字符串中含有变量，标签模板会进行特殊处理，它会根据嵌入的变量，把模板字符串拆开。<br>普通字符串组成数组做位第一个参数，插入的变量依次作为第二个、第三个…变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, value1, value2</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, ...values</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p><h2 id="为什么要有标签模板？"><a href="#为什么要有标签模板？" class="headerlink" title="为什么要有标签模板？"></a>为什么要有标签模板？</h2><p>我第一次看到标签模板的时候，不禁在想为什么要有标签模板，它有什么普通函数不能替代的地方呢？如果没有不可替代的地方，那为什么还要创造<br>它呢？<br>答案是：标签模板确实有它存在的意义，也有普通函数无法替代它的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">logArgs</span> = (<span class="params">...args</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(...args)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先用普通函数形式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">logArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment">// -&gt; a b</span></span><br></pre></td></tr></table></figure><p>再用一个简单的模板字符串试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logArgs<span class="string">``</span></span><br><span class="line"><span class="comment">// -&gt; [&quot;&quot;, raw: Array(1)]</span></span><br></pre></td></tr></table></figure><p>上面输出了一个空数组，然后传入一个有值的模板字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logArgs<span class="string">`I like pizza`</span></span><br><span class="line"><span class="comment">// -&gt; [&quot;I like pizza&quot;]</span></span><br></pre></td></tr></table></figure><p>现在，进一步网模板字符串中传入变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> favoriteFood = <span class="string">&#x27;pizza&#x27;</span></span><br><span class="line"><span class="comment">//当作普通函数调用，直接出入拼接的字符串</span></span><br><span class="line"><span class="title function_">logArgs</span>(<span class="string">`I like <span class="subst">$&#123;favoriteFood&#125;</span>.`</span>)</span><br><span class="line"><span class="comment">// -&gt; I like pizza.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用标签模板，会输出处理后的参数</span></span><br><span class="line"><span class="keyword">const</span> favoriteFood = <span class="string">&#x27;pizza&#x27;</span></span><br><span class="line"></span><br><span class="line">logArgs<span class="string">`I like <span class="subst">$&#123;favoriteFood&#125;</span>.`</span></span><br><span class="line"><span class="comment">// -&gt; [&quot;I like &quot;, &quot;.&quot;] &quot;pizza&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>变换过程是这样的：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa7ce629cc291?w=658&h=188&f=png&s=27166" alt="标签模板例子"></p><p>当我们传入多个变量时，每一个插入的变量都作为下一个参数了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> favoriteFood = <span class="string">&#x27;pizza&#x27;</span></span><br><span class="line"><span class="keyword">const</span> favoriteDrink = <span class="string">&#x27;obi&#x27;</span></span><br><span class="line"></span><br><span class="line">logArgs<span class="string">`I like <span class="subst">$&#123;favoriteFood&#125;</span> and <span class="subst">$&#123;favoriteDrink&#125;</span>.`</span></span><br><span class="line"><span class="comment">// -&gt; [&quot;I like &quot;, &quot; and &quot;, &quot;.&quot;] &quot;pizza&quot; &quot;obi&quot;</span></span><br></pre></td></tr></table></figure><p>这样看来，标签模版有什么大的作用呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="title function_">logArgs</span>(<span class="string">`Test <span class="subst">$&#123;() =&gt; <span class="variable language_">console</span>.log(<span class="string">&#x27;test&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// -&gt; Test () =&gt; console.log(&#x27;test&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="comment">// () =&gt; console.log(&#x27;test&#x27;)</span></span><br></pre></td></tr></table></figure><p>普通函数，遇到变量是一个函数是，会把函数变成字符串形式的，而没有别的处理，看看标签模板的特殊之处，<strong>模板字符串中嵌入变量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logArgs<span class="string">`Test <span class="subst">$&#123;() =&gt; <span class="variable language_">console</span>.log(<span class="string">&#x27;test&#x27;</span>)&#125;</span>`</span></span><br><span class="line"><span class="comment">// -&gt; [&quot;Test&quot;, &quot;&quot;] () =&gt; console.log(&#x27;test&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出，标签模板把模板字符串中的变量解析了出来，函数还是一个函数不会变成字符串。我们有能力拿到函数，那么我们也可以执行这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">execFuncArgs</span> = (<span class="params">...args</span>) =&gt; args.<span class="title function_">forEach</span>(<span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">arg</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的函数，我们会忽略不是函数的参数，是函数就执行它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">execFuncArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment">// -&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">execFuncArgs</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is a function&#x27;</span>) &#125;)</span><br><span class="line"><span class="comment">// -&gt; &quot;this is a function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">execFuncArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;another one&#x27;</span>) &#125;)</span><br><span class="line"><span class="comment">// -&gt; &quot;another one&quot;</span></span><br></pre></td></tr></table></figure><p>让我们把它当作普通函数来调用带有变量的模板字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">execFuncArgs</span>(<span class="string">`Hi, <span class="subst">$&#123;() =&gt; &#123; <span class="variable language_">console</span>.log(<span class="string">&#x27;Executed!&#x27;</span>) &#125;&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// -&gt; undefined</span></span><br></pre></td></tr></table></figure><p>为什么会是<code>undfined</code>呢？因为，普通函数调用的方式，模板字符串会全部变成字符串的形式，变量也变成了字符串的形式<br>实际上调用参数是这样的： <code>&quot;Hi, () =&gt; &#123; console.log(&#39;I got executed!&#39;) &#125;&quot;.</code></p><p>把上面的函数当作”标签模板”来调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execFuncArgs<span class="string">`Hi, <span class="subst">$&#123;() =&gt; &#123; <span class="variable language_">console</span>.log(<span class="string">&#x27;Executed!&#x27;</span>) &#125;&#125;</span>`</span></span><br><span class="line"><span class="comment">// -&gt; &quot;Executed!&quot;</span></span><br></pre></td></tr></table></figure><p>与之前相反，<code>execFuncArgs</code>的第二个参数实际上是一个函数，然后会执行这个函数。<br>由此可以解决我的疑问了：<br><strong>标签模板可以对传入的模板字符串中的变量，进行提取，并进一步处理，普通函数根本取不到这些变量，就甭提进一步处理了。</strong></p><h2 id="标签模板的实际应用"><a href="#标签模板的实际应用" class="headerlink" title="标签模板的实际应用"></a>标签模板的实际应用</h2><p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> message =</span><br><span class="line">  <span class="title class_">SaferHTML</span><span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SaferHTML</span>(<span class="params">templateData</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="title class_">String</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">            .<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">            .<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> sender = <span class="string">&#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="title class_">SaferHTML</span><span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;</span></span><br></pre></td></tr></table></figure><p>还有<code>common-tags</code>库中的<code>oneLine</code>标签函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;oneLine&#125; <span class="keyword">from</span> <span class="string">&#x27;common-tags&#x27;</span></span><br><span class="line"></span><br><span class="line">oneLine<span class="string">`</span></span><br><span class="line"><span class="string">  foo</span></span><br><span class="line"><span class="string">  bar</span></span><br><span class="line"><span class="string">  baz</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// &quot;foo bar baz&quot;</span></span><br></pre></td></tr></table></figure><p>总之，标签模板功能很强大，可能一开始并不会觉得厉害之处，平时工作中也不会用到，但是这些知识是有用的，在很多库中会用到它，我们<br>使用这些库的时候也在不自觉中使用了标签模板，可以慢慢开始了解它，并使用它。</p><p>参考文章：</p><p><a href="https://www.freecodecamp.org/news/es6-tagged-template-literals-48a70ef3ed4d/">ES6 Tagged Template Literals</a></p><p><a href="https://mxstbr.blog/2016/11/styled-components-magic-explained/">The magic behind 💅 styled-components</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模板字符串&quot;&gt;&lt;a href=&quot;#模板字符串&quot; class=&quot;headerlink&quot; title=&quot;模板字符串&quot;&gt;&lt;/a&gt;模板字符串&lt;/h2&gt;&lt;p&gt;模板字符串的几个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以嵌入变量，或者表达式&lt;/li&gt;
&lt;li&gt;会保留多个空格、换行、</summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解let和const原理</title>
    <link href="https://justsso1.github.io/2020/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3let%E5%92%8Cconst%E5%8E%9F%E7%90%86/"/>
    <id>https://justsso1.github.io/2020/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3let%E5%92%8Cconst%E5%8E%9F%E7%90%86/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2024-10-12T08:40:56.550Z</updated>
    
    <content type="html"><![CDATA[<p>let 和const命令是ES6新增的，让我们来看看它们是怎么回事吧～</p><p>在有 let 和const之前，我们使用 var 来声明变量，var声明变量会有变量提升的特性，</p><p>Javascript<br>console.log(a)<br>var a &#x3D; 1 &#x2F;&#x2F;undefined<br>用var声明a,a变量会被提升到在当前作用域的最前面声明，其实执行的代码是这样的：</p><p>Javascript<br>var a;<br>console.log(a)<br>a &#x3D; 1;<br>为了约束变量提升，出现了块级作用域，块级作用域搭配let和const就没有变量提升了。</p><p>Javascript<br>console.log(b)<br>let b &#x3D; 1 &#x2F;&#x2F;ReferenceError: b is not defined<br>用let就没有变量提升的问题，但是在声明变量之前就访问，会报错，访问b会报ReferenceError错误<br>那let为什么没有变量提升的问题呢？块级作用域又是什么呢？</p><p>块级作用域<br>let和const实际上为ES6引入了”块级作用域”的概念。<br>在ES5中只有全局作用域和函数作用域。ES6新增了块级作用域来约束变量的生命周期。<br>简单说就是两个大括号{}就形成了块级作用域，外层代码块不受内层代码块的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">//5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i&lt; <span class="number">10</span> ;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)  <span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>内层的n不会影响外层的n，所以打印n&#x3D;5<br>for循环中声明了变量i,在for循环之外访问i变量，会报错，这是因为在外层代码块中没有声明变量i</p><p>for循环中都会有块级作用域。我们来看一个经典的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[<span class="number">2</span>]() <span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>在for循环外可以访问到i，i的值为10，这是因为i在for循环中使用var声明了，会被变量提升，结果就是i挂载到全局对象中，<br>在浏览器中就是window对象，成为window的属性。每一层循环改变的都是全局的i, 传入到循环中的console.log(i)都是10，<br>最后外部访问的i值也变成了10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    brr[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">brr[<span class="number">2</span>]() <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>for循环中使用let声明变量i，这样每一层循环都重新声明了i，并绑定了当前循环的代码块，所以传入内存函数的额console.log(i)<br>也是当时的i的值，所以brr<a href="">2</a>执行时，变量i的值是2，在for循环外访问i会出错。</p><p>你可能会问，每一层的循环变量都是重新声明的，那么for循环怎么知道上一层循环的值，从而计算出本层的值？这是因为<br>Javascript引擎内部会记住上一层的循环的值，在上一层循环的基础上，计算得出初始化本层的变量的值。</p><p>细说for循环中的块级作用域<br>for循环中（）是一个块级作用域，而循环体内{}是一个单独的子作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面输出三次 abc ，说明，循环内部的i变量与循环变量i不在同一个作用域，有各自单独的作用域。</p><p>我们来看看let到底是怎么由var转过来的，我用Babel试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    brr[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">brr[<span class="number">2</span>]()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Babel转过之后，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> brr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _loop = <span class="keyword">function</span> <span class="title function_">_loop</span>(<span class="params">_i</span>) &#123;</span><br><span class="line">    brr[_i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(_i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; <span class="number">10</span>; _i++) &#123;</span><br><span class="line">    <span class="title function_">_loop</span>(_i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">brr[<span class="number">2</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure><p>babel把for循环内层都抽象到一个函数中了，然后，把循环变量传入这个函数参数，这样每一层的循环都会返回一个函数声明，<br>而循环变量都会锁定住。</p><p>暂时性死区<br>只要块级作用域中有let和const命令，那么所声明的变量就”绑定”这个区域，不再受外部的影响。<br>在块级作用域内，使用let或const声明变量之前，该变量都是不可取的，这就叫”暂时性死区”</p><p>暂时性死区解决的问题：<br>解决了在声明变量之前访问该变量，没有变量提升，主要为了减少运行时错误。</p><p>暂时性死区的本质：</p><p>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，不可访问，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><ul><li>const 也不会变量提升</li><li>const 也存在暂时性死区特性</li><li>const在声明变量时就要赋值，否则以后不能赋值了</li><li>const只声明不赋值会报错</li></ul><p>const 声明的变量如果是基本类型，那么不允许改变，如果是引用类型，那么只要不改变引用的地址就是可以的。</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>Javascript<br>const name &#x3D; ‘Friday’<br>name &#x3D; ‘Sunday’  &#x2F;&#x2F;直接报错</p><p>const people &#x3D; {<br>    name: ‘Jack’,<br>    age: 21<br>}<br>people.age &#x3D; 22<br>console.log(people) &#x2F;&#x2F;{ name: ‘Jack’, age: 22 }</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;let 和const命令是ES6新增的，让我们来看看它们是怎么回事吧～&lt;/p&gt;
&lt;p&gt;在有 let 和const之前，我们使用 var 来声明变量，var声明变量会有变量提升的特性，&lt;/p&gt;
&lt;p&gt;Javascript&lt;br&gt;console.log(a)&lt;br&gt;var a </summary>
      
    
    
    
    <category term="javascript" scheme="https://justsso1.github.io/categories/javascript/"/>
    
    
  </entry>
  
</feed>
