{"meta":{"title":"Justsso的博客","subtitle":"","description":"前端道路上的积累与思考","author":"justsso","url":"https://justsso1.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-10-14T10:13:21.913Z","updated":"2024-10-14T10:13:21.913Z","comments":false,"path":"/404.html","permalink":"https://justsso1.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-10-14T10:34:48.261Z","updated":"2024-10-14T10:34:48.261Z","comments":false,"path":"about/index.html","permalink":"https://justsso1.github.io/about/index.html","excerpt":"","text":"个人详细介绍 👋 Hi, I’m @justsso1👀 I’m interested in TypeScript、React、JavaScript、H5、CSS3🌱 I’m currently learning FrontEnd Engineer and Full Stack Engineer and AI💞️ I’m looking to find a good job📫 How to reach me &#53;&#x32;&#x38;&#x32;&#x32;&#x36;&#x32;&#52;&#x39;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;😄 Pronouns: work hard and play hard⚡ Fun fact: …"},{"title":"标签","date":"2024-10-14T10:14:56.819Z","updated":"2024-10-14T10:14:56.819Z","comments":false,"path":"tags/index.html","permalink":"https://justsso1.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-10-14T10:35:04.724Z","updated":"2024-10-14T10:35:04.724Z","comments":false,"path":"categories/index.html","permalink":"https://justsso1.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-02-27T14:44:57.217Z","updated":"2023-02-27T14:44:57.217Z","comments":true,"path":"imgs/axure/我的考试.html","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95.html","excerpt":"","text":"我的考试 PREVIEW_INFO = {}; if (location.href.toString().indexOf('file://localhost/') == 0) { location.href = location.href.toString().replace('file://localhost/', 'file:///'); } #outerContainer { width:1000px; height:1500px; } .vsplitbar { width: 3px; /*background: #B9B9B9;*/ border-right: 1px solid #8f949a; } .vsplitbar:hover, .vsplitbar.active { background: #8f949a; } #rightPanel { background-color: White; } /*#leftPanel { min-width: 120px; }*/ .splitterMask { position:absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; background-image: url(resources/images/transparent.gif); z-index: 20000; } &nbsp; PAGESNOTESCONSOLE NOTES我的考试No notes for this page.Notes added in Axure RP will appear here. (矩形)功能逻辑首页中，有&nbsp; 种情况。1.用户没有加入任何营，首页仅仅展示新营售卖；2.用户加入了1个或多个营， (矩形)功能逻辑点击“我的考试”，弹出设置考试面板。考试面板在页面正中间。"},{"title":"","date":"2023-02-27T14:44:57.217Z","updated":"2023-02-27T14:44:57.217Z","comments":true,"path":"imgs/axure/我的考试_files/axure_rp_page.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/axure_rp_page.css","excerpt":"","text":"/* so the window resize fires within a frame in IE7 */ html, body { height: 100%; } a { color: inherit; } p { margin: 0px; text-rendering: optimizeLegibility; font-feature-settings: \"kern\" 1; -webkit-font-feature-settings: \"kern\"; -moz-font-feature-settings: \"kern\"; -moz-font-feature-settings: \"kern=1\"; font-kerning: normal; } iframe { background: #FFFFFF; } /* to match IE with C, FF */ input { padding: 1px 0px 1px 0px; box-sizing: border-box; -moz-box-sizing: border-box; } textarea { margin: 0px; box-sizing: border-box; -moz-box-sizing: border-box; } div.intcases { font-family: arial; font-size: 12px; text-align:left; border:1px solid #AAA; background:#FFF none repeat scroll 0% 0%; z-index:9999; visibility:hidden; position:absolute; padding: 0px; border-radius: 3px; white-space: nowrap; } div.intcaselink { cursor: pointer; padding: 3px 8px 3px 8px; margin: 5px; background:#EEE none repeat scroll 0% 0%; border:1px solid #AAA; border-radius: 3px; } div.refpageimage { position: absolute; left: 0px; top: 0px; font-size: 0px; width: 16px; height: 16px; cursor: pointer; background-image: url(images/newwindow.gif); background-repeat: no-repeat; } div.annnoteimage { position: absolute; left: 0px; top: 0px; font-size: 0px; /*width: 16px; height: 12px;*/ cursor: help; /*background-image: url(images/note.gif);*/ /*background-repeat: no-repeat;*/ width: 13px; height: 12px; padding-top: 1px; text-align: center; background-color: #138CDD; -moz-box-shadow: 1px 1px 3px #aaa; -webkit-box-shadow: 1px 1px 3px #aaa; box-shadow: 1px 1px 3px #aaa; } div.annnoteline { display: inline-block; width: 9px; height: 1px; border-bottom: 1px solid white; margin-top: 1px; } div.annnotelabel { position: absolute; left: 0px; top: 0px; font-family: Helvetica,Arial; font-size: 10px; /*border: 1px solid rgb(166,221,242);*/ cursor: help; /*background:rgb(0,157,217) none repeat scroll 0% 0%;*/ padding: 1px 3px 1px 3px; white-space: nowrap; color: white; background-color: #138CDD; -moz-box-shadow: 1px 1px 3px #aaa; -webkit-box-shadow: 1px 1px 3px #aaa; box-shadow: 1px 1px 3px #aaa; } .annotation { font-size: 12px; padding-left: 2px; margin-bottom: 5px; } .annotationName { /*font-size: 13px; font-weight: bold; margin-bottom: 3px; white-space: nowrap;*/ font-family: 'Trebuchet MS'; font-size: 14px; font-weight: bold; margin-bottom: 5px; white-space: nowrap; } .annotationValue { font-family: Arial, Helvetica, Sans-Serif; font-size: 12px; color: #4a4a4a; line-height: 21px; margin-bottom: 20px; } .noteLink { text-decoration: inherit; color: inherit; } .noteLink:hover { background-color: white; } /* this is a fix for the issue where dialogs jump around and takes the text-align from the body */ .dialogFix { position:absolute; text-align:left; border: 1px solid #8f949a; } @keyframes pulsate { from { box-shadow: 0 0 10px #15d6ba; } to { box-shadow: 0 0 20px #15d6ba; } } @-webkit-keyframes pulsate { from { -webkit-box-shadow: 0 0 10px #15d6ba; box-shadow: 0 0 10px #15d6ba; } to { -webkit-box-shadow: 0 0 20px #15d6ba; box-shadow: 0 0 20px #15d6ba; } } @-moz-keyframes pulsate { from { -moz-box-shadow: 0 0 10px #15d6ba; box-shadow: 0 0 10px #15d6ba; } to { -moz-box-shadow: 0 0 20px #15d6ba; box-shadow: 0 0 20px #15d6ba; } } .legacyPulsateBorder { /*border: 5px solid #15d6ba; margin: -5px;*/ -moz-box-shadow: 0 0 10px 3px #15d6ba; box-shadow: 0 0 10px 3px #15d6ba; } .pulsateBorder { animation-name: pulsate; animation-timing-function: ease-in-out; animation-duration: 0.9s; animation-iteration-count: infinite; animation-direction: alternate; -webkit-animation-name: pulsate; -webkit-animation-timing-function: ease-in-out; -webkit-animation-duration: 0.9s; -webkit-animation-iteration-count: infinite; -webkit-animation-direction: alternate; -moz-animation-name: pulsate; -moz-animation-timing-function: ease-in-out; -moz-animation-duration: 0.9s; -moz-animation-iteration-count: infinite; -moz-animation-direction: alternate; } .ax_default_hidden, .ax_default_unplaced{ display: none; visibility: hidden; } .widgetNoteSelected { -moz-box-shadow: 0 0 10px 3px #138CDD; box-shadow: 0 0 10px 3px #138CDD; /*-moz-box-shadow: 0 0 20px #3915d6; box-shadow: 0 0 20px #3915d6;*/ /*border: 3px solid #3915d6;*/ /*margin: -3px;*/ } .singleImg { display: none; visibility: hidden; }"},{"title":"","date":"2023-02-27T14:44:57.218Z","updated":"2023-02-27T14:44:57.218Z","comments":true,"path":"imgs/axure/我的考试_files/default.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/default.css","excerpt":"","text":"body { font-family : Arial, Helvetica, Sans-Serif; background-color: #8f949a; overflow:hidden; } a { cursor: pointer; } input[type=\"radio\"], input[type=\"checkbox\"] { margin: 0px 9px 0px 0px; vertical-align: bottom; } input { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } #maximizePanelContainer { font-size: 4px; position:absolute; left: 0px; top: 0px; width: 55px; height: 20px; overflow: visible; z-index: 1000; } #maximizePanelOver { position: absolute; left: 0px; top: 0px; width: 55px; height: 20px; } .maximizePanel { position: absolute; left: 0px; top: 0px; width: 55px; height: 20px; background: #a2a2a2 url('../images/expand.png') no-repeat center center; background: url('../images/expand.svg') no-repeat center center, linear-gradient(rgba(200,200,200,.5),rgba(200,200,200,.5)); cursor: pointer; } #interfaceControlFrameMinimizeContainer { position:absolute; top: 0px; left: 0px; font-size: 2px; /*for IE*/ text-align: right; z-index: 100; height: 20px; width: 55px; background-color: #62666b; } #interfaceControlFrameMinimizeContainer a { display: inline-block; width: 55px; height: 20px; font-size: 2px; background: url('../images/close.png') no-repeat center center; background: url('../images/close.svg') no-repeat center center, linear-gradient(transparent,transparent); text-decoration: none; } .hashover #interfaceControlFrameMinimizeContainer a:hover { background: url('../images/close_hover.png') no-repeat center center; background: url('../images/close_hover.svg') no-repeat center center, linear-gradient(transparent,transparent); } #interfaceControlFrame { margin: 0px 0px 0px 55px; } #interfaceControlFrameCloseContainer { /*display: none;*/ position:absolute; bottom: 0px; left: 0px; font-size: 9px; font-family: 'Trebuchet MS'; font-weight: bold; letter-spacing: 1px; z-index: 100; width: 55px; background-color: #62666b; text-align: center; } #interfaceControlFrameCloseContainer a { display: inline-block; width: 55px; color: #ffffff; padding: 5px 0px; } #interfaceControlFrameHeader li a { display: block; width: 54px; height: 78px; text-align: center; padding-top: 50px; outline: none; margin-right: 1px; text-decoration: none; color: #ffffff; white-space: nowrap; background-color: transparent; background-repeat: no-repeat; background-position: 50% 17px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-left: 4px solid transparent; border-right: 4px solid transparent; } .hashover #interfaceControlFrameHeader li a:hover { background-color: transparent; background-repeat: no-repeat; background-position: 50% 17px; color: #c2c2c2; } #interfaceControlFrameHeader li a.selected, #interfaceControlFrameHeader li a.selected:hover { background-color: #f5f5f5; background-repeat: no-repeat; background-position: 50% 17px; color: #62666b; border-left: 5px solid #138CDD; } #interfaceControlFrameHeaderContainer { float: left; overflow: visible; width: 55px; margin-left: -55px; margin-top: 20px; } #interfaceControlFrameHeader { position: relative; list-style: none; font-size: 8px; z-index: 50; font-family: 'Trebuchet MS'; font-weight: bold; letter-spacing: 1px; } #interfaceControlFrameContainer { float: right; background-color: #f5f5f5; overflow: hidden; width: 100%; } #interfaceControlFrameLogoContainer { background-color: White; padding: 20px 10px 10px 10px; overflow: hidden; } #interfaceControlFrameLogoImageContainer { text-align: center; } #interfaceControlFrameLogoCaptionContainer { text-align: center; margin: 5px 10px 0px 10px; font-size: 12px; color: #4a4a4a; } #logoImage { width: 100%; } .emptyStateContainer { text-align: center; padding: 0px 10px; margin-top: 32px } .emptyStateTitle { margin: 0px 0px 9px 0px; font-weight: bold; } .emptyStateContent { line-height: 16px; } .dottedDivider { height: 2px; margin: 15px 0px 15px 0px; background: url('../images/divider.png') no-repeat center center; background: url('../images/divider.svg') no-repeat center center, linear-gradient(transparent,transparent); } .nondottedDivider { height: 2px; margin: 9px 0px 9px 0px; }"},{"title":"","date":"2023-02-27T14:44:57.217Z","updated":"2023-02-27T14:44:57.217Z","comments":true,"path":"imgs/axure/我的考试_files/debug.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/debug.css","excerpt":"","text":"#debugHost { font-size: 12px; color:#4a4a4a; height: 100%; } #debugHostBtn a { background: url('images/variables_on.png'); background: url('images/variables_on.svg'),linear-gradient(transparent, transparent); } .hashover #debugHostBtn a:hover { background: url('images/variables_hover.png'); background: url('images/variables_hover.svg'),linear-gradient(transparent, transparent); } #debugHostBtn a.selected, #debugHostBtn a.selected:hover { background: url('images/variables_off.png'); background: url('images/variables_off.svg'),linear-gradient(transparent, transparent); } #debugHeader .pageNameHeader { padding-right: 0px; } #variablesClearLink { display: inline-block; margin-bottom: 15px; } #variablesClearLink:hover { color: #0a6cd6; } #traceClearLink { display: inline-block; margin-bottom: 15px; } #traceClearLink:hover { color: #0a6cd6; } #debugScrollContainer { overflow: auto; width: 100%; height: 100%; -webkit-overflow-scrolling: touch; } #debugContainer { padding: 10px 10px 10px 10px; } .variableName { font-weight: bold; } .variableDiv { margin-bottom: 20px; line-height: 16px; } #variablesContainer { padding-bottom: 5px; /*overflow: auto;*/ } #traceContainer { padding-top: 15px; /*padding: 0px 10px 10px 10px;*/ } .debugToolbarButton { font-size: 1em; color: #069; } .axEventBlock { display: inline-block; width: 100%; margin: 5px 0px 5px 0px; line-height: 21px; } /*a.axEventBlock:hover { background-color: #069; color: white; }*/ .axTime { margin: 0px 0px 0px 0px; font-size: 11px; color: #b1b3b5; } .axLabel { margin: 0px 0px 5px 0px; font-family: 'Trebuchet MS'; font-size: 14px; font-weight: bold; } .lastAxEvent { margin-bottom: 10px; border-bottom: 1px solid #c2c2c2; padding-bottom: 10px; } .axEvent { margin: 0px 0px 5px 0px; font-weight: bold; } .axCase { margin: 0px 0px 5px 8px; font-style: italic; } .axAction { margin: 0px 0px 5px 13px; } #traceEmptyState.emptyStateContainer { margin-top: 0px; } .debugLinksContainer { text-align: right; }"},{"title":"","date":"2023-02-27T14:44:57.217Z","updated":"2023-02-27T14:44:57.217Z","comments":true,"path":"imgs/axure/我的考试_files/data.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/data.js","excerpt":"","text":"$axure.loadCurrentPage( (function() { var _ = function() { var r={},a=arguments; for(var i=0; i"},{"title":"","date":"2023-02-27T14:44:57.218Z","updated":"2023-02-27T14:44:57.218Z","comments":true,"path":"imgs/axure/我的考试_files/document(1).js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/document(1).js","excerpt":"","text":"$axure.loadDocument( (function() { var _ = function() { var r={},a=arguments; for(var i=0; i"},{"title":"","date":"2023-02-27T14:44:57.218Z","updated":"2023-02-27T14:44:57.218Z","comments":true,"path":"imgs/axure/我的考试_files/document.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/document.js","excerpt":"","text":"$axure.loadDocument( (function() { var _ = function() { var r={},a=arguments; for(var i=0; i"},{"title":"","date":"2023-02-27T14:44:57.219Z","updated":"2023-02-27T14:44:57.219Z","comments":true,"path":"imgs/axure/我的考试_files/jquery-1.7.1.min(1).js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/jquery-1.7.1.min(1).js","excerpt":"","text":"/*! jQuery v1.7.1 jquery.com | jquery.org/license */ (function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f(\"\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){cl||(cl=c.createElement(\"iframe\"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode===\"CSS1Compat\"?\"\":\"\")+\"\"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g"},{"title":"","date":"2023-02-27T14:44:57.218Z","updated":"2023-02-27T14:44:57.218Z","comments":true,"path":"imgs/axure/我的考试_files/expand.html","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/expand.html","excerpt":"","text":""},{"title":"","date":"2023-02-27T14:44:57.220Z","updated":"2023-02-27T14:44:57.220Z","comments":true,"path":"imgs/axure/我的考试_files/jquery-1.7.1.min.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/jquery-1.7.1.min.js","excerpt":"","text":"/*! jQuery v1.7.1 jquery.com | jquery.org/license */ (function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f(\"\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){cl||(cl=c.createElement(\"iframe\"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode===\"CSS1Compat\"?\"\":\"\")+\"\"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g"},{"title":"","date":"2023-02-27T14:44:57.221Z","updated":"2023-02-27T14:44:57.221Z","comments":true,"path":"imgs/axure/我的考试_files/jquery-ui-themes.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/jquery-ui-themes.css","excerpt":"","text":"/* * jQuery UI CSS Framework * Copyright (c) 2009 AUTHORS.txt (http://jqueryui.com/about) * Dual licensed under the MIT (MIT-LICENSE.txt) and GPL (GPL-LICENSE.txt) licenses. */ /* Layout helpers ----------------------------------*/ .ui-helper-hidden { display: none; } .ui-helper-hidden-accessible { position: absolute; left: -99999999px; } .ui-helper-reset { margin: 0; padding: 0; border: 0; outline: 0; line-height: 1.3; text-decoration: none; font-size: 100%; list-style: none; } .ui-helper-clearfix:after { content: \".\"; display: block; height: 0; clear: both; visibility: hidden; } .ui-helper-clearfix { display: inline-block; } /* required comment for clearfix to work in Opera \\*/ * html .ui-helper-clearfix { height:1%; } .ui-helper-clearfix { display:block; } /* end clearfix */ .ui-helper-zfix { width: 100%; height: 100%; top: 0; left: 0; position: absolute; opacity: 0; filter:Alpha(Opacity=0); } /* Interaction Cues ----------------------------------*/ .ui-state-disabled { cursor: default !important; } /* Icons ----------------------------------*/ /* states and images */ .ui-icon { display: block; text-indent: -99999px; overflow: hidden; background-repeat: no-repeat; } /* Misc visuals ----------------------------------*/ /* Overlays */ .ui-widget-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }/* Accordion ----------------------------------*/ .ui-accordion .ui-accordion-header { cursor: pointer; position: relative; margin-top: 1px; zoom: 1; } .ui-accordion .ui-accordion-li-fix { display: inline; } .ui-accordion .ui-accordion-header-active { border-bottom: 0 !important; } .ui-accordion .ui-accordion-header a { display: block; font-size: 1em; padding: .5em .5em .5em 2.2em; } .ui-accordion .ui-accordion-header .ui-icon { position: absolute; left: .5em; top: 50%; margin-top: -8px; } .ui-accordion .ui-accordion-content { padding: 1em 2.2em; border-top: 0; margin-top: -2px; position: relative; top: 1px; margin-bottom: 2px; overflow: auto; display: none; } .ui-accordion .ui-accordion-content-active { display: block; } /* Datepicker ----------------------------------*/ .ui-datepicker { width: 17em; padding: .2em .2em 0; } .ui-datepicker .ui-datepicker-header { position:relative; padding:.2em 0; } .ui-datepicker .ui-datepicker-prev, .ui-datepicker .ui-datepicker-next { position:absolute; top: 2px; width: 1.8em; height: 1.8em; } .ui-datepicker .ui-datepicker-prev-hover, .ui-datepicker .ui-datepicker-next-hover { top: 1px; } .ui-datepicker .ui-datepicker-prev { left:2px; } .ui-datepicker .ui-datepicker-next { right:2px; } .ui-datepicker .ui-datepicker-prev-hover { left:1px; } .ui-datepicker .ui-datepicker-next-hover { right:1px; } .ui-datepicker .ui-datepicker-prev span, .ui-datepicker .ui-datepicker-next span { display: block; position: absolute; left: 50%; margin-left: -8px; top: 50%; margin-top: -8px; } .ui-datepicker .ui-datepicker-title { margin: 0 2.3em; line-height: 1.8em; text-align: center; } .ui-datepicker .ui-datepicker-title select { float:left; font-size:1em; margin:1px 0; } .ui-datepicker select.ui-datepicker-month-year {width: 100%;} .ui-datepicker select.ui-datepicker-month, .ui-datepicker select.ui-datepicker-year { width: 49%;} .ui-datepicker .ui-datepicker-title select.ui-datepicker-year { float: right; } .ui-datepicker table {width: 100%; font-size: .9em; border-collapse: collapse; margin:0 0 .4em; } .ui-datepicker th { padding: .7em .3em; text-align: center; font-weight: bold; border: 0; } .ui-datepicker td { border: 0; padding: 1px; } .ui-datepicker td span, .ui-datepicker td a { display: block; padding: .2em; text-align: right; text-decoration: none; } .ui-datepicker .ui-datepicker-buttonpane { background-image: none; margin: .7em 0 0 0; padding:0 .2em; border-left: 0; border-right: 0; border-bottom: 0; } .ui-datepicker .ui-datepicker-buttonpane button { float: right; margin: .5em .2em .4em; cursor: pointer; padding: .2em .6em .3em .6em; width:auto; overflow:visible; } .ui-datepicker .ui-datepicker-buttonpane button.ui-datepicker-current { float:left; } /* with multiple calendars */ .ui-datepicker.ui-datepicker-multi { width:auto; } .ui-datepicker-multi .ui-datepicker-group { float:left; } .ui-datepicker-multi .ui-datepicker-group table { width:95%; margin:0 auto .4em; } .ui-datepicker-multi-2 .ui-datepicker-group { width:50%; } .ui-datepicker-multi-3 .ui-datepicker-group { width:33.3%; } .ui-datepicker-multi-4 .ui-datepicker-group { width:25%; } .ui-datepicker-multi .ui-datepicker-group-last .ui-datepicker-header { border-left-width:0; } .ui-datepicker-multi .ui-datepicker-group-middle .ui-datepicker-header { border-left-width:0; } .ui-datepicker-multi .ui-datepicker-buttonpane { clear:left; } .ui-datepicker-row-break { clear:both; width:100%; } /* RTL support */ .ui-datepicker-rtl { direction: rtl; } .ui-datepicker-rtl .ui-datepicker-prev { right: 2px; left: auto; } .ui-datepicker-rtl .ui-datepicker-next { left: 2px; right: auto; } .ui-datepicker-rtl .ui-datepicker-prev:hover { right: 1px; left: auto; } .ui-datepicker-rtl .ui-datepicker-next:hover { left: 1px; right: auto; } .ui-datepicker-rtl .ui-datepicker-buttonpane { clear:right; } .ui-datepicker-rtl .ui-datepicker-buttonpane button { float: left; } .ui-datepicker-rtl .ui-datepicker-buttonpane button.ui-datepicker-current { float:right; } .ui-datepicker-rtl .ui-datepicker-group { float:right; } .ui-datepicker-rtl .ui-datepicker-group-last .ui-datepicker-header { border-right-width:0; border-left-width:1px; } .ui-datepicker-rtl .ui-datepicker-group-middle .ui-datepicker-header { border-right-width:0; border-left-width:1px; } /* IE6 IFRAME FIX (taken from datepicker 1.5.3 */ .ui-datepicker-cover { display: none; /*sorry for IE5*/ display/**/: block; /*sorry for IE5*/ position: absolute; /*must have*/ z-index: -1; /*must have*/ filter: mask(); /*must have*/ top: -4px; /*must have*/ left: -4px; /*must have*/ width: 200px; /*must have*/ height: 200px; /*must have*/ } /* Dialog ----------------------------------*/ .ui-dialog { position: relative; padding: 0px; width: 300px;} .ui-dialog .ui-dialog-titlebar { padding: .3em .3em .1em .8em; font-size:.7em; position: relative; background-image: none; } .ui-dialog .ui-dialog-title { float: left; margin: .1em 0 .2em; font-family: 'Trebuchet MS'; font-size: 15px; font-weight: normal; color: #ffffff;} .ui-dialog .ui-dialog-titlebar-close { position: absolute; right: .1em; top: 50%; width: 19px; margin: -10px 0 0 0; padding: 1px; height: 18px; } .ui-dialog .ui-dialog-titlebar-close span { display: block; margin: 1px; } .ui-dialog .ui-dialog-titlebar-close:hover, .ui-dialog .ui-dialog-titlebar-close:focus { /*padding: 0;*/ } .ui-dialog .ui-dialog-content { border: 0; padding: .5em .2em; background: none; overflow: auto; zoom: 1; background-color: #ffffff;} .ui-dialog .ui-dialog-buttonpane { text-align: left; border-width: 1px 0 0 0; background-image: none; margin: .5em 0 0 0; padding: .3em 1em .5em .4em; } .ui-dialog .ui-dialog-buttonpane button { float: right; margin: .5em .4em .5em 0; cursor: pointer; padding: .2em .6em .3em .6em; line-height: 1.4em; width:auto; overflow:visible; } .ui-dialog .ui-resizable-se { width: 14px; height: 14px; right: 3px; bottom: 3px; } .ui-draggable .ui-dialog-titlebar { cursor: move; background-color: #8f949a; border-bottom: 1px solid #d9d9d9;} /* Progressbar ----------------------------------*/ .ui-progressbar { height:2em; text-align: left; } .ui-progressbar .ui-progressbar-value {margin: -1px; height:100%; }/* Resizable ----------------------------------*/ .ui-resizable { position: relative;} .ui-resizable-handle { position: absolute;font-size: 0.1px;z-index: 99999; display: block;} .ui-resizable-disabled .ui-resizable-handle, .ui-resizable-autohide .ui-resizable-handle { display: none; } .ui-resizable-n { cursor: n-resize; height: 7px; width: 100%; top: -5px; left: 0px; } .ui-resizable-s { cursor: s-resize; height: 7px; width: 100%; bottom: -5px; left: 0px; } .ui-resizable-e { cursor: e-resize; width: 7px; right: -5px; top: 0px; height: 100%; } .ui-resizable-w { cursor: w-resize; width: 7px; left: -5px; top: 0px; height: 100%; } .ui-resizable-se { cursor: se-resize; width: 12px; height: 12px; right: 1px; bottom: 1px; } .ui-resizable-sw { cursor: sw-resize; width: 9px; height: 9px; left: -5px; bottom: -5px; } .ui-resizable-nw { cursor: nw-resize; width: 9px; height: 9px; left: -5px; top: -5px; } .ui-resizable-ne { cursor: ne-resize; width: 9px; height: 9px; right: -5px; top: -5px;}/* Slider ----------------------------------*/ .ui-slider { position: relative; text-align: left; } .ui-slider .ui-slider-handle { position: absolute; z-index: 2; width: 1.2em; height: 1.2em; cursor: default; } .ui-slider .ui-slider-range { position: absolute; z-index: 1; font-size: .7em; display: block; border: 0; } .ui-slider-horizontal { height: .8em; } .ui-slider-horizontal .ui-slider-handle { top: -.3em; margin-left: -.6em; } .ui-slider-horizontal .ui-slider-range { top: 0; height: 100%; } .ui-slider-horizontal .ui-slider-range-min { left: 0; } .ui-slider-horizontal .ui-slider-range-max { right: 0; } .ui-slider-vertical { width: .8em; height: 100px; } .ui-slider-vertical .ui-slider-handle { left: -.3em; margin-left: 0; margin-bottom: -.6em; } .ui-slider-vertical .ui-slider-range { left: 0; width: 100%; } .ui-slider-vertical .ui-slider-range-min { bottom: 0; } .ui-slider-vertical .ui-slider-range-max { top: 0; }/* Tabs ----------------------------------*/ .ui-tabs { padding: .2em; zoom: 1; } .ui-tabs .ui-tabs-nav { list-style: none; position: relative; padding: .2em .2em 0; } .ui-tabs .ui-tabs-nav li { position: relative; float: left; border-bottom-width: 0 !important; margin: 0 .2em -1px 0; padding: 0; } .ui-tabs .ui-tabs-nav li a { float: left; text-decoration: none; padding: .5em 1em; } .ui-tabs .ui-tabs-nav li.ui-tabs-selected { padding-bottom: 1px; border-bottom-width: 0; } .ui-tabs .ui-tabs-nav li.ui-tabs-selected a, .ui-tabs .ui-tabs-nav li.ui-state-disabled a, .ui-tabs .ui-tabs-nav li.ui-state-processing a { cursor: text; } .ui-tabs .ui-tabs-nav li a, .ui-tabs.ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-selected a { cursor: pointer; } /* first selector in group seems obsolete, but required to overcome bug in Opera applying cursor: text overall if defined elsewhere... */ .ui-tabs .ui-tabs-panel { padding: 1em 1.4em; display: block; border-width: 0; background: none; } .ui-tabs .ui-tabs-hide { display: none !important; } /* * jQuery UI CSS Framework * Copyright (c) 2009 AUTHORS.txt (http://jqueryui.com/about) * Dual licensed under the MIT (MIT-LICENSE.txt) and GPL (GPL-LICENSE.txt) licenses. * To view and modify this theme, visit http://jqueryui.com/themeroller/ */ /* Component containers ----------------------------------*/ .ui-widget { font-family: Verdana,Arial,sans-serif/*{ffDefault}*/; font-size: 1.1em/*{fsDefault}*/; } .ui-widget input, .ui-widget select, .ui-widget textarea, .ui-widget button { font-family: Verdana,Arial,sans-serif/*{ffDefault}*/; font-size: 1em; } .ui-widget-content { border: 1px solid #aaaaaa/*{borderColorContent}*/; background: #ffffff/*{bgColorContent}*/ url(images/ui-bg_glass_75_ffffff_1x400.png)/*{bgImgUrlContent}*/ 0/*{bgContentXPos}*/ 0/*{bgContentYPos}*/ repeat-x/*{bgContentRepeat}*/; color: #222222/*{fcContent}*/; } .ui-widget-content a { /*color: #222222*//*{fcContent}*/; } .ui-widget-header { border: none /*1px solid #aaaaaa*//*{borderColorHeader}*/; background: #D3D3D3/*{bgColorHeader}*/ url(images/ui-bg_highlight-soft_75_cccccc_1x100.png)/*{bgImgUrlHeader}*/ 0/*{bgHeaderXPos}*/ 50%/*{bgHeaderYPos}*/ repeat-x/*{bgHeaderRepeat}*/; color: #000000/*{fcHeader}*/; font-weight: bold; } .ui-widget-header a { color: #222222/*{fcHeader}*/; } /* Interaction states ----------------------------------*/ .ui-state-default, .ui-widget-content .ui-state-default { border: none /*1px solid #d3d3d3*//*{borderColorDefault}*/; /*background: #e6e6e6*//*{bgColorDefault}*/ /*url(images/ui-bg_glass_75_e6e6e6_1x400.png)*//*{bgImgUrlDefault}*/ /*0*//*{bgDefaultXPos}*/ /*50%*//*{bgDefaultYPos}*/ /*repeat-x*//*{bgDefaultRepeat}*/ font-weight: normal/*{fwDefault}*/; color: #555555/*{fcDefault}*/; outline: none; } .ui-state-default a, .ui-state-default a:link, .ui-state-default a:visited { color: #555555/*{fcDefault}*/; text-decoration: none; outline: none; } .ui-state-hover, .ui-widget-content .ui-state-hover, .ui-state-focus, .ui-widget-content .ui-state-focus { border: none /*1px solid #999999*//*{borderColorHover}*/; /*background: #dadada*//*{bgColorHover}*/ /*url(images/ui-bg_glass_75_dadada_1x400.png)*//*{bgImgUrlHover}*/ /*0*//*{bgHoverXPos}*/ /*50%*//*{bgHoverYPos}*/ /*repeat-x*//*{bgHoverRepeat}*/ font-weight: normal/*{fwDefault}*/; color: #212121/*{fcHover}*/; outline: none; } .ui-state-hover a, .ui-state-hover a:hover { color: #212121/*{fcHover}*/; text-decoration: none; outline: none; } .ui-state-active, .ui-widget-content .ui-state-active { border: 1px solid #aaaaaa/*{borderColorActive}*/; background: #ffffff/*{bgColorActive}*/ url(images/ui-bg_glass_65_ffffff_1x400.png)/*{bgImgUrlActive}*/ 0/*{bgActiveXPos}*/ 50%/*{bgActiveYPos}*/ repeat-x/*{bgActiveRepeat}*/; font-weight: normal/*{fwDefault}*/; color: #212121/*{fcActive}*/; outline: none; } .ui-state-active a, .ui-state-active a:link, .ui-state-active a:visited { color: #212121/*{fcActive}*/; outline: none; text-decoration: none; } /* Interaction Cues ----------------------------------*/ .ui-state-highlight, .ui-widget-content .ui-state-highlight {border: 1px solid #fcefa1/*{borderColorHighlight}*/; background: #fbf9ee/*{bgColorHighlight}*/ url(images/ui-bg_glass_55_fbf9ee_1x400.png)/*{bgImgUrlHighlight}*/ 0/*{bgHighlightXPos}*/ 50%/*{bgHighlightYPos}*/ repeat-x/*{bgHighlightRepeat}*/; color: #363636/*{fcHighlight}*/; } .ui-state-highlight a, .ui-widget-content .ui-state-highlight a { color: #363636/*{fcHighlight}*/; } .ui-state-error, .ui-widget-content .ui-state-error {border: 1px solid #cd0a0a/*{borderColorError}*/; background: #fef1ec/*{bgColorError}*/ url(images/ui-bg_inset-soft_95_fef1ec_1x100.png)/*{bgImgUrlError}*/ 0/*{bgErrorXPos}*/ 50%/*{bgErrorYPos}*/ repeat-x/*{bgErrorRepeat}*/; color: #cd0a0a/*{fcError}*/; } .ui-state-error a, .ui-widget-content .ui-state-error a { color: #363636/*{fcError}*/; } .ui-state-error-text, .ui-widget-content .ui-state-error-text { color: #cd0a0a/*{fcError}*/; } .ui-state-disabled, .ui-widget-content .ui-state-disabled { opacity: .35; filter:Alpha(Opacity=35); background-image: none; } .ui-priority-primary, .ui-widget-content .ui-priority-primary { font-weight: bold; } .ui-priority-secondary, .ui-widget-content .ui-priority-secondary { opacity: .7; filter:Alpha(Opacity=70); font-weight: normal; } /* Icons ----------------------------------*/ /* states and images */ .ui-icon { width: 16px; height: 16px; background-image: url(images/ui-icons_222222_256x240.png)/*{iconsContent}*/; } .ui-widget-content .ui-icon {background-image: url(images/ui-icons_222222_256x240.png)/*{iconsContent}*/; } .ui-widget-header .ui-icon {background-image: url(images/ui-icons_454545_256x240.png)/*{iconsHeader}*/; } .ui-state-default .ui-icon { background-image: url(images/ui-icons_888888_256x240.png)/*{iconsDefault}*/; } .ui-state-hover .ui-icon, .ui-state-focus .ui-icon {background-image: url(images/ui-icons_222222_256x240.png)/*{iconsHover}*/; } .ui-state-active .ui-icon {background-image: url(images/ui-icons_454545_256x240.png)/*{iconsActive}*/; } .ui-state-highlight .ui-icon {background-image: url(images/ui-icons_2e83ff_256x240.png)/*{iconsHighlight}*/; } .ui-state-error .ui-icon, .ui-state-error-text .ui-icon {background-image: url(images/ui-icons_cd0a0a_256x240.png)/*{iconsError}*/; } /* positioning */ .ui-icon-carat-1-n { background-position: 0 0; } .ui-icon-carat-1-ne { background-position: -16px 0; } .ui-icon-carat-1-e { background-position: -32px 0; } .ui-icon-carat-1-se { background-position: -48px 0; } .ui-icon-carat-1-s { background-position: -64px 0; } .ui-icon-carat-1-sw { background-position: -80px 0; } .ui-icon-carat-1-w { background-position: -96px 0; } .ui-icon-carat-1-nw { background-position: -112px 0; } .ui-icon-carat-2-n-s { background-position: -128px 0; } .ui-icon-carat-2-e-w { background-position: -144px 0; } .ui-icon-triangle-1-n { background-position: 0 -16px; } .ui-icon-triangle-1-ne { background-position: -16px -16px; } .ui-icon-triangle-1-e { background-position: -32px -16px; } .ui-icon-triangle-1-se { background-position: -48px -16px; } .ui-icon-triangle-1-s { background-position: -64px -16px; } .ui-icon-triangle-1-sw { background-position: -80px -16px; } .ui-icon-triangle-1-w { background-position: -96px -16px; } .ui-icon-triangle-1-nw { background-position: -112px -16px; } .ui-icon-triangle-2-n-s { background-position: -128px -16px; } .ui-icon-triangle-2-e-w { background-position: -144px -16px; } .ui-icon-arrow-1-n { background-position: 0 -32px; } .ui-icon-arrow-1-ne { background-position: -16px -32px; } .ui-icon-arrow-1-e { background-position: -32px -32px; } .ui-icon-arrow-1-se { background-position: -48px -32px; } .ui-icon-arrow-1-s { background-position: -64px -32px; } .ui-icon-arrow-1-sw { background-position: -80px -32px; } .ui-icon-arrow-1-w { background-position: -96px -32px; } .ui-icon-arrow-1-nw { background-position: -112px -32px; } .ui-icon-arrow-2-n-s { background-position: -128px -32px; } .ui-icon-arrow-2-ne-sw { background-position: -144px -32px; } .ui-icon-arrow-2-e-w { background-position: -160px -32px; } .ui-icon-arrow-2-se-nw { background-position: -176px -32px; } .ui-icon-arrowstop-1-n { background-position: -192px -32px; } .ui-icon-arrowstop-1-e { background-position: -208px -32px; } .ui-icon-arrowstop-1-s { background-position: -224px -32px; } .ui-icon-arrowstop-1-w { background-position: -240px -32px; } .ui-icon-arrowthick-1-n { background-position: 0 -48px; } .ui-icon-arrowthick-1-ne { background-position: -16px -48px; } .ui-icon-arrowthick-1-e { background-position: -32px -48px; } .ui-icon-arrowthick-1-se { background-position: -48px -48px; } .ui-icon-arrowthick-1-s { background-position: -64px -48px; } .ui-icon-arrowthick-1-sw { background-position: -80px -48px; } .ui-icon-arrowthick-1-w { background-position: -96px -48px; } .ui-icon-arrowthick-1-nw { background-position: -112px -48px; } .ui-icon-arrowthick-2-n-s { background-position: -128px -48px; } .ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; } .ui-icon-arrowthick-2-e-w { background-position: -160px -48px; } .ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; } .ui-icon-arrowthickstop-1-n { background-position: -192px -48px; } .ui-icon-arrowthickstop-1-e { background-position: -208px -48px; } .ui-icon-arrowthickstop-1-s { background-position: -224px -48px; } .ui-icon-arrowthickstop-1-w { background-position: -240px -48px; } .ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; } .ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; } .ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; } .ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; } .ui-icon-arrowreturn-1-w { background-position: -64px -64px; } .ui-icon-arrowreturn-1-n { background-position: -80px -64px; } .ui-icon-arrowreturn-1-e { background-position: -96px -64px; } .ui-icon-arrowreturn-1-s { background-position: -112px -64px; } .ui-icon-arrowrefresh-1-w { background-position: -128px -64px; } .ui-icon-arrowrefresh-1-n { background-position: -144px -64px; } .ui-icon-arrowrefresh-1-e { background-position: -160px -64px; } .ui-icon-arrowrefresh-1-s { background-position: -176px -64px; } .ui-icon-arrow-4 { background-position: 0 -80px; } .ui-icon-arrow-4-diag { background-position: -16px -80px; } .ui-icon-extlink { background-position: -32px -80px; } .ui-icon-newwin { background-position: -48px -80px; } .ui-icon-refresh { background-position: -64px -80px; } .ui-icon-shuffle { background-position: -80px -80px; } .ui-icon-transfer-e-w { background-position: -96px -80px; } .ui-icon-transferthick-e-w { background-position: -112px -80px; } .ui-icon-folder-collapsed { background-position: 0 -96px; } .ui-icon-folder-open { background-position: -16px -96px; } .ui-icon-document { background-position: -32px -96px; } .ui-icon-document-b { background-position: -48px -96px; } .ui-icon-note { background-position: -64px -96px; } .ui-icon-mail-closed { background-position: -80px -96px; } .ui-icon-mail-open { background-position: -96px -96px; } .ui-icon-suitcase { background-position: -112px -96px; } .ui-icon-comment { background-position: -128px -96px; } .ui-icon-person { background-position: -144px -96px; } .ui-icon-print { background-position: -160px -96px; } .ui-icon-trash { background-position: -176px -96px; } .ui-icon-locked { background-position: -192px -96px; } .ui-icon-unlocked { background-position: -208px -96px; } .ui-icon-bookmark { background-position: -224px -96px; } .ui-icon-tag { background-position: -240px -96px; } .ui-icon-home { background-position: 0 -112px; } .ui-icon-flag { background-position: -16px -112px; } .ui-icon-calendar { background-position: -32px -112px; } .ui-icon-cart { background-position: -48px -112px; } .ui-icon-pencil { background-position: -64px -112px; } .ui-icon-clock { background-position: -80px -112px; } .ui-icon-disk { background-position: -96px -112px; } .ui-icon-calculator { background-position: -112px -112px; } .ui-icon-zoomin { background-position: -128px -112px; } .ui-icon-zoomout { background-position: -144px -112px; } .ui-icon-search { background-position: -160px -112px; } .ui-icon-wrench { background-position: -176px -112px; } .ui-icon-gear { background-position: -192px -112px; } .ui-icon-heart { background-position: -208px -112px; } .ui-icon-star { background-position: -224px -112px; } .ui-icon-link { background-position: -240px -112px; } .ui-icon-cancel { background-position: 0 -128px; } .ui-icon-plus { background-position: -16px -128px; } .ui-icon-plusthick { background-position: -32px -128px; } .ui-icon-minus { background-position: -48px -128px; } .ui-icon-minusthick { background-position: -64px -128px; } .ui-icon-close { background-position: -80px -128px; } .ui-icon-closethick { background-position: -96px -128px; } .ui-icon-key { background-position: -112px -128px; } .ui-icon-lightbulb { background-position: -128px -128px; } .ui-icon-scissors { background-position: -144px -128px; } .ui-icon-clipboard { background-position: -160px -128px; } .ui-icon-copy { background-position: -176px -128px; } .ui-icon-contact { background-position: -192px -128px; } .ui-icon-image { background-position: -208px -128px; } .ui-icon-video { background-position: -224px -128px; } .ui-icon-script { background-position: -240px -128px; } .ui-icon-alert { background-position: 0 -144px; } .ui-icon-info { background-position: -16px -144px; } .ui-icon-notice { background-position: -32px -144px; } .ui-icon-help { background-position: -48px -144px; } .ui-icon-check { background-position: -64px -144px; } .ui-icon-bullet { background-position: -80px -144px; } .ui-icon-radio-off { background-position: -96px -144px; } .ui-icon-radio-on { background-position: -112px -144px; } .ui-icon-pin-w { background-position: -128px -144px; } .ui-icon-pin-s { background-position: -144px -144px; } .ui-icon-play { background-position: 0 -160px; } .ui-icon-pause { background-position: -16px -160px; } .ui-icon-seek-next { background-position: -32px -160px; } .ui-icon-seek-prev { background-position: -48px -160px; } .ui-icon-seek-end { background-position: -64px -160px; } .ui-icon-seek-first { background-position: -80px -160px; } .ui-icon-stop { background-position: -96px -160px; } .ui-icon-eject { background-position: -112px -160px; } .ui-icon-volume-off { background-position: -128px -160px; } .ui-icon-volume-on { background-position: -144px -160px; } .ui-icon-power { background-position: 0 -176px; } .ui-icon-signal-diag { background-position: -16px -176px; } .ui-icon-signal { background-position: -32px -176px; } .ui-icon-battery-0 { background-position: -48px -176px; } .ui-icon-battery-1 { background-position: -64px -176px; } .ui-icon-battery-2 { background-position: -80px -176px; } .ui-icon-battery-3 { background-position: -96px -176px; } .ui-icon-circle-plus { background-position: 0 -192px; } .ui-icon-circle-minus { background-position: -16px -192px; } .ui-icon-circle-close { background-position: -32px -192px; } .ui-icon-circle-triangle-e { background-position: -48px -192px; } .ui-icon-circle-triangle-s { background-position: -64px -192px; } .ui-icon-circle-triangle-w { background-position: -80px -192px; } .ui-icon-circle-triangle-n { background-position: -96px -192px; } .ui-icon-circle-arrow-e { background-position: -112px -192px; } .ui-icon-circle-arrow-s { background-position: -128px -192px; } .ui-icon-circle-arrow-w { background-position: -144px -192px; } .ui-icon-circle-arrow-n { background-position: -160px -192px; } .ui-icon-circle-zoomin { background-position: -176px -192px; } .ui-icon-circle-zoomout { background-position: -192px -192px; } .ui-icon-circle-check { background-position: -208px -192px; } .ui-icon-circlesmall-plus { background-position: 0 -208px; } .ui-icon-circlesmall-minus { background-position: -16px -208px; } .ui-icon-circlesmall-close { background-position: -32px -208px; } .ui-icon-squaresmall-plus { background-position: -48px -208px; } .ui-icon-squaresmall-minus { background-position: -64px -208px; } .ui-icon-squaresmall-close { background-position: -80px -208px; } .ui-icon-grip-dotted-vertical { background-position: 0 -224px; } .ui-icon-grip-dotted-horizontal { background-position: -16px -224px; } .ui-icon-grip-solid-vertical { background-position: -32px -224px; } .ui-icon-grip-solid-horizontal { background-position: -48px -224px; } .ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; } .ui-icon-grip-diagonal-se { background-position: -80px -224px; } /* Misc visuals ----------------------------------*/ /* Corner radius */ .ui-corner-tl { -moz-border-radius-topleft: 4px/*{cornerRadius}*/; -webkit-border-top-left-radius: 4px/*{cornerRadius}*/; } .ui-corner-tr { -moz-border-radius-topright: 4px/*{cornerRadius}*/; -webkit-border-top-right-radius: 4px/*{cornerRadius}*/; } .ui-corner-bl { -moz-border-radius-bottomleft: 4px/*{cornerRadius}*/; -webkit-border-bottom-left-radius: 4px/*{cornerRadius}*/; } .ui-corner-br { -moz-border-radius-bottomright: 4px/*{cornerRadius}*/; -webkit-border-bottom-right-radius: 4px/*{cornerRadius}*/; } .ui-corner-top { -moz-border-radius-topleft: 4px/*{cornerRadius}*/; -webkit-border-top-left-radius: 4px/*{cornerRadius}*/; -moz-border-radius-topright: 4px/*{cornerRadius}*/; -webkit-border-top-right-radius: 4px/*{cornerRadius}*/; } .ui-corner-bottom { -moz-border-radius-bottomleft: 4px/*{cornerRadius}*/; -webkit-border-bottom-left-radius: 4px/*{cornerRadius}*/; -moz-border-radius-bottomright: 4px/*{cornerRadius}*/; -webkit-border-bottom-right-radius: 4px/*{cornerRadius}*/; } .ui-corner-right { -moz-border-radius-topright: 4px/*{cornerRadius}*/; -webkit-border-top-right-radius: 4px/*{cornerRadius}*/; -moz-border-radius-bottomright: 4px/*{cornerRadius}*/; -webkit-border-bottom-right-radius: 4px/*{cornerRadius}*/; } .ui-corner-left { -moz-border-radius-topleft: 4px/*{cornerRadius}*/; -webkit-border-top-left-radius: 4px/*{cornerRadius}*/; -moz-border-radius-bottomleft: 4px/*{cornerRadius}*/; -webkit-border-bottom-left-radius: 4px/*{cornerRadius}*/; } .ui-corner-all { -moz-border-radius: 0px/*{cornerRadius}*/; -webkit-border-radius: 0px/*{cornerRadius}*/; } /* Overlays */ .ui-widget-overlay { background: #aaaaaa/*{bgColorOverlay}*/ none/*{bgImgUrlOverlay}*/ 0/*{bgOverlayXPos}*/ 0/*{bgOverlayYPos}*/ repeat-x/*{bgOverlayRepeat}*/; opacity: .3;filter:Alpha(Opacity=30)/*{opacityOverlay}*/; } .ui-widget-shadow { margin: -4px/*{offsetTopShadow}*/ 0 0 -4px/*{offsetLeftShadow}*/; padding: 4px/*{thicknessShadow}*/; background: #aaaaaa/*{bgColorShadow}*/ none/*{bgImgUrlShadow}*/ 0/*{bgShadowXPos}*/ 0/*{bgShadowYPos}*/ repeat-x/*{bgShadowRepeat}*/; opacity: .35;filter:Alpha(Opacity=35)/*{opacityShadow}*/; -moz-border-radius: 4px/*{cornerRadiusShadow}*/; -webkit-border-radius: 4px/*{cornerRadiusShadow}*/; }"},{"title":"","date":"2023-02-27T14:44:57.220Z","updated":"2023-02-27T14:44:57.220Z","comments":true,"path":"imgs/axure/我的考试_files/jquery-ui-1.8.10.custom.min.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/jquery-ui-1.8.10.custom.min.js","excerpt":"","text":"/*! * jQuery UI 1.8.10 * * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about) * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * http://docs.jquery.com/UI */ (function(c,j){function k(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,\"visibility\")===\"hidden\"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:\"1.8.10\",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106, NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({_focus:c.fn.focus,focus:function(a,b){return typeof a===\"number\"?this.each(function(){var d=this;setTimeout(function(){c(d).focus();b&&b.call(d)},a)}):this._focus.apply(this,arguments)},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css(\"position\"))||/absolute/.test(this.css(\"position\"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this, \"position\",1))&&/(auto|scroll)/.test(c.curCSS(this,\"overflow\",1)+c.curCSS(this,\"overflow-y\",1)+c.curCSS(this,\"overflow-x\",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,\"overflow\",1)+c.curCSS(this,\"overflow-y\",1)+c.curCSS(this,\"overflow-x\",1))}).eq(0);return/fixed/.test(this.css(\"position\"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css(\"zIndex\",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css(\"position\"); if(b===\"absolute\"||b===\"relative\"||b===\"fixed\"){b=parseInt(a.css(\"zIndex\"),10);if(!isNaN(b)&&b!==0)return b}a=a.parent()}}return 0},disableSelection:function(){return this.bind((c.support.selectstart?\"selectstart\":\"mousedown\")+\".ui-disableSelection\",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(\".ui-disableSelection\")}});c.each([\"Width\",\"Height\"],function(a,b){function d(f,g,l,m){c.each(e,function(){g-=parseFloat(c.curCSS(f,\"padding\"+this,true))||0;if(l)g-=parseFloat(c.curCSS(f, \"border\"+this+\"Width\",true))||0;if(m)g-=parseFloat(c.curCSS(f,\"margin\"+this,true))||0});return g}var e=b===\"Width\"?[\"Left\",\"Right\"]:[\"Top\",\"Bottom\"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,outerWidth:c.fn.outerWidth,outerHeight:c.fn.outerHeight};c.fn[\"inner\"+b]=function(f){if(f===j)return i[\"inner\"+b].call(this);return this.each(function(){c(this).css(h,d(this,f)+\"px\")})};c.fn[\"outer\"+b]=function(f,g){if(typeof f!==\"number\")return i[\"outer\"+b].call(this,f);return this.each(function(){c(this).css(h, d(this,f,true,g)+\"px\")})}});c.extend(c.expr[\":\"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){var b=a.nodeName.toLowerCase(),d=c.attr(a,\"tabindex\");if(\"area\"===b){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!==\"map\")return false;a=c(\"img[usemap=#\"+d+\"]\")[0];return!!a&&k(a)}return(/input|select|textarea|button|object/.test(b)?!a.disabled:\"a\"==b?a.href||!isNaN(d):!isNaN(d))&&k(a)},tabbable:function(a){var b=c.attr(a,\"tabindex\");return(isNaN(b)||b>=0)&&c(a).is(\":focusable\")}}); c(function(){var a=document.body,b=a.appendChild(b=document.createElement(\"div\"));c.extend(b.style,{minHeight:\"100px\",height:\"auto\",padding:0,borderWidth:0});c.support.minHeight=b.offsetHeight===100;c.support.selectstart=\"onselectstart\"in b;a.removeChild(b).style.display=\"none\"});c.extend(c.ui,{plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&a.element[0].parentNode)for(var e=0;e0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a=9)&&!a.button)return this._mouseUp(a);if(this._mouseStarted){this._mouseDrag(a); return a.preventDefault()}if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a))(this._mouseStarted=this._mouseStart(this._mouseDownEvent,a)!==false)?this._mouseDrag(a):this._mouseUp(a);return!this._mouseStarted},_mouseUp:function(a){c(document).unbind(\"mousemove.\"+this.widgetName,this._mouseMoveDelegate).unbind(\"mouseup.\"+this.widgetName,this._mouseUpDelegate);if(this._mouseStarted){this._mouseStarted=false;a.target==this._mouseDownEvent.target&&c.data(a.target,this.widgetName+\".preventClickEvent\", true);this._mouseStop(a)}return false},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return true}})})(jQuery); ;/* * jQuery UI Position 1.8.10 * * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about) * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * http://docs.jquery.com/UI/Position */ (function(c){c.ui=c.ui||{};var n=/left|center|right/,o=/top|center|bottom/,t=c.fn.position,u=c.fn.offset;c.fn.position=function(b){if(!b||!b.of)return t.apply(this,arguments);b=c.extend({},b);var a=c(b.of),d=a[0],g=(b.collision||\"flip\").split(\" \"),e=b.offset?b.offset.split(\" \"):[0,0],h,k,j;if(d.nodeType===9){h=a.width();k=a.height();j={top:0,left:0}}else if(d.setTimeout){h=a.width();k=a.height();j={top:a.scrollTop(),left:a.scrollLeft()}}else if(d.preventDefault){b.at=\"left top\";h=k=0;j={top:b.of.pageY, left:b.of.pageX}}else{h=a.outerWidth();k=a.outerHeight();j=a.offset()}c.each([\"my\",\"at\"],function(){var f=(b[this]||\"\").split(\" \");if(f.length===1)f=n.test(f[0])?f.concat([\"center\"]):o.test(f[0])?[\"center\"].concat(f):[\"center\",\"center\"];f[0]=n.test(f[0])?f[0]:\"center\";f[1]=o.test(f[1])?f[1]:\"center\";b[this]=f});if(g.length===1)g[1]=g[0];e[0]=parseInt(e[0],10)||0;if(e.length===1)e[1]=e[0];e[1]=parseInt(e[1],10)||0;if(b.at[0]===\"right\")j.left+=h;else if(b.at[0]===\"center\")j.left+=h/2;if(b.at[1]===\"bottom\")j.top+= k;else if(b.at[1]===\"center\")j.top+=k/2;j.left+=e[0];j.top+=e[1];return this.each(function(){var f=c(this),l=f.outerWidth(),m=f.outerHeight(),p=parseInt(c.curCSS(this,\"marginLeft\",true))||0,q=parseInt(c.curCSS(this,\"marginTop\",true))||0,v=l+p+(parseInt(c.curCSS(this,\"marginRight\",true))||0),w=m+q+(parseInt(c.curCSS(this,\"marginBottom\",true))||0),i=c.extend({},j),r;if(b.my[0]===\"right\")i.left-=l;else if(b.my[0]===\"center\")i.left-=l/2;if(b.my[1]===\"bottom\")i.top-=m;else if(b.my[1]===\"center\")i.top-= m/2;i.left=Math.round(i.left);i.top=Math.round(i.top);r={left:i.left-p,top:i.top-q};c.each([\"left\",\"top\"],function(s,x){c.ui.position[g[s]]&&c.ui.position[g[s]][x](i,{targetWidth:h,targetHeight:k,elemWidth:l,elemHeight:m,collisionPosition:r,collisionWidth:v,collisionHeight:w,offset:e,my:b.my,at:b.at})});c.fn.bgiframe&&f.bgiframe();f.offset(c.extend(i,{using:b.using}))})};c.ui.position={fit:{left:function(b,a){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();b.left= d>0?b.left-d:Math.max(b.left-a.collisionPosition.left,b.left)},top:function(b,a){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();b.top=d>0?b.top-d:Math.max(b.top-a.collisionPosition.top,b.top)}},flip:{left:function(b,a){if(a.at[0]!==\"center\"){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();var g=a.my[0]===\"left\"?-a.elemWidth:a.my[0]===\"right\"?a.elemWidth:0,e=a.at[0]===\"left\"?a.targetWidth:-a.targetWidth,h=-2*a.offset[0];b.left+= a.collisionPosition.left0?g+e+h:0}},top:function(b,a){if(a.at[1]!==\"center\"){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();var g=a.my[1]===\"top\"?-a.elemHeight:a.my[1]===\"bottom\"?a.elemHeight:0,e=a.at[1]===\"top\"?a.targetHeight:-a.targetHeight,h=-2*a.offset[1];b.top+=a.collisionPosition.top0?g+e+h:0}}}};if(!c.offset.setOffset){c.offset.setOffset=function(b,a){if(/static/.test(c.curCSS(b,\"position\")))b.style.position=\"relative\";var d=c(b), g=d.offset(),e=parseInt(c.curCSS(b,\"top\",true),10)||0,h=parseInt(c.curCSS(b,\"left\",true),10)||0;g={top:a.top-g.top+e,left:a.left-g.left+h};\"using\"in a?a.using.call(b,g):d.css(g)};c.fn.offset=function(b){var a=this[0];if(!a||!a.ownerDocument)return null;if(b)return this.each(function(){c.offset.setOffset(this,b)});return u.call(this)}}})(jQuery); ;/* * jQuery UI Draggable 1.8.10 * * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about) * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * http://docs.jquery.com/UI/Draggables * * Depends: * jquery.ui.core.js * jquery.ui.mouse.js * jquery.ui.widget.js */ (function(d){d.widget(\"ui.draggable\",d.ui.mouse,{widgetEventPrefix:\"drag\",options:{addClasses:true,appendTo:\"parent\",axis:false,connectToSortable:false,containment:false,cursor:\"auto\",cursorAt:false,grid:false,handle:false,helper:\"original\",iframeFix:false,opacity:false,refreshPositions:false,revert:false,revertDuration:500,scope:\"default\",scroll:true,scrollSensitivity:20,scrollSpeed:20,snap:false,snapMode:\"both\",snapTolerance:20,stack:false,zIndex:false},_create:function(){if(this.options.helper== \"original\"&&!/^(?:r|a|f)/.test(this.element.css(\"position\")))this.element[0].style.position=\"relative\";this.options.addClasses&&this.element.addClass(\"ui-draggable\");this.options.disabled&&this.element.addClass(\"ui-draggable-disabled\");this._mouseInit()},destroy:function(){if(this.element.data(\"draggable\")){this.element.removeData(\"draggable\").unbind(\".draggable\").removeClass(\"ui-draggable ui-draggable-dragging ui-draggable-disabled\");this._mouseDestroy();return this}},_mouseCapture:function(a){var b= this.options;if(this.helper||b.disabled||d(a.target).is(\".ui-resizable-handle\"))return false;this.handle=this._getHandle(a);if(!this.handle)return false;return true},_mouseStart:function(a){var b=this.options;this.helper=this._createHelper(a);this._cacheHelperProportions();if(d.ui.ddmanager)d.ui.ddmanager.current=this;this._cacheMargins();this.cssPosition=this.helper.css(\"position\");this.scrollParent=this.helper.scrollParent();this.offset=this.positionAbs=this.element.offset();this.offset={top:this.offset.top- this.margins.top,left:this.offset.left-this.margins.left};d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});this.originalPosition=this.position=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);b.containment&&this._setContainment();if(this._trigger(\"start\",a)===false){this._clear();return false}this._cacheHelperProportions(); d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.helper.addClass(\"ui-draggable-dragging\");this._mouseDrag(a,true);return true},_mouseDrag:function(a,b){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo(\"absolute\");if(!b){b=this._uiHash();if(this._trigger(\"drag\",a,b)===false){this._mouseUp({});return false}this.position=b.position}if(!this.options.axis||this.options.axis!=\"y\")this.helper[0].style.left=this.position.left+\"px\";if(!this.options.axis|| this.options.axis!=\"x\")this.helper[0].style.top=this.position.top+\"px\";d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);return false},_mouseStop:function(a){var b=false;if(d.ui.ddmanager&&!this.options.dropBehaviour)b=d.ui.ddmanager.drop(this,a);if(this.dropped){b=this.dropped;this.dropped=false}if((!this.element[0]||!this.element[0].parentNode)&&this.options.helper==\"original\")return false;if(this.options.revert==\"invalid\"&&!b||this.options.revert==\"valid\"&&b||this.options.revert===true||d.isFunction(this.options.revert)&& this.options.revert.call(this.element,b)){var c=this;d(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){c._trigger(\"stop\",a)!==false&&c._clear()})}else this._trigger(\"stop\",a)!==false&&this._clear();return false},cancel:function(){this.helper.is(\".ui-draggable-dragging\")?this._mouseUp({}):this._clear();return this},_getHandle:function(a){var b=!this.options.handle||!d(this.options.handle,this.element).length?true:false;d(this.options.handle,this.element).find(\"*\").andSelf().each(function(){if(this== a.target)b=true});return b},_createHelper:function(a){var b=this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a])):b.helper==\"clone\"?this.element.clone():this.element;a.parents(\"body\").length||a.appendTo(b.appendTo==\"parent\"?this.element[0].parentNode:b.appendTo);a[0]!=this.element[0]&&!/(fixed|absolute)/.test(a.css(\"position\"))&&a.css(\"position\",\"absolute\");return a},_adjustOffsetFromHelper:function(a){if(typeof a==\"string\")a=a.split(\" \");if(d.isArray(a))a={left:+a[0],top:+a[1]|| 0};if(\"left\"in a)this.offset.click.left=a.left+this.margins.left;if(\"right\"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if(\"top\"in a)this.offset.click.top=a.top+this.margins.top;if(\"bottom\"in a)this.offset.click.top=this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition==\"absolute\"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0], this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()==\"html\"&&d.browser.msie)a={top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css(\"borderTopWidth\"),10)||0),left:a.left+(parseInt(this.offsetParent.css(\"borderLeftWidth\"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition==\"relative\"){var a=this.element.position();return{top:a.top- (parseInt(this.helper.css(\"top\"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css(\"left\"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css(\"marginLeft\"),10)||0,top:parseInt(this.element.css(\"marginTop\"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment== \"parent\")a.containment=this.helper[0].parentNode;if(a.containment==\"document\"||a.containment==\"window\")this.containment=[(a.containment==\"document\"?0:d(window).scrollLeft())-this.offset.relative.left-this.offset.parent.left,(a.containment==\"document\"?0:d(window).scrollTop())-this.offset.relative.top-this.offset.parent.top,(a.containment==\"document\"?0:d(window).scrollLeft())+d(a.containment==\"document\"?document:window).width()-this.helperProportions.width-this.margins.left,(a.containment==\"document\"? 0:d(window).scrollTop())+(d(a.containment==\"document\"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)&&a.containment.constructor!=Array){var b=d(a.containment)[0];if(b){a=d(a.containment).offset();var c=d(b).css(\"overflow\")!=\"hidden\";this.containment=[a.left+(parseInt(d(b).css(\"borderLeftWidth\"),10)||0)+(parseInt(d(b).css(\"paddingLeft\"),10)||0)-this.margins.left,a.top+(parseInt(d(b).css(\"borderTopWidth\"), 10)||0)+(parseInt(d(b).css(\"paddingTop\"),10)||0)-this.margins.top,a.left+(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css(\"borderLeftWidth\"),10)||0)-(parseInt(d(b).css(\"paddingRight\"),10)||0)-this.helperProportions.width-this.margins.left,a.top+(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css(\"borderTopWidth\"),10)||0)-(parseInt(d(b).css(\"paddingBottom\"),10)||0)-this.helperProportions.height-this.margins.top]}}else if(a.containment.constructor== Array)this.containment=a.containment},_convertPositionTo:function(a,b){if(!b)b=this.position;a=a==\"absolute\"?1:-1;var c=this.cssPosition==\"absolute\"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName);return{top:b.top+this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&d.browser.version"},{"title":"","date":"2023-02-27T14:44:57.221Z","updated":"2023-02-27T14:44:57.221Z","comments":true,"path":"imgs/axure/我的考试_files/messagecenter.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/messagecenter.js","excerpt":"","text":"if (typeof console == 'undefined') console = { log: function () { } }; // sniff chrome var CHROME_5_LOCAL = false; var CHROME = false; var SAFARI = false; var FIREFOX = false; var WEBKIT = false; var OS_MAC = false; var IOS = false; var ANDROID = false; var MOBILE_DEVICE = false; var IE = false; var IE_10_AND_BELOW = false; //ie 10 and lower var IE_11_AND_ABOVE = false; //ie 11 and above var BROWSER_VERSION = 5000; (function () { if(!window.$axure) window.$axure = function() {}; var useragent = window.navigator.userAgent; var edgeRegex = /Edge\\/([0-9]+)/g; var edgeMatch = edgeRegex.exec(useragent); $axure.browser = { isEdge: Boolean(edgeMatch) }; if(!$axure.browser.isEdge) { var chromeRegex = /Chrome\\/([0-9]+).([0-9]+)/g; var chromeMatch = chromeRegex.exec(useragent); CHROME = Boolean(chromeMatch); CHROME_5_LOCAL = chromeMatch && Number(chromeMatch[1]) >= 5 && location.href.indexOf('file://') >= 0; } var safariRegex = /Safari\\/([0-9]+)/g; var safariMatch = safariRegex.exec(useragent); SAFARI = Boolean(safariMatch) && !CHROME; //because chrome also inserts safari string into user agent var webkitRegex = /WebKit\\//g ; WEBKIT = Boolean(webkitRegex.exec(useragent)); FIREFOX = useragent.toLowerCase().indexOf('firefox') > -1; var macRegex = /Mac/g ; OS_MAC = Boolean(macRegex.exec(window.navigator.platform)); IOS = useragent.match(/iPhone/i) || useragent.match(/iPad/i) || useragent.match(/iPod/i); ANDROID = useragent.match(/Android/i); MOBILE_DEVICE = ANDROID || IOS || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Tablet PC/i) || navigator.userAgent.match(/Windows Phone/i); if($.browser) { if($.browser.msie) IE_10_AND_BELOW = true; else IE_11_AND_ABOVE = useragent.toLowerCase().indexOf('trident') > -1; BROWSER_VERSION = $.browser.version; } IE = IE_10_AND_BELOW || IE_11_AND_ABOVE; //Used by sitemap and variables.js getLinkUrl functions so that they know //whether to embed global variables in URL as query string or hash string //_shouldSendVars persists the value for sitemap instead of re-checking every time var _shouldSendVars; var _shouldSendVarsToServer = function(url) { if(typeof _shouldSendVars != 'undefined') { return _shouldSendVars; } if(SAFARI || (IE_10_AND_BELOW && BROWSER_VERSION < 10)) { var urlToCheck = typeof url != 'undefined' ? url : window.location.href; var serverRegex = /http:\\/\\/127\\.0\\.0\\.1:[0-9]{5}/g; var serverMatch = serverRegex.exec(urlToCheck); var previewRegex = /[0-9]{2}\\.[0-9]{2}\\.[0-9]{2}/g; var previewMatch = previewRegex.exec(urlToCheck); if(Boolean(serverMatch) && Boolean(previewMatch)) { _shouldSendVars = true; return _shouldSendVars; } } _shouldSendVars = false; return _shouldSendVars; }; $axure.shouldSendVarsToServer = _shouldSendVarsToServer; })(); (function() { var _topMessageCenter; var _messageCenter = {}; var _listeners = []; var _stateListeners = []; var _state = {}; var _eventObject = null; var _queuedMessages = []; var _initialized = false; // this is for the non Chrome 5 local scenarios. The \"top\" message center will dispatch to all the bottom ones var _childrenMessageCenters = []; // create $axure if it hasn't been created if (!window.$axure) window.$axure = function() {}; $axure.messageCenter = _messageCenter; // isolate scope, and initialize _topMessageCenter. (function() { if (!CHROME_5_LOCAL) { var topAxureWindow = window; try { while(topAxureWindow.parent && topAxureWindow.parent !== topAxureWindow && topAxureWindow.parent.$axure) topAxureWindow = topAxureWindow.parent; } catch(e) {} _topMessageCenter = topAxureWindow.$axure.messageCenter; } })(); $(window.document).ready(function() { if (CHROME_5_LOCAL) { $('body').append(\"\" + \"\"); _eventObject = window.document.createEvent('Event'); _eventObject.initEvent('axureMessageSenderEvent', true, true); $('#axureEventReceiverDiv').bind('axureMessageReceiverEvent', function () { var request = JSON.parse($(this).text()); _handleRequest(request); }); } else { if (_topMessageCenter != _messageCenter) { _topMessageCenter.addChildMessageCenter(_messageCenter); console.log('adding from ' + window.location.toString()); } } }); var _handleRequest = function (request) { // route the request to all the listeners for(var i = 0; i < _listeners.length; i++) _listeners[i](request.message, request.data); // now handle the queued messages if we're initializing if (request.message == 'initialize') { _initialized = true; // send all the queued messages and return for (var i = 0; i < _queuedMessages.length; i++) { var qRequest = _queuedMessages[i]; _messageCenter.postMessage(qRequest.message, qRequest.data); } _queuedMessages = []; } // and then handle the set state messages, if necessary if (request.message == 'setState') { _state[request.data.key] = request.data.value; for (var i = 0; i < _stateListeners.length; i++) { var keyListener = _stateListeners[i]; // if thep passed a null or empty value, always post the message if (!keyListener.key || keyListener.key == request.data.key) { keyListener.listener(request.data.key, request.data.value); } } } }; // ----------------------------------------------------------------------------------------- // This method allows for dispatching messages in the non-chromelocal scenario. // Each child calls this on _topMessageCenter // ----------------------------------------------------------------------------------------- _messageCenter.addChildMessageCenter = function(messageCenter) { _childrenMessageCenters[_childrenMessageCenters.length] = messageCenter; }; // ----------------------------------------------------------------------------------------- // This method allows for dispatching messages in the non-chromelocal scenario. // Each child calls this on _topMessageCenter // ----------------------------------------------------------------------------------------- _messageCenter.dispatchMessage = function(message, data) { _handleRequest({ message: message, data: data }); }; // ----------------------------------------------------------------------------------------- // ----------------------------------------------------------------------------------------- _messageCenter.dispatchMessageRecursively = function(message, data) { console.log(\"dispatched to \" + window.location.toString()); // dispatch to the top center first _messageCenter.dispatchMessage(message, data); $('iframe').each(function(index, frame) { //try,catch to handle permissions error in FF when loading pages from another domain try { if (frame.contentWindow.$axure && frame.contentWindow.$axure.messageCenter) { frame.contentWindow.$axure.messageCenter.dispatchMessageRecursively(message, data); } }catch(e) {} }); }; var _combineEventMessages = false; var _compositeEventMessageData = []; _messageCenter.startCombineEventMessages = function() { _combineEventMessages = true; } _messageCenter.endCombineEventMessages = function () { _messageCenter.sendCompositeEventMessage(); _combineEventMessages = false; } _messageCenter.sendCompositeEventMessage = function () { _messageCenter.postMessage('axCompositeEventMessage', _compositeEventMessageData); _compositeEventMessageData = []; } _messageCenter.postMessage = function (message, data) { if(_combineEventMessages) { if(message == 'axEvent' || message == 'axCase' || message == 'axAction' || message == 'axEventComplete') { _compositeEventMessageData.push({ 'message': message, 'data': data }); if(_compositeEventMessageData.length >= 10) _messageCenter.sendCompositeEventMessage(); return; } } if(!CHROME_5_LOCAL) { _topMessageCenter.dispatchMessageRecursively(message, data); } else { var request = { message: message, data: data }; if(_initialized) { var senderDiv = window.document.getElementById('axureEventSenderDiv'); var messageText = JSON.stringify(request); // console.log('sending event: ' + messageText); senderDiv.innerText = messageText; senderDiv.dispatchEvent(_eventObject); // console.log('event sent'); } else { _queuedMessages[_queuedMessages.length] = request; } } }; _messageCenter.setState = function(key, value) { var data = { key: key, value: value }; _messageCenter.postMessage('setState', data); }; _messageCenter.getState = function(key) { return _state[key]; }; _messageCenter.addMessageListener = function(listener) { _listeners[_listeners.length] = listener; }; _messageCenter.addStateListener = function(key, listener) { _stateListeners[_stateListeners.length] = { key: key, listener: listener }; }; })();"},{"title":"","date":"2023-02-27T14:44:57.221Z","updated":"2023-02-27T14:44:57.221Z","comments":true,"path":"imgs/axure/我的考试_files/page_notes.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/page_notes.css","excerpt":"","text":"#pageNotesHost { font-size: 12px; color:#4a4a4a; height: 100%; } #pageNotesHostBtn a { background: url('images/notes_on.png'); background: url('images/notes_on.svg'),linear-gradient(transparent, transparent); } .hashover #pageNotesHostBtn a:hover { background: url('images/notes_hover.png'); background: url('images/notes_hover.svg'),linear-gradient(transparent, transparent); } #pageNotesHostBtn a.selected, #pageNotesHostBtn a.selected:hover { background: url('images/notes_off.png'); background: url('images/notes_off.svg'),linear-gradient(transparent, transparent); } #footnotesButton { background: url('images/footnotes.png') no-repeat center center; background: url('images/footnotes.svg') no-repeat center center,linear-gradient(transparent, transparent); } #footnotesButton:hover { background: url('images/footnotes_hover.png') no-repeat center center; background: url('images/footnotes_hover.svg') no-repeat center center,linear-gradient(transparent, transparent); } #footnotesButton.sitemapToolbarButtonSelected, #footnotesButton.sitemapToolbarButtonSelected:hover { background: url('images/footnotes_on.png') no-repeat center center; background: url('images/footnotes_on.svg') no-repeat center center,linear-gradient(transparent, transparent); } .nextPageButton { background: url('images/forward.png') no-repeat center center; background: url('images/forward.svg') no-repeat center center,linear-gradient(transparent, transparent); } .nextPageButton:hover { background: url('images/forward_hover.png') no-repeat center center; background: url('images/forward_hover.svg') no-repeat center center,linear-gradient(transparent, transparent); } .prevPageButton { background: url('images/back.png') no-repeat center center; background: url('images/back.svg') no-repeat center center,linear-gradient(transparent, transparent); } .prevPageButton:hover { background: url('images/back_hover.png') no-repeat center center; background: url('images/back_hover.svg') no-repeat center center,linear-gradient(transparent, transparent); } #pageNotesScrollContainer { overflow: auto; width: 100%; /*height: 100%;*/ -webkit-overflow-scrolling: touch; } #pageNotesContainer { /*padding: 10px 10px 10px 12px;*/ } #pageNotesContent { overflow: visible; } .pageNoteContainer { padding: 10px; } .pageNoteName { font-family: 'Trebuchet MS'; font-size: 14px; font-weight: bold; margin-bottom: 5px; /*text-decoration: underline;*/ white-space: nowrap; } .pageNote { line-height: 21px; /*margin-bottom: 20px;*/ } .widgetNoteContainer { padding: 10px; border-bottom: 1px solid transparent; border-top: 1px solid transparent; cursor: pointer; } .widgetNoteContainerSelected { background-color: white; border-bottom: 1px solid #c2c2c2; border-top: 1px solid #c2c2c2; } /*.widgetNoteContainer:hover { background-color: white; //border-bottom: 1px solid #c2c2c2; //border-top: 1px solid #c2c2c2; }*/ .widgetNoteFootnote { display: inline-block; /*vertical-align: top; margin: 2px 5px 10px 0px; padding: 1px 6px; font-size: 10px; color: #ffffff; background-color: #0a6cd6;*/ width: 13px; height: 12px; padding-top: 1px; text-align: center; background-color: #138CDD; /*-moz-box-shadow: 1px 1px 3px #aaa; -webkit-box-shadow: 1px 1px 3px #aaa; box-shadow: 1px 1px 3px #aaa;*/ font-size: 0px; margin-right: 8px; } div.annnoteline { display: inline-block; width: 9px; height: 1px; border-bottom: 1px solid white; margin-top: 1px; } .widgetNoteLabel { display: inline-block; vertical-align: top; font-family: 'Trebuchet MS'; font-size: 14px; font-weight: bold; margin-bottom: 5px; } .noteLink { text-decoration: inherit; color: inherit; } .noteLink:hover { background-color: white; }"},{"title":"","date":"2023-02-27T14:44:57.225Z","updated":"2023-02-27T14:44:57.225Z","comments":true,"path":"imgs/axure/我的考试_files/reset.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/reset.css","excerpt":"","text":"html,body,div,span, applet,object,iframe, h1,h2,h3,h4,h5,h6,p,blockquote,pre, a,abbr,acronym,address,big,cite,code, del,dfn,em,font,img,ins,kbd,q,s,samp, small,strike,strong,sub,sup,tt,var, dd,dl,dt,li,ol,ul, fieldset,form,label,legend, table,caption,tbody,tfoot,thead,tr,th,td { margin: 0; padding: 0; border: 0; } table { border-collapse: collapse; border-spacing: 0; } ol,ul { list-style: none; } q:before,q:after, blockquote:before,blockquote:after { content: \"\"; }"},{"title":"","date":"2023-02-27T14:44:57.225Z","updated":"2023-02-27T14:44:57.225Z","comments":true,"path":"imgs/axure/我的考试_files/saved_resource.html","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/saved_resource.html","excerpt":"","text":"我的考试 $axure.utils.getTransparentGifPath = function() { return 'resources/images/transparent.gif'; }; $axure.utils.getOtherPath = function() { return 'resources/Other.html'; }; $axure.utils.getReloadPath = function() { return 'resources/reload.html'; }; 首页 我的 昵称 手机 我的考试 托福 雅思 GRE SAT 考试科目： 考试时间："},{"title":"","date":"2023-02-27T14:44:57.225Z","updated":"2023-02-27T14:44:57.225Z","comments":true,"path":"imgs/axure/我的考试_files/sitemap.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/sitemap.css","excerpt":"","text":"#sitemapHost { font-size: 12px; color:#4a4a4a; height: 100%; } #sitemapHostBtn a { background: url('images/sitemap_on.png'); background: url('images/sitemap_on.svg'),linear-gradient(transparent, transparent); } .hashover #sitemapHostBtn a:hover { background: url('images/sitemap_hover.png'); background: url('images/sitemap_hover.svg'),linear-gradient(transparent, transparent); } #sitemapHostBtn a.selected, #sitemapHostBtn a.selected:hover { background: url('images/sitemap_off.png'); background: url('images/sitemap_off.svg'),linear-gradient(transparent, transparent); } #sitemapHost .pageButtonHeader { top: -27px; } #sitemapTreeContainer { overflow: auto; width: 100%; height: 100%; -webkit-overflow-scrolling: touch; } .sitemapTree { margin: 0px 0px 10px 0px; overflow:visible; } .sitemapTree ul { list-style-type: none; margin: 0px 0px 0px 0px; padding-left: 0px; } .sitemapPlusMinusLink { } .sitemapMinus { vertical-align:middle; background: url('images/minus.gif'); background-repeat: no-repeat; margin-right: 3px; margin-bottom: 1px; height:9px; width:9px; display:inline-block; } .sitemapPlus { vertical-align:middle; background: url('images/plus.gif'); background-repeat: no-repeat; margin-right: 3px; margin-bottom: 1px; height:9px; width:9px; display:inline-block; } .sitemapPageLink { margin-left: 0px; } .sitemapPageIcon { margin: 0px 0px -3px 4px; width: 16px; height: 16px; display: inline-block; background: url('images/page.png') no-repeat center center; background: url('images/page.svg') no-repeat center center, linear-gradient(transparent,transparent); } .sitemapFlowIcon { background: url('images/flow.png') no-repeat center center; background: url('images/flow.svg') no-repeat center center, linear-gradient(transparent,transparent); } .sitemapFolderIcon { background: url('images/folder_closed.png') no-repeat center center; background: url('images/folder_closed.svg') no-repeat center center, linear-gradient(transparent,transparent); } .sitemapFolderOpenIcon { background: url('images/folder_open.png') no-repeat center center; background: url('images/folder_open.svg') no-repeat center center, linear-gradient(transparent,transparent); } .sitemapPageName { margin-left: 7px; } .sitemapNode { /*margin:4px 0px 4px 0px;*/ white-space:nowrap; } .sitemapPageLinkContainer { /*display: inline-block;*/ margin-left: 0px; padding: 4px 0px 4px 0px; } /* .sitemapNode div { padding-top: 1px; padding-bottom: 3px; padding-left: 20px; height: 14px; } */ .sitemapExpandableNode { margin-left: 0px; } .sitemapHighlight { /*display: inline-block;*/ background-color : #C8E0F0; font-weight: bold; } .sitemapGreyedName { color: #AAA; } .pluginNameHeader { font-family: 'Trebuchet MS'; font-size: 12px; letter-spacing: 1px; /*font-weight: bold;*/ white-space: nowrap; margin-bottom: 5px; } .pageNameHeader { font-family: 'Trebuchet MS'; /*display: inline-block;*/ /*float: left;*/ font-size: 15px; font-weight: bold; /*height: 23px;*/ padding-right: 77px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .pageButtonHeader { float: right; position: relative; /*width: 72px;*/ height: 24px; top: -22px; margin-bottom: -24px; } .sitemapHeader { padding-top: 27px; border-bottom: 1px solid #d9d9d9; min-width: 110px; } .sitemapToolbar { margin: 0px 5px 14px 12px; } .sitemapToolbarButton { float: left; width: 22px; height: 22px; border: 1px solid transparent; } #linksButton { background: url('images/share.png') no-repeat center center; background: url('images/share.svg') no-repeat center center, linear-gradient(transparent,transparent); } #linksButton:hover { background: url('images/share_hover.png') no-repeat center center; background: url('images/share_hover.svg') no-repeat center center, linear-gradient(transparent,transparent); } #linksButton.sitemapToolbarButtonSelected, .hashover #linksButton.sitemapToolbarButtonSelected:hover { background: url('images/share_on.png') no-repeat center center; background: url('images/share_on.svg') no-repeat center center, linear-gradient(transparent,transparent); } #adaptiveButton { background: url('images/views.png') no-repeat center center; background: url('images/views.svg') no-repeat center center, linear-gradient(transparent,transparent); } #adaptiveButton:hover { background: url('images/views_hover.png') no-repeat center center; background: url('images/views_hover.svg') no-repeat center center, linear-gradient(transparent,transparent); } #adaptiveButton.sitemapToolbarButtonSelected, #adaptiveButton.sitemapToolbarButtonSelected:hover { background: url('images/views_on.png') no-repeat center center; background: url('images/views_on.svg') no-repeat center center, linear-gradient(transparent,transparent); } #highlightInteractiveButton { background: url('images/hotspots.png') no-repeat center center; background: url('images/hotspots.svg') no-repeat center center, linear-gradient(transparent,transparent); margin-top: 1px; } #highlightInteractiveButton:hover { background: url('images/hotspots_hover.png') no-repeat center center; background: url('images/hotspots_hover.svg') no-repeat center center, linear-gradient(transparent,transparent); } #highlightInteractiveButton.sitemapToolbarButtonSelected, #highlightInteractiveButton.sitemapToolbarButtonSelected:hover { background: url('images/hotspots_on.png') no-repeat center center; background: url('images/hotspots_on.svg') no-repeat center center, linear-gradient(transparent,transparent); } /*#variablesButton { background: url('images/229_variables_16.png') no-repeat center center; }*/ #searchButton { background: url('images/232_search_16.png') no-repeat center center; } .sitemapLinkContainer { margin-top: 8px; padding-right: 5px; /*font-size: 12px;*/ } .sitemapLinkField { width: 100%; font-size: 12px; margin-top: 3px; padding: 5px; } .sitemapRadioSelected { font-weight: bold; } .sitemapOptionContainer { margin-top: 8px; padding-right: 5px; /*font-size: 12px;*/ } #sitemapOptionsDiv { margin-top: 10px; /*margin-left: 16px;*/ } #viewSelectDiv { padding: 2px 0px 0px 0px; /*margin-left: 5px;*/ } #viewSelect { width: 70%; } .sitemapUrlOption { padding-bottom: 8px; } .optionLabel { font-size: 12px; } .sitemapPopupContainer { display: none; position: absolute; background-color: #F4F4F4; border: 1px solid #B9B9B9; padding: 5px 5px 5px 5px; margin: 5px 0px 0px 5px; z-index: 1; } #sitemapLinksContainer { border-top: 1px solid #d9d9d9; padding: 10px; margin-left: 0px; /*line-height: 18px;*/ } #adaptiveViewsContainer { border-top: 1px solid #d9d9d9; padding: 10px; margin-left: 0px; line-height: 18px; } .adaptiveViewOption { padding: 2px; } .adaptiveViewOption:hover { background-color: rgb(204,235,248); cursor: pointer; } .currentAdaptiveView { font-weight: bold; } .adaptiveCheckboxDiv { height: 15px; width: 15px; float: left; } .checkedAdaptive { background: url('images/adaptivecheck.png') no-repeat center center; } /*#variablesContainer { max-height: 350px; overflow: auto; }*/ /*#variablesClearLink { color: #069; left: 5px; }*/ #searchDiv { padding: 8px 12px 11px 12px; } #searchBox { width: 100%; border: none; border-top: 1px solid #d9d9d9; /*border-bottom: 1px solid #d9d9d9;*/ padding: 5px; font-size: 12px; } .searchBoxHint { color: #8f949a; /*font-style: italic;*/ } #sitemapLinksPageName { font-weight: bold; } #sitemapOptionsHeader { font-weight: bold; }"},{"title":"","date":"2023-02-27T14:44:57.225Z","updated":"2023-02-27T14:44:57.225Z","comments":true,"path":"imgs/axure/我的考试_files/startPost.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/startPost.js","excerpt":"","text":"// 8.0.0.3382. Generated 1/14/2019 10:26:32 PM UTC //***** sitemap.js *****// var currentNodeUrl = ''; var allNodeUrls = []; function openNextPage() { var index = allNodeUrls.indexOf(currentNodeUrl) + 1; if(index >= allNodeUrls.length) return; var nextNodeUrl = allNodeUrls[index]; $('.sitemapPageLink[nodeUrl=\"' + nextNodeUrl + '\"]').click(); } function openPreviousPage() { var index = allNodeUrls.indexOf(currentNodeUrl) - 1; if(index < 0) return; var nextNodeUrl = allNodeUrls[index]; $('.sitemapPageLink[nodeUrl=\"' + nextNodeUrl + '\"]').click(); } // use this to isolate the scope (function() { var SHOW_HIDE_ANIMATION_DURATION = 0; var HIGHLIGHT_INTERACTIVE_VAR_NAME = 'hi'; var currentPageLoc = ''; var currentPlayerLoc = ''; var currentPageHashString = ''; $(window.document).ready(function() { $axure.player.createPluginHost({ id: 'sitemapHost', context: 'interface', title: 'PAGES', gid: 1 }); generateSitemap(); $('.sitemapPlusMinusLink').toggle(collapse_click, expand_click); $('.sitemapPageLink').click(node_click); $('#sitemapLinksContainer').hide(); $('#linksButton').click(links_click); $('#adaptiveButton').click(adaptive_click); $('#adaptiveViewsContainer').hide(); $('#highlightInteractiveButton').click(highlight_interactive); $('#searchButton').click(search_click); $('#searchBox').keyup(search_input_keyup); $('.sitemapLinkField').click(function() { this.select(); }); $('input[value=\"withoutmap\"]').click(withoutSitemapRadio_click); $('input[value=\"withmap\"]').click(withSitemapRadio_click); $('#minimizeBox, #collapseBox, #footnotesBox, #highlightBox').change(sitemapUrlOptions_change); $('#viewSelect').change(sitemapUrlViewSelect_change); $(document).on('ContainerHeightChange', function() { updateContainerHeight(); }); // bind to the page load $axure.page.bind('load.sitemap', function() { currentPageLoc = $axure.page.location.split(\"#\")[0]; var decodedPageLoc = decodeURI(currentPageLoc); currentNodeUrl = decodedPageLoc.substr(decodedPageLoc.lastIndexOf('/') ? decodedPageLoc.lastIndexOf('/') + 1 : 0); currentPlayerLoc = $(location).attr('href').split(\"#\")[0].split(\"?\")[0]; currentPageHashString = '#p=' + currentNodeUrl.substr(0, currentNodeUrl.lastIndexOf('.')); setVarInCurrentUrlHash('p', currentNodeUrl.substring(0, currentNodeUrl.lastIndexOf('.html'))); $('.sitemapPageLink').parent().parent().removeClass('sitemapHighlight'); $('.sitemapPageLink[nodeUrl=\"' + currentNodeUrl + '\"]').parent().parent().addClass('sitemapHighlight'); var pageName = $axure.page.pageName; $('.pageNameHeader').html(pageName); $('#sitemapLinksPageName').html($('.sitemapHighlight > .sitemapPageLinkContainer > .sitemapPageLink > .sitemapPageName').html()); //Click the \"Without sitemap\" radio button so that it's selected by default $('input[value=\"withoutmap\"]').click(); //If highlight var is present and set to 1 or else if //sitemap highlight button is selected then highlight interactive elements var hiVal = getHashStringVar(HIGHLIGHT_INTERACTIVE_VAR_NAME); if(hiVal.length > 0 && hiVal == 1) { $('#highlightInteractiveButton').addClass('sitemapToolbarButtonSelected'); $axure.messageCenter.postMessage('highlightInteractive', true); } else if($('#highlightInteractiveButton').is('.sitemapToolbarButtonSelected')) { $axure.messageCenter.postMessage('highlightInteractive', true); } //Set the current view if it is defined in the hash string //If the view is invalid, set it to 'auto' in the string //ELSE set the view based on the currently selected view in the toolbar menu var viewStr = getHashStringVar(ADAPTIVE_VIEW_VAR_NAME); if(viewStr.length > 0) { var $view = $('.adaptiveViewOption[val=\"' + viewStr + '\"]'); if($view.length > 0) $view.click(); else $('.adaptiveViewOption[val=\"auto\"]').click(); } else if($('.checkedAdaptive').length > 0) { var $viewOption = $('.checkedAdaptive').parents('.adaptiveViewOption'); if($viewOption.attr('val') != 'auto') $viewOption.click(); } $axure.messageCenter.postMessage('finishInit'); return false; }); var $adaptiveViewsContainer = $('#adaptiveViewsContainer'); var $viewSelect = $('#viewSelect'); //Fill out adaptive view container with prototype's defined adaptive views, as well as the default, and Auto $adaptiveViewsContainer.append('Auto'); $viewSelect.append('Auto'); if(typeof $axure.document.defaultAdaptiveView.name != 'undefined') { //If the name is a blank string, make the view name the width if non-zero, else 'any' var defaultViewName = $axure.document.defaultAdaptiveView.name; $adaptiveViewsContainer.append('' + defaultViewName + ''); $viewSelect.append('' + defaultViewName + ''); } var enabledViewIds = $axure.document.configuration.enabledViewIds; for(var viewIndex = 0; viewIndex < $axure.document.adaptiveViews.length; viewIndex++) { var currView = $axure.document.adaptiveViews[viewIndex]; if(enabledViewIds.indexOf(currView.id) < 0) continue; var widthString = currView.size.width == 0 ? 'any' : currView.size.width; var heightString = currView.size.height == 0 ? 'any' : currView.size.height; var conditionString = ''; if(currView.condition == '>' || currView.condition == '>=') { conditionString = ' and above'; } else if(currView.condition == '"},{"title":"","date":"2023-02-27T14:44:57.226Z","updated":"2023-02-27T14:44:57.226Z","comments":true,"path":"imgs/axure/我的考试_files/styles(1).css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/styles(1).css","excerpt":"","text":"body { margin:0px; background-image:none; position:static; left:auto; width:375px; margin-left:0; margin-right:0; text-align:left; } #base { position:absolute; z-index:0; } #u0_div { border-width:0px; position:absolute; left:0px; top:0px; width:375px; height:667px; background:inherit; background-color:rgba(255, 255, 255, 1); box-sizing:border-box; border-width:1px; border-style:solid; border-color:rgba(121, 121, 121, 1); border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; } #u0 { border-width:0px; position:absolute; left:0px; top:0px; width:375px; height:667px; } #u0_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u0_ann { border-width:0px; position:absolute; left:368px; top:-4px; width:1px; height:1px; } #u1_div { border-width:0px; position:absolute; left:0px; top:0px; width:375px; height:60px; background:inherit; background-color:rgba(255, 255, 255, 1); box-sizing:border-box; border-width:1px; border-style:solid; border-color:rgba(121, 121, 121, 1); border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; } #u1 { border-width:0px; position:absolute; left:0px; top:606px; width:375px; height:60px; } #u1_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u2_img { border-width:0px; position:absolute; left:0px; top:0px; width:2px; height:62px; } #u2 { border-width:0px; position:absolute; left:186px; top:606px; width:1px; height:61px; } #u2_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u3_img { border-width:0px; position:absolute; left:0px; top:0px; width:20px; height:20px; } #u3 { border-width:0px; position:absolute; left:63px; top:612px; width:20px; height:20px; } #u3_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u4_div { border-width:0px; position:absolute; left:0px; top:0px; width:29px; height:20px; background:inherit; background-color:rgba(255, 255, 255, 0); border:none; border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; text-align:center; } #u4 { border-width:0px; position:absolute; left:60px; top:638px; width:29px; height:20px; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; text-align:center; } #u4_text { border-width:0px; position:absolute; left:0px; top:0px; width:29px; white-space:nowrap; } #u5_div { border-width:0px; position:absolute; left:0px; top:0px; width:29px; height:20px; background:inherit; background-color:rgba(255, 255, 255, 0); border:none; border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; text-align:center; } #u5 { border-width:0px; position:absolute; left:264px; top:638px; width:29px; height:20px; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; text-align:center; } #u5_text { border-width:0px; position:absolute; left:0px; top:0px; width:29px; white-space:nowrap; } #u6_img { border-width:0px; position:absolute; left:0px; top:0px; width:20px; height:20px; } #u6 { border-width:0px; position:absolute; left:266px; top:612px; width:20px; height:20px; } #u6_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u7_div { border-width:0px; position:absolute; left:0px; top:0px; width:375px; height:117px; background:inherit; background-color:rgba(255, 255, 255, 1); box-sizing:border-box; border-width:1px; border-style:solid; border-color:rgba(121, 121, 121, 1); border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; } #u7 { border-width:0px; position:absolute; left:0px; top:33px; width:375px; height:117px; } #u7_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u8_img { border-width:0px; position:absolute; left:0px; top:0px; width:60px; height:60px; } #u8 { border-width:0px; position:absolute; left:11px; top:54px; width:60px; height:60px; } #u8_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u9_div { border-width:0px; position:absolute; left:0px; top:0px; width:29px; height:20px; background:inherit; background-color:rgba(255, 255, 255, 0); border:none; border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; } #u9 { border-width:0px; position:absolute; left:101px; top:59px; width:29px; height:20px; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; } #u9_text { border-width:0px; position:absolute; left:0px; top:0px; width:29px; white-space:nowrap; } #u10_div { border-width:0px; position:absolute; left:0px; top:0px; width:29px; height:20px; background:inherit; background-color:rgba(255, 255, 255, 0); border:none; border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; } #u10 { border-width:0px; position:absolute; left:102px; top:89px; width:29px; height:20px; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; } #u10_text { border-width:0px; position:absolute; left:0px; top:0px; width:29px; white-space:nowrap; } #u11_div { border-width:0px; position:absolute; left:0px; top:0px; width:365px; height:436px; background:inherit; background-color:rgba(255, 255, 255, 1); box-sizing:border-box; border-width:1px; border-style:solid; border-color:rgba(121, 121, 121, 1); border-radius:10px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; } #u11 { border-width:0px; position:absolute; left:5px; top:160px; width:365px; height:436px; } #u11_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u12 { border-width:0px; position:absolute; left:0px; top:0px; width:0px; height:0px; } #u13_div { border-width:0px; position:absolute; left:0px; top:0px; width:352px; height:60px; background:inherit; background-color:rgba(255, 255, 255, 1); box-sizing:border-box; border-width:1px; border-style:solid; border-color:rgba(121, 121, 121, 1); border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; } #u13 { border-width:0px; position:absolute; left:11px; top:215px; width:352px; height:60px; } #u13_div.mouseDown { border-width:0px; position:absolute; left:0px; top:0px; width:352px; height:60px; background:inherit; background-color:rgba(255, 255, 255, 1); box-sizing:border-box; border-width:1px; border-style:solid; border-color:rgba(121, 121, 121, 1); border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; } #u13.mouseDown { } #u13_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u13_ann { border-width:0px; position:absolute; left:356px; top:211px; width:1px; height:1px; } #u14_div { border-width:0px; position:absolute; left:0px; top:0px; width:81px; height:28px; background:inherit; background-color:rgba(255, 255, 255, 0); border:none; border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; font-size:20px; } #u14 { border-width:0px; position:absolute; left:32px; top:232px; width:81px; height:28px; font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; font-size:20px; } #u14_text { border-width:0px; position:absolute; left:0px; top:0px; width:81px; white-space:nowrap; } #u15_img { border-width:0px; position:absolute; left:0px; top:0px; width:20px; height:20px; } #u15 { border-width:0px; position:absolute; left:296px; top:234px; width:20px; height:20px; } #u15_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u16 { border-width:0px; position:absolute; left:0px; top:0px; width:0px; height:0px; } #u17_div { border-width:0px; position:absolute; left:0px; top:0px; width:352px; height:271px; background:inherit; background-color:rgba(255, 255, 255, 1); box-sizing:border-box; border-width:1px; border-style:solid; border-color:rgba(121, 121, 121, 1); border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; } #u17 { border-width:0px; position:absolute; left:11px; top:177px; width:352px; height:271px; } #u17_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; } #u18 { border-width:0px; position:absolute; left:138px; top:242px; width:204px; height:50px; } #u18_input { position:absolute; left:0px; top:0px; width:204px; height:50px; font-family:'ArialMT', 'Arial'; font-weight:400; font-style:normal; font-size:13px; text-decoration:none; color:#000000; } #u18_input:disabled { color:grayText; } #u19_div { border-width:0px; position:absolute; left:0px; top:0px; width:96px; height:25px; background:inherit; background-color:rgba(255, 255, 255, 0); border:none; border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; font-size:18px; } #u19 { border-width:0px; position:absolute; left:32px; top:253px; width:96px; height:25px; font-size:18px; } #u19_text { border-width:0px; position:absolute; left:0px; top:0px; width:96px; white-space:nowrap; } #u20_div { border-width:0px; position:absolute; left:0px; top:0px; width:96px; height:25px; background:inherit; background-color:rgba(255, 255, 255, 0); border:none; border-radius:0px; -moz-box-shadow:none; -webkit-box-shadow:none; box-shadow:none; font-size:18px; } #u20 { border-width:0px; position:absolute; left:32px; top:321px; width:96px; height:25px; font-size:18px; } #u20_text { border-width:0px; position:absolute; left:0px; top:0px; width:96px; white-space:nowrap; } #u21 { border-width:0px; position:absolute; left:138px; top:321px; width:204px; height:50px; } #u21_input { position:absolute; left:0px; top:0px; width:204px; height:50px; font-family:'ArialMT', 'Arial'; font-weight:400; font-style:normal; font-size:13px; text-decoration:none; color:#000000; text-align:left; } #u22_img { border-width:0px; position:absolute; left:0px; top:0px; width:30px; height:30px; } #u22 { border-width:0px; position:absolute; left:319px; top:184px; width:30px; height:30px; } #u22_text { border-width:0px; position:absolute; left:0px; top:0px; width:0px; visibility:hidden; word-wrap:break-word; }"},{"title":"","date":"2023-02-27T14:44:57.226Z","updated":"2023-02-27T14:44:57.226Z","comments":true,"path":"imgs/axure/我的考试_files/styles.css","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/styles.css","excerpt":"","text":".ax_default { font-family:'ArialMT', 'Arial'; font-weight:400; font-style:normal; font-size:13px; color:#333333; text-align:center; line-height:normal; } .box_1 { } .box_2 { } ._形状 { } .image { } .button { } .primary_button { color:#FFFFFF; } ._一级标题 { font-family:'ArialMT', 'Arial'; font-weight:bold; font-style:normal; font-size:32px; text-align:left; } ._二级标题 { font-family:'ArialMT', 'Arial'; font-weight:bold; font-style:normal; font-size:24px; text-align:left; } ._三级标题 { font-family:'ArialMT', 'Arial'; font-weight:bold; font-style:normal; font-size:18px; text-align:left; } ._四级标题 { font-family:'ArialMT', 'Arial'; font-weight:bold; font-style:normal; font-size:14px; text-align:left; } ._五级标题 { font-family:'ArialMT', 'Arial'; font-weight:bold; font-style:normal; text-align:left; } ._六级标题 { font-family:'ArialMT', 'Arial'; font-weight:bold; font-style:normal; font-size:10px; text-align:left; } .label { font-size:14px; text-align:left; } ._文本段落 { text-align:left; } .line { } .text_field { color:#000000; text-align:left; } .droplist { color:#000000; text-align:left; } .html_button { font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; text-align:center; } ._流程形状 { } ._连接线 { } .snapshot { } .icon { } .shape { } ._34号字_单行列表内，左方主标题文字字） { font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; font-size:17px; text-align:left; } ._28号字_页面备注信息及列表的表头说明文字__） { font-family:'PingFangSC-Regular', 'PingFang SC'; font-weight:400; font-style:normal; font-size:14px; text-align:left; } .image1 { color:#000000; }"},{"title":"","date":"2023-02-27T14:44:57.226Z","updated":"2023-02-27T14:44:57.226Z","comments":true,"path":"imgs/axure/我的考试_files/startPre.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/startPre.js","excerpt":"","text":"// 8.0.0.3382. Generated 1/14/2019 10:26:32 PM UTC //***** splitter.js *****// /* * jQuery.splitter.js - two-pane splitter window plugin * * version 1.51 (2009/01/09) * * Dual licensed under the MIT and GPL licenses: * http://www.opensource.org/licenses/mit-license.php * http://www.gnu.org/licenses/gpl.html */ /** * The splitter() plugin implements a two-pane resizable splitter window. * The selected elements in the jQuery object are converted to a splitter; * each selected element should have two child elements, used for the panes * of the splitter. The plugin adds a third child element for the splitbar. * * For more details see: http://methvin.com/splitter/ * * * @example $('#MySplitter').splitter(); * @desc Create a vertical splitter with default settings * * @example $('#MySplitter').splitter({type: 'h', accessKey: 'M'}); * @desc Create a horizontal splitter resizable via Alt+Shift+M * * @name splitter * @type jQuery * @param Object options Options for the splitter (not required) * @cat Plugins/Splitter * @return jQuery * @author Dave Methvin (dave.methvin@gmail.com) */ ;(function($){ $.fn.splitter = function(args){ args = args || {}; return this.each(function() { var zombie; // left-behind splitbar for outline resizes function startSplitMouse(evt) { if ( opts.outline ) zombie = zombie || bar.clone(false).insertAfter(A); panes.css(\"-webkit-user-select\", \"none\"); // Safari selects A/B text on a move bar.addClass(opts.activeClass); $('').insertAfter(bar); A._posSplit = A[0][opts.pxSplit] - evt[opts.eventPos]; $(document) .bind(\"mousemove\", doSplitMouse) .bind(\"mouseup\", endSplitMouse); } function doSplitMouse(evt) { var newPos = A._posSplit+evt[opts.eventPos]; if ( opts.outline ) { newPos = Math.max(0, Math.min(newPos, splitter._DA - bar._DA)); bar.css(opts.origin, newPos); } else resplit(newPos); } function endSplitMouse(evt) { $('div.splitterMask').remove(); bar.removeClass(opts.activeClass); var newPos = A._posSplit+evt[opts.eventPos]; if ( opts.outline ) { zombie.remove(); zombie = null; resplit(newPos); } panes.css(\"-webkit-user-select\", \"text\"); // let Safari select text again $(document) .unbind(\"mousemove\", doSplitMouse) .unbind(\"mouseup\", endSplitMouse); } function resplit(newPos) { // Constrain new splitbar position to fit pane size limits newPos = Math.max(A._min, splitter._DA - B._max, Math.min(newPos, A._max, splitter._DA - bar._DA - B._min)); // Resize/position the two panes bar._DA = bar[0][opts.pxSplit]; // bar size may change during dock var posOffset = bar.is(':visible') ? bar._DA - 1 : 0; bar.css(opts.origin, newPos - posOffset).css(opts.fixed, splitter._DF); A.css(opts.origin, 0).css(opts.split, newPos).css(opts.fixed, splitter._DF); B.css(opts.origin, newPos + bar._DA - posOffset) .css(opts.split, splitter._DA-bar._DA-newPos).css(opts.fixed, splitter._DF); // IE fires resize for us; all others pay cash if ( !IE_10_AND_BELOW ) panes.trigger(\"resize\"); } function dimSum(jq, dims) { // Opera returns -1 for missing min/max width, turn into 0 var sum = 0; for ( var i=1; i < arguments.length; i++ ) sum += Math.max(parseInt(jq.css(arguments[i])) || 0, 0); return sum; } // Determine settings based on incoming opts, element classes, and defaults var vh = (args.splitHorizontal? 'h' : args.splitVertical? 'v' : args.type) || 'v'; var opts = $.extend({ activeClass: 'active', // class name for active splitter pxPerKey: 8, // splitter px moved per keypress tabIndex: 0, // tab order indicator accessKey: '' // accessKey for splitbar },{ v: { // Vertical splitters: keyLeft: 39, keyRight: 37, cursor: \"col-resize\", splitbarClass: \"vsplitbar\", outlineClass: \"voutline\", type: 'v', eventPos: \"pageX\", origin: \"left\", split: \"width\", pxSplit: \"offsetWidth\", side1: \"Left\", side2: \"Right\", fixed: \"height\", pxFixed: \"offsetHeight\", side3: \"Top\", side4: \"Bottom\" }, h: { // Horizontal splitters: keyTop: 40, keyBottom: 38, cursor: \"row-resize\", splitbarClass: \"hsplitbar\", outlineClass: \"houtline\", type: 'h', eventPos: \"pageY\", origin: \"top\", split: \"height\", pxSplit: \"offsetHeight\", side1: \"Top\", side2: \"Bottom\", fixed: \"width\", pxFixed: \"offsetWidth\", side3: \"Left\", side4: \"Right\" } }[vh], args); // Create jQuery object closures for splitter and both panes var splitter = $(this).css({position: \"relative\"}); var panes = $(\">*\", splitter[0]).css({ position: \"absolute\", // positioned inside splitter container \"z-index\": \"1\", // splitbar is positioned above \"-moz-outline-style\": \"none\" // don't show dotted outline }); var A = $(panes[0]); // left or top var B = $(panes[1]); // right or bottom // Focuser element, provides keyboard support; title is shown by Opera accessKeys var focuser = $('') .attr({accessKey: opts.accessKey, tabIndex: opts.tabIndex, title: opts.splitbarClass}) .bind($.browser.opera?\"click\":\"focus\", function(){ this.focus(); bar.addClass(opts.activeClass) }) .bind(\"keydown\", function(e){ var key = e.which || e.keyCode; var dir = key==opts[\"key\"+opts.side1]? 1 : key==opts[\"key\"+opts.side2]? -1 : 0; if ( dir ) resplit(A[0][opts.pxSplit]+dir*opts.pxPerKey, false); }) .bind(\"blur\", function(){ bar.removeClass(opts.activeClass) }); // Splitbar element, can be already in the doc or we create one var bar = $(panes[2] || '') .insertAfter(A).css(\"z-index\", \"100\").append(focuser) .attr({\"class\": opts.splitbarClass, unselectable: \"on\"}) .css({position: \"absolute\", \"user-select\": \"none\", \"-webkit-user-select\": \"none\", \"-khtml-user-select\": \"none\", \"-moz-user-select\": \"none\", \"top\": \"0px\"}) .bind(\"mousedown\", startSplitMouse); // Use our cursor unless the style specifies a non-default cursor if ( /^(auto|default|)$/.test(bar.css(\"cursor\")) ) bar.css(\"cursor\", opts.cursor); // Cache several dimensions for speed, rather than re-querying constantly bar._DA = bar[0][opts.pxSplit]; splitter._PBF = $.boxModel? dimSum(splitter, \"border\"+opts.side3+\"Width\", \"border\"+opts.side4+\"Width\") : 0; splitter._PBA = $.boxModel? dimSum(splitter, \"border\"+opts.side1+\"Width\", \"border\"+opts.side2+\"Width\") : 0; A._pane = opts.side1; B._pane = opts.side2; $.each([A,B], function(){ this._min = opts[\"min\"+this._pane] || dimSum(this, \"min-\"+opts.split); this._max = opts[\"max\"+this._pane] || dimSum(this, \"max-\"+opts.split) || 9999; this._init = opts[\"size\"+this._pane]===true ? parseInt($.curCSS(this[0],opts.split)) : opts[\"size\"+this._pane]; }); // Determine initial position, get from cookie if specified var initPos = A._init; if ( !isNaN(B._init) ) // recalc initial B size as an offset from the top or left side initPos = splitter[0][opts.pxSplit] - splitter._PBA - B._init - bar._DA; if ( opts.cookie ) { if ( !$.cookie ) alert('jQuery.splitter(): jQuery cookie plugin required'); var ckpos = parseInt($.cookie(opts.cookie)); if ( !isNaN(ckpos) ) initPos = ckpos; $(window).bind(\"unload\", function(){ var state = String(bar.css(opts.origin)); // current location of splitbar $.cookie(opts.cookie, state, {expires: opts.cookieExpires || 365, path: opts.cookiePath || document.location.pathname}); }); } if ( isNaN(initPos) ) // King Solomon's algorithm initPos = Math.round((splitter[0][opts.pxSplit] - splitter._PBA - bar._DA)/2); // Resize event propagation and splitter sizing if ( opts.anchorToWindow ) { // Account for margin or border on the splitter container and enforce min height splitter._hadjust = dimSum(splitter, \"borderTopWidth\", \"borderBottomWidth\", \"marginBottom\"); splitter._hmin = Math.max(dimSum(splitter, \"minHeight\"), 20); $(window).bind(\"resize\", function(){ var top = splitter.offset().top; var wh = $(window).height(); splitter.css(\"height\", Math.max(wh-top-splitter._hadjust, splitter._hmin)+\"px\"); if ( !IE_10_AND_BELOW ) splitter.trigger(\"resize\"); }).trigger(\"resize\"); } else if ( opts.resizeToWidth && !IE_10_AND_BELOW ) $(window).bind(\"resize\", function(){ splitter.trigger(\"resize\"); }); // Resize event handler; triggered immediately to set initial position splitter.bind(\"resize\", function(e, size){ // Custom events bubble in jQuery 1.3; don't Yo Dawg if ( e.target != this ) return; // Determine new width/height of splitter container splitter._DF = splitter[0][opts.pxFixed] - splitter._PBF; splitter._DA = splitter[0][opts.pxSplit] - splitter._PBA; // Bail if splitter isn't visible or content isn't there yet if ( splitter._DF >> 0; var from = trunc(Number(arguments[1]) || 0); if(from < 0) from += len; for(; from < len; from++) { if(from in this && this[from] === elt) return from; } return -1; }; } var trunc = function(num) { return num < 0 ? Math.ceil(num) : Math.floor(num); }; })(); //***** axplayer.js *****// if (!window.$axure) window.$axure = function () { }; if (typeof console == 'undefined') console = { log: function () { } }; if(window._axUtils) $axure.utils = _axUtils; $axure.loadDocument = function(document) { $axure.document = document; }; function setUpController() { //$axure.utils = _axUtils; var _page = {}; $axure.page = _page; $axure.utils.makeBindable(_page, ['load']); var _player = function() { }; $axure.player = _player; //----------------------------------------- //Global Var array, getLinkUrl function and setGlobalVar listener are //for use in setting global vars in page url string when clicking a //page in the sitemap //----------------------------------------- var _globalVars = {}; //----------------------------------------- //Used by getLinkUrl below to check if local server is running //in order to send back the global variables as a query string //in the page url //----------------------------------------- var _shouldSendVarsToServer = function () { //If exception occurs (due to page in content frame being from a different domain, etc) //then run the check without the url (which will end up checking against sitemap url) try { var mainFrame = document.getElementById(\"mainFrame\"); return $axure.shouldSendVarsToServer(mainFrame.contentWindow.location.href); } catch (e) { return $axure.shouldSendVarsToServer(); } }; var _getLinkUrl = function (baseUrl) { var toAdd = ''; for(var globalVarName in _globalVars) { var val = _globalVars[globalVarName]; if(val != null) { if(toAdd.length > 0) toAdd += '&'; toAdd += globalVarName + '=' + encodeURIComponent(val); } } return toAdd.length > 0 ? baseUrl + (_shouldSendVarsToServer() ? '?' : '#') + toAdd + \"&CSUM=1\" : baseUrl; }; $axure.getLinkUrlWithVars = _getLinkUrl; $axure.messageCenter.addMessageListener(function(message, data) { if (message == 'setGlobalVar'){ _globalVars[data.globalVarName] = data.globalVarValue; } }); $axure.messageCenter.addStateListener('page.data', function (key, value) { for (var subKey in value) { _page[subKey] = value[subKey]; } $axure.page.triggerEvent('load'); }); // --------------------------------------------- // Navigates the main frame (setting the currently visible page). If the link is relative, // this method should test if it is actually a axure rp page being loaded and properly set // up all the controller for the page if it is // --------------------------------------------- _page.navigate = function (url, includeVariables) { var mainFrame = document.getElementById(\"mainFrame\"); //var mainFrame = window.parent.mainFrame; // if this is a relative url... var urlToLoad; if (url.indexOf(':') < 0 || url[0] == '/') { var winHref = window.location.href; var page = winHref.substring(0, winHref.lastIndexOf('/') + 1) + url; urlToLoad = page; } else { urlToLoad = url; } if (!includeVariables) { mainFrame.contentWindow.location.href = urlToLoad; return; } var urlWithVars = $axure.getLinkUrlWithVars(urlToLoad); var currentData = $axure.messageCenter.getState('page.data'); var currentUrl = currentData && currentData.location; if(currentUrl && currentUrl.indexOf('#') != -1) currentUrl = currentUrl.substring(0, currentUrl.indexOf('#')) // this is so we can make sure the current frame reloads if the variables have changed // by default, if the location is the same but the hash code is different, the browser will not // trigger a reload mainFrame.contentWindow.location.href = currentUrl && urlToLoad.toLowerCase() != currentUrl.toLowerCase() ? urlWithVars : 'resources/reload.html#' + encodeURI(urlWithVars); }; var pluginIds = []; var plugins = {}; var currentVisibleHostId = null; // --------------------------------------------- // Adds a tool box frame from a url to the interface. This is useful for loading plugins // settings is an object that supports the following properties: // - id : the id of the element for the plugin // - context : the context to create the plugin host for // - title : the user-visible caption for the plugin // --------------------------------------------- _player.createPluginHost = function (settings) { // right now we only understand an interface context if (!(!settings.context || settings.context === 'interface')) { throw ('unknown context type'); } if (!settings.id) throw ('each plugin host needs an id'); var host = $('') .appendTo('#interfaceControlFrameHostContainer'); host.hide(); var headerLink = $('' + settings.title.toUpperCase() + ''); headerLink .click($axure.utils.curry(interfaceControlHeaderButton_click, settings.id)).wrap(''); if((settings.id == 'feedbackHost' || settings.id == 'feedbackContainer') && pluginIds[pluginIds.length - 1] == 'debugHost') headerLink.parent().insertBefore('#debugHostBtn'); else headerLink.parent().appendTo('#interfaceControlFrameHeader'); pluginIds[pluginIds.length] = settings.id; plugins[settings.id] = settings; $(document).trigger('pluginCreated', [settings.gid]); }; // private methods var interfaceControlHeaderButton_click = function (id) { var clickedPlugin = $('#interfaceControlFrameHeader a[pluginId=' + id + ']'); if(clickedPlugin.hasClass('selected')) { clickedPlugin.removeClass('selected'); $('#' + id).hide(); _player.collapseToBar(); $(document).trigger('pluginShown',['']); } else { $('#interfaceControlFrameHeader a').removeClass('selected'); clickedPlugin.addClass('selected'); $('#' + currentVisibleHostId).hide(); $('#' + id).show(); currentVisibleHostId = id; _player.expandFromBar(); $(document).trigger('pluginShown', [plugins[id].gid]); } $(document).trigger('ContainerHeightChange'); }; $axure.player.showPlugin = function(gid) { for(var id in plugins) { if(plugins[id].gid == gid) { $('a[pluginId=\"' + id + '\"]').click(); break; } } }; } function setUpDocumentStateManager() { var mgr = $axure.prototype.documentStateManager = {}; $axure.utils.makeBindable(mgr, ['globalVariableChanged']); mgr.globalVariableValues = {}; mgr.setGlobalVariable = function(varname, value, source) { var arg = {}; arg.variableName = varname; arg.newValue = value; arg.oldValue = this.getGlobalVariable(varname); arg.source = source; mgr.globalVariableValues[varname] = value; this.triggerEvent('globalVariableChanged', arg); }; mgr.getGlobalVariable = function(varname) { return mgr.globalVariableValues[varname]; }; } function setUpPageStateManager() { var mgr = $axure.prototype.pageStateManager = {}; mgr.panelToStateIds = {}; } //***** messagecenter.js *****// if (typeof console == 'undefined') console = { log: function () { } }; // sniff chrome var CHROME_5_LOCAL = false; var CHROME = false; var SAFARI = false; var FIREFOX = false; var WEBKIT = false; var OS_MAC = false; var IOS = false; var ANDROID = false; var MOBILE_DEVICE = false; var IE = false; var IE_10_AND_BELOW = false; //ie 10 and lower var IE_11_AND_ABOVE = false; //ie 11 and above var BROWSER_VERSION = 5000; (function () { if(!window.$axure) window.$axure = function() {}; var useragent = window.navigator.userAgent; var edgeRegex = /Edge\\/([0-9]+)/g; var edgeMatch = edgeRegex.exec(useragent); $axure.browser = { isEdge: Boolean(edgeMatch) }; if(!$axure.browser.isEdge) { var chromeRegex = /Chrome\\/([0-9]+).([0-9]+)/g; var chromeMatch = chromeRegex.exec(useragent); CHROME = Boolean(chromeMatch); CHROME_5_LOCAL = chromeMatch && Number(chromeMatch[1]) >= 5 && location.href.indexOf('file://') >= 0; } var safariRegex = /Safari\\/([0-9]+)/g; var safariMatch = safariRegex.exec(useragent); SAFARI = Boolean(safariMatch) && !CHROME; //because chrome also inserts safari string into user agent var webkitRegex = /WebKit\\//g ; WEBKIT = Boolean(webkitRegex.exec(useragent)); FIREFOX = useragent.toLowerCase().indexOf('firefox') > -1; var macRegex = /Mac/g ; OS_MAC = Boolean(macRegex.exec(window.navigator.platform)); IOS = useragent.match(/iPhone/i) || useragent.match(/iPad/i) || useragent.match(/iPod/i); ANDROID = useragent.match(/Android/i); MOBILE_DEVICE = ANDROID || IOS || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Tablet PC/i) || navigator.userAgent.match(/Windows Phone/i); if($.browser) { if($.browser.msie) IE_10_AND_BELOW = true; else IE_11_AND_ABOVE = useragent.toLowerCase().indexOf('trident') > -1; BROWSER_VERSION = $.browser.version; } IE = IE_10_AND_BELOW || IE_11_AND_ABOVE; //Used by sitemap and variables.js getLinkUrl functions so that they know //whether to embed global variables in URL as query string or hash string //_shouldSendVars persists the value for sitemap instead of re-checking every time var _shouldSendVars; var _shouldSendVarsToServer = function(url) { if(typeof _shouldSendVars != 'undefined') { return _shouldSendVars; } if(SAFARI || (IE_10_AND_BELOW && BROWSER_VERSION < 10)) { var urlToCheck = typeof url != 'undefined' ? url : window.location.href; var serverRegex = /http:\\/\\/127\\.0\\.0\\.1:[0-9]{5}/g; var serverMatch = serverRegex.exec(urlToCheck); var previewRegex = /[0-9]{2}\\.[0-9]{2}\\.[0-9]{2}/g; var previewMatch = previewRegex.exec(urlToCheck); if(Boolean(serverMatch) && Boolean(previewMatch)) { _shouldSendVars = true; return _shouldSendVars; } } _shouldSendVars = false; return _shouldSendVars; }; $axure.shouldSendVarsToServer = _shouldSendVarsToServer; })(); (function() { var _topMessageCenter; var _messageCenter = {}; var _listeners = []; var _stateListeners = []; var _state = {}; var _eventObject = null; var _queuedMessages = []; var _initialized = false; // this is for the non Chrome 5 local scenarios. The \"top\" message center will dispatch to all the bottom ones var _childrenMessageCenters = []; // create $axure if it hasn't been created if (!window.$axure) window.$axure = function() {}; $axure.messageCenter = _messageCenter; // isolate scope, and initialize _topMessageCenter. (function() { if (!CHROME_5_LOCAL) { var topAxureWindow = window; try { while(topAxureWindow.parent && topAxureWindow.parent !== topAxureWindow && topAxureWindow.parent.$axure) topAxureWindow = topAxureWindow.parent; } catch(e) {} _topMessageCenter = topAxureWindow.$axure.messageCenter; } })(); $(window.document).ready(function() { if (CHROME_5_LOCAL) { $('body').append(\"\" + \"\"); _eventObject = window.document.createEvent('Event'); _eventObject.initEvent('axureMessageSenderEvent', true, true); $('#axureEventReceiverDiv').bind('axureMessageReceiverEvent', function () { var request = JSON.parse($(this).text()); _handleRequest(request); }); } else { if (_topMessageCenter != _messageCenter) { _topMessageCenter.addChildMessageCenter(_messageCenter); console.log('adding from ' + window.location.toString()); } } }); var _handleRequest = function (request) { // route the request to all the listeners for(var i = 0; i < _listeners.length; i++) _listeners[i](request.message, request.data); // now handle the queued messages if we're initializing if (request.message == 'initialize') { _initialized = true; // send all the queued messages and return for (var i = 0; i < _queuedMessages.length; i++) { var qRequest = _queuedMessages[i]; _messageCenter.postMessage(qRequest.message, qRequest.data); } _queuedMessages = []; } // and then handle the set state messages, if necessary if (request.message == 'setState') { _state[request.data.key] = request.data.value; for (var i = 0; i < _stateListeners.length; i++) { var keyListener = _stateListeners[i]; // if thep passed a null or empty value, always post the message if (!keyListener.key || keyListener.key == request.data.key) { keyListener.listener(request.data.key, request.data.value); } } } }; // ----------------------------------------------------------------------------------------- // This method allows for dispatching messages in the non-chromelocal scenario. // Each child calls this on _topMessageCenter // ----------------------------------------------------------------------------------------- _messageCenter.addChildMessageCenter = function(messageCenter) { _childrenMessageCenters[_childrenMessageCenters.length] = messageCenter; }; // ----------------------------------------------------------------------------------------- // This method allows for dispatching messages in the non-chromelocal scenario. // Each child calls this on _topMessageCenter // ----------------------------------------------------------------------------------------- _messageCenter.dispatchMessage = function(message, data) { _handleRequest({ message: message, data: data }); }; // ----------------------------------------------------------------------------------------- // ----------------------------------------------------------------------------------------- _messageCenter.dispatchMessageRecursively = function(message, data) { console.log(\"dispatched to \" + window.location.toString()); // dispatch to the top center first _messageCenter.dispatchMessage(message, data); $('iframe').each(function(index, frame) { //try,catch to handle permissions error in FF when loading pages from another domain try { if (frame.contentWindow.$axure && frame.contentWindow.$axure.messageCenter) { frame.contentWindow.$axure.messageCenter.dispatchMessageRecursively(message, data); } }catch(e) {} }); }; var _combineEventMessages = false; var _compositeEventMessageData = []; _messageCenter.startCombineEventMessages = function() { _combineEventMessages = true; } _messageCenter.endCombineEventMessages = function () { _messageCenter.sendCompositeEventMessage(); _combineEventMessages = false; } _messageCenter.sendCompositeEventMessage = function () { _messageCenter.postMessage('axCompositeEventMessage', _compositeEventMessageData); _compositeEventMessageData = []; } _messageCenter.postMessage = function (message, data) { if(_combineEventMessages) { if(message == 'axEvent' || message == 'axCase' || message == 'axAction' || message == 'axEventComplete') { _compositeEventMessageData.push({ 'message': message, 'data': data }); if(_compositeEventMessageData.length >= 10) _messageCenter.sendCompositeEventMessage(); return; } } if(!CHROME_5_LOCAL) { _topMessageCenter.dispatchMessageRecursively(message, data); } else { var request = { message: message, data: data }; if(_initialized) { var senderDiv = window.document.getElementById('axureEventSenderDiv'); var messageText = JSON.stringify(request); // console.log('sending event: ' + messageText); senderDiv.innerText = messageText; senderDiv.dispatchEvent(_eventObject); // console.log('event sent'); } else { _queuedMessages[_queuedMessages.length] = request; } } }; _messageCenter.setState = function(key, value) { var data = { key: key, value: value }; _messageCenter.postMessage('setState', data); }; _messageCenter.getState = function(key) { return _state[key]; }; _messageCenter.addMessageListener = function(listener) { _listeners[_listeners.length] = listener; }; _messageCenter.addStateListener = function(key, listener) { _stateListeners[_stateListeners.length] = { key: key, listener: listener }; }; })();"},{"title":"","date":"2023-02-27T14:44:57.224Z","updated":"2023-02-27T14:44:57.224Z","comments":true,"path":"imgs/axure/我的考试_files/prototypePre.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/prototypePre.js","excerpt":"","text":"// 8.0.0.3382. Generated 1/14/2019 10:26:32 PM UTC //***** axQuery.js *****// $axure = function(query) { return $axure.query(query); }; // ******* AxQuery and Page metadata ******** // (function() { var $ax = function() { var returnVal = $axure.apply(this, arguments); var axFn = $ax.fn; for (var key in axFn) { returnVal[key] = axFn[key]; } return returnVal; }; $ax.public = $axure; $ax.fn = {}; $axure.internal = function(initFunction) { //Attach messagecenter to $ax object so that it can be used in viewer.js, etc in internal scope if(!$ax.messageCenter) $ax.messageCenter = $axure.messageCenter; return initFunction($ax); }; var _lastFiredResize = 0; var _resizeFunctions = []; var _lastTimeout; var _fireResize = function() { if (_lastTimeout) window.clearTimeout(_lastTimeout); _lastTimeout = undefined; _lastFiredResize = new Date().getTime(); for(var i = 0; i < _resizeFunctions.length; i++) _resizeFunctions[i](); }; $axure.resize = function(fn) { if(fn) _resizeFunctions[_resizeFunctions.length] = fn; else $(window).resize(); }; $(window).resize(function() { var THRESHOLD = 50; var now = new Date().getTime(); if(now - _lastFiredResize > THRESHOLD) { _fireResize(); } else if(!_lastTimeout) { _lastTimeout = window.setTimeout(_fireResize, THRESHOLD); } }); window.$obj = function(id) { return $ax.getObjectFromElementId(id); }; window.$id = function(obj) { return obj.scriptIds[0]; }; window.$jobj = function(id) { return $(document.getElementById(id)); }; window.$jobjAll = function(id) { return $addAll($jobj(id), id); }; window.$addAll = function(jobj, id) { return jobj.add($jobj(id + '_ann')).add($jobj(id + '_ref')); }; $ax.INPUT = function(id) { return id + \"_input\"; }; $ax.IsImageFocusable = function (type) { return $ax.public.fn.IsImageBox(type) || $ax.public.fn.IsVector(type) || $ax.public.fn.IsTreeNodeObject(type) || $ax.public.fn.IsTableCell(type); }; $ax.IsTreeNodeObject = function (type) { return $ax.public.fn.IsTreeNodeObject(type); }; $ax.IsSelectionButton = function (type) { return $ax.public.fn.IsCheckBox(type) || $ax.public.fn.IsRadioButton(type); }; var _fn = {}; $axure.fn = _fn; $axure.fn.jQuery = function() { var elements = this.getElements(); return $(elements); }; $axure.fn.$ = $axure.fn.jQuery; var _query = function(query, queryArg) { var returnVal = {}; var _axQueryObject = returnVal.query = { }; _axQueryObject.filterFunctions = []; if (query == '*') { _axQueryObject.filterFunctions[0] = function() { return true; }; } else if (typeof(query) === 'function') { _axQueryObject.filterFunctions[0] = query; } else { var firstString = $.trim(query.toString()); if (firstString.charAt(0) == '@') { _axQueryObject.filterFunctions[0] = function(diagramObject) { return diagramObject.label == firstString.substring(1); }; } else if (firstString.charAt(0) == '#') { _axQueryObject.elementId = firstString.substring(1); } else { if (firstString == 'label') { _axQueryObject.filterFunctions[0] = function(diagramObject) { return queryArg instanceof Array && queryArg.indexOf(diagramObject.label) > 0 || queryArg instanceof RegExp && queryArg.test(diagramObject.label) || diagramObject.label == queryArg; }; } else if(firstString == 'elementId') { _axQueryObject.filterFunctions[0] = function(diagramObject, elementId) { return queryArg instanceof Array && queryArg.indexOf(elementId) > 0 || elementId == queryArg; }; } } } var axureFn = $axure.fn; for (var key in axureFn) { returnVal[key] = axureFn[key]; } return returnVal; }; $axure.query = _query; var _getFilterFnFromQuery = function(query) { var filter = function(diagramObject, elementId) { // Non diagram objects are allowed to be queryed, such as text inputs. if (diagramObject && !$ax.public.fn.IsReferenceDiagramObject(diagramObject.type) && !document.getElementById(elementId)) return false; var retVal = true; for(var i = 0; i < query.filterFunctions.length && retVal; i++) { retVal = query.filterFunctions[i](diagramObject, elementId); } return retVal; }; return filter; }; $ax.public.fn.filter = function(query, queryArg) { var returnVal = _query(query, queryArg); if(this.query.elementId) returnVal.query.elementId = this.query.elementId; //If there is already a function, offset by 1 when copying other functions over. var offset = returnVal.query.filterFunctions[0] ? 1 : 0; //Copy all functions over to new array. for(var i = 0; i < this.query.filterFunctions.length; i++) returnVal.query.filterFunctions[i+offset] = this.query.filterFunctions[i]; //Functions are in reverse order now returnVal.query.filterFunctions.reverse(); return returnVal; }; $ax.public.fn.each = function(fn) { var filter = _getFilterFnFromQuery(this.query); var elementIds = this.query.elementId ? [this.query.elementId] : $ax.getAllElementIds(); for (var i = 0; i < elementIds.length; i++) { var elementId = elementIds[i]; var diagramObject = $ax.getObjectFromElementId(elementId); if (filter(diagramObject, elementId)) { fn.apply(diagramObject, [diagramObject, elementId]); } } }; $ax.public.fn.getElements = function() { var elements = []; this.each(function(dObj, elementId) { var elementById = document.getElementById(elementId); if(elementById) elements[elements.length] = elementById; }); return elements; }; $ax.public.fn.getElementIds = function() { var elementIds = []; this.each(function(dObj, elementId) { elementIds[elementIds.length] = elementId; }); return elementIds; }; // Deep means to keep getting parents parent until at the root parent. Parent is then an array instead of an id. // Filter options: layer, rdo, repeater, item, dynamicPanel, state $ax.public.fn.getParents = function (deep, filter) { if(filter == '*') filter = ['layer', 'rdo', 'repeater', 'item', 'dynamicPanel', 'state']; var elementIds = this.getElementIds(); var parentIds = []; var getParent = function(elementId) { var containerIndex = elementId.indexOf('_container'); if(containerIndex !== -1) elementId = elementId.substring(0, containerIndex); if(elementId.indexOf('_text') !== -1) elementId = $ax.GetShapeIdFromText(elementId); // Check repeater item before layer, because repeater item detects it's parent layer, but wants to go directly to it's repeater first. // if repeater item, then just return repeater var scriptId = $ax.repeater.getScriptIdFromElementId(elementId); var itemNum = $ax.repeater.getItemIdFromElementId(elementId); var parentRepeater = $ax.getParentRepeaterFromScriptId(scriptId); // scriptId is item or repeater itself if (parentRepeater == scriptId) { // If you are repeater item, return your repeater if (itemNum) return filter.indexOf('repeater') != -1 ? scriptId : getParent(scriptId); // Otherwise you are actually at repeater, clean parentRepeater, or else you loop parentRepeater = undefined; } // Layer only references it if it is a direct layer to it var parent = $ax.getLayerParentFromElementId(elementId); // If layer is allowed we found parent, otherwise ignore and keep climbing if (parent) return filter.indexOf('layer') != -1 ? parent : getParent(parent); // if state, then just return panel if(scriptId.indexOf('_state') != -1) { var panelId = $ax.repeater.createElementId(scriptId.split('_')[0], itemNum); // If dynamic panel is allowed we found parent, otherwise ignore and keep climbing return filter.indexOf('dynamicPanel') != -1 ? panelId : getParent(panelId); } var parentType = ''; if(parentRepeater) { parentType = 'item'; parent = $ax.repeater.createElementId(parentRepeater, itemNum); } var masterPath = $ax.getPathFromScriptId($ax.repeater.getScriptIdFromElementId(elementId)); masterPath.pop(); if(masterPath.length > 0) { var masterId = $ax.getElementIdFromPath(masterPath, { itemNum: itemNum }); if(!masterId) return undefined; var masterRepeater = $ax.getParentRepeaterFromElementId($ax.repeater.getScriptIdFromElementId(masterId)); if(!parentRepeater || masterRepeater) { parentType = 'rdo'; parent = masterId; } } var obj = $obj(elementId); var parentDynamicPanel = obj.parentDynamicPanel; if(parentDynamicPanel) { // Make sure the parent if not parentRepeater, or dynamic panel is also in that repeater // If there is a parent master, the dynamic panel must be in it, otherwise parentDynamicPanel would be undefined. var panelPath = masterPath; panelPath[panelPath.length] = parentDynamicPanel; panelId = $ax.getElementIdFromPath(panelPath, { itemNum: itemNum }); if(!panelId) return undefined; var panelRepeater = $ax.getParentRepeaterFromElementId(panelId); if(!parentRepeater || panelRepeater) { parentType = 'state'; parent = panelId + '_state' + obj.panelIndex; } } // If at top or parent type is desired, then return parent, otherwise keep climbing return !parent || filter.indexOf(parentType) != -1 ? parent : getParent(parent); }; for(var i = 0; i < elementIds.length; i++) { var parent = getParent(elementIds[i]); if(deep) { var parents = []; while(parent) { parents[parents.length] = parent; // If id is not a valid object, you are either repeater item or dynamic panel state //if(!$obj(parent)) parent = $ax.visibility.getWidgetFromContainer($jobj(parent).parent().attr('id')); parent = getParent(parent); } parent = parents; } parentIds[parentIds.length] = parent; } return parentIds; }; // Get the path to the child, where non leaf nodes can be masters, layers, dynamic panels, and repeaters. $ax.public.fn.getChildren = function(deep, ignoreUnplaced) { // ignoreUnplaced should probably be the default, but when that is done a full audit of usages should be done var elementIds = this.getElementIds(); var children = []; var getChildren = function(elementId) { var obj = $obj(elementId); if(!obj) return undefined; var isRepeater = obj.type == $ax.constants.REPEATER_TYPE; var isDynamicPanel = obj.type == $ax.constants.DYNAMIC_PANEL_TYPE; var isLayer = obj.type == $ax.constants.LAYER_TYPE; var isMaster = obj.type == $ax.constants.MASTER_TYPE; var isMenu = obj.type == $ax.constants.MENU_OBJECT_TYPE; var isTreeNode = obj.type == $ax.constants.TREE_NODE_OBJECT_TYPE; var isTable = obj.type == $ax.constants.TABLE_TYPE; //var isCompoundVector = obj.type == $ax.constants.VECTOR_SHAPE_TYPE && obj.generateCompound; if (isRepeater || isDynamicPanel || isLayer || isMaster || isMenu || isTreeNode || isTable) {// || isCompoundVector) { // Find parent that children should be pulled from. Default is just the elementId query (used by table and master) var parent = $jobj(elementId); if(isRepeater) { parent = $(); var itemIds = $ax.getItemIdsForRepeater(elementId); for(var itemIndex = 0; itemIndex < itemIds.length; itemIndex++) parent = parent.add($jobj($ax.repeater.createElementId(elementId, itemIds[itemIndex]))); } else if(isDynamicPanel) { // Really only need to do active state probably... parent = $jobj(elementId).children(); // Get through all containers while ($(parent[0]).attr('id').indexOf('container') != -1) parent = parent.children(); // Now at states, but want states content parent = parent.children(); } else if(isTreeNode) parent = $jobj($ax.repeater.applySuffixToElementId(elementId, '_children')); // Menu doesn't want all children, only tables and menus, so it must be handled specially var children = isMenu ? parent.children('.ax_table').add(parent.children('.ax_menu')) : parent.children(); children = $ax.visibility.getRealChildren(_fixForBasicLinks(children)); // For tree nodes you want the the button shape contained by the elementQuery too if(isTreeNode) { var treeNodeChildren = $jobj(elementId).children(); for(var treeNodeIndex = 0; treeNodeIndex < treeNodeChildren.length; treeNodeIndex++) { var treeNodeChild = $(treeNodeChildren[treeNodeIndex]); var childObj = $obj(treeNodeChild.attr('id')); if (childObj && $ax.public.fn.IsVector(childObj.type)) children = children.add(treeNodeChild); } } var childrenIds = []; for(var childIndex = 0; childIndex < children.length; childIndex++) { var childObj = $(children[childIndex]); var id = childObj.attr('id'); if(typeof(id) == 'undefined' && childObj.is('a')) id = $(childObj.children()[0]).attr('id'); // Ignore annotations and any other children that are not elements if (id.split('_').length > 1) continue; // Ignore Unplaced if(ignoreUnplaced && $ax.visibility.isScriptIdLimbo($ax.repeater.getScriptIdFromElementId(id))) continue; childrenIds.push(id); } if(deep) { var childObjs = []; for(var i = 0; i < childrenIds.length; i++) { var childId = childrenIds[i]; childObjs[i] = { id: childId, children: getChildren(childId) }; } childrenIds = childObjs; } return childrenIds; } return undefined; }; for(var i = 0; i < elementIds.length; i++) { children[children.length] = { id : elementIds[i], children : getChildren(elementIds[i])}; } return children; }; var _fixForBasicLinks = function(query) { var hasBasicLinks = query.filter('.basiclink').length > 0; if(!hasBasicLinks) return query; var retval = $(); for(var i = 0; i < query.length; i++) { var child = $(query[i]); if(child.hasClass('basiclink')) retval = retval.add(child.children()); else retval = retval.add(child); } return retval; }; })(); //***** globals.js *****// $axure.internal(function($ax) { var _globals = $ax.globals = {}; $ax.globals.MaxZIndex = 1000; $ax.globals.MinZIndex = -1000; }); //***** axutils.js *****// /* * * * * */ (function() { // define the root namespace object if(!window.$axure) window.$axure = {}; $axure.utils = {}; // ------------------------------------------------------------------------ // Makes an object bindable // ------------------------------------------------------------------------ $axure.utils.makeBindable = function(obj, events) { if(obj.registeredBindings != null) return; // copy the events obj.bindableEvents = events.slice(); obj.registeredBindings = {}; obj.bind = function(eventName, fn) { var binding = {}; binding.eventName = eventName; binding.action = fn; var bindingList = this.registeredBindings[eventName]; if(bindingList == null) { bindingList = []; this.registeredBindings[eventName] = bindingList; } bindingList[bindingList.length] = binding; }; obj.unbind = function(eventName) { if(eventName.indexOf('.') >= 0) { this.registeredBindings[eventName] = null; } else { var event = eventName.split('.')[0]; for(var bindingKey in this.registeredBindings) { if(bindingKey.split('.')[0] == event) { this.registeredBindings[bindingKey] = null; } } } }; obj.triggerEvent = function(eventName, arg) { for(var bindingKey in this.registeredBindings) { if(bindingKey.split('.')[0] == eventName) { var bindings = this.registeredBindings[bindingKey]; for(var i = 0; i < bindings.length; i++) { if(arg == null) { bindings[i].action(); } else { bindings[i].action(arg); } } } } }; }; $axure.utils.loadCSS = function(url) { $('head').append(''); }; $axure.utils.loadJS = function(url) { $('head').append(''); }; $axure.utils.curry = function(fn) { var curriedArgs = Array.prototype.slice.call(arguments, [1]); return function() { fn.apply(this, curriedArgs.concat(Array.prototype.slice.call(arguments))); }; }; $axure.utils.succeeded = function(result) { return result && result.success; }; $axure.utils.createUniqueTag = function() { return Math.random().toString().substring(2) + Math.random().toString().substring(2) + Math.random().toString().substring(2) + Math.random().toString().substring(2); }; $axure.utils.formatDate = function(date) { var months = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]; var hours = date.getHours(); var amPm = (hours > 11 ? 'PM' : 'AM'); hours = hours % 12; if(hours == '0') hours = '12'; var minutes = date.getMinutes() + ''; if(minutes.length == 1) { minutes = '0' + minutes; } return [ months[date.getMonth()], ' ', date.getDate(), ' ', date.getFullYear(), ' ', hours, ':', minutes, ' ', amPm].join(''); }; $axure.utils.quickObject = function() { var returnVal = {}; for(var i = 0; i < arguments.length; i += 2) { returnVal[arguments[i]] = arguments[i + 1]; } return returnVal; }; var matrixBase = { mul: function(val) { if(val.x !== undefined) { return $axure.utils.Vector2D( this.m11 * val.x + this.m12 * val.y + this.tx, this.m21 * val.x + this.m22 * val.y + this.ty); } else if(val.m11) { return $axure.utils.Matrix2D( this.m11 * val.m11 + this.m12 * val.m21, this.m11 * val.m12 + this.m12 * val.m22, this.m21 * val.m11 + this.m22 * val.m21, this.m21 * val.m12 + this.m22 * val.m22, val.tx + this.tx * val.m11 + this.ty * val.m21, val.ty + this.tx * val.m12 + this.ty * val.m22 ); } else if(Number(val)) { var num = Number(val); return $axure.utils.Matrix2D(this.m11 * num, this.m12 * num, this.m21 * num, this.m22 * num, this.tx * num, this.ty * num); } else return undefined; }, rotate: function(angle) { var angleRad = angle * Math.PI / 180; var c = Math.cos(angleRad); var s = Math.sin(angleRad); return this.mul($axure.utils.Matrix2D(c, -s, s, c)); }, translate: function(tx, ty) { return this.mul($axure.utils.Matrix2D(1, 0, 0, 1, tx, ty)); } }; $axure.utils.Matrix2D = function(m11, m12, m21, m22, tx, ty) { return $.extend({ m11: m11 || 0, m12: m12 || 0, m21: m21 || 0, m22: m22 || 0, tx: tx || 0, ty: ty || 0 }, matrixBase); }; $axure.utils.Vector2D = function(x, y) { return { x: x || 0, y: y || 0 }; }; $axure.utils.Matrix2D.identity = function() { return $axure.utils.Matrix2D(1, 0, 0, 1, 0, 0); }; $axure.utils.fixPng = function(png) { if(!(/MSIE ((5\\.5)|6)/.test(navigator.userAgent) && navigator.platform == \"Win32\")) return; var src = png.src; if(!png.style.width) { png.style.width = $(png).width(); } if(!png.style.height) { png.style.height = $(png).height(); } png.onload = function() { }; png.src = $axure.utils.getTransparentGifPath(); png.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + src + \"',sizingMethod='scale')\"; }; })(); // TODO: [mas] simplify this if(window.$axure && window.$axure.internal) { $axure.internal(function($ax) { $ax.utils = $axure.utils; }); } // Its too much of a pain to escape everything and use regular expresions, just replace manually (function () { var original = String.prototype.replace; // TODO: maybe use flags or object instead to pass options in String.prototype.replace = function (search, newVal, replaceFirst, ignoreCase) { // Use original is some cases if (search instanceof RegExp) return original.apply(this, arguments); search = String(search); var searchCompare = ignoreCase ? this.toLowerCase() : this; if (ignoreCase) search = search.toLowerCase(); var searchLength = search.length; var thisLength = this.length; var index = 0; var retVal = ''; while (index != -1) { var nextIndex = searchCompare.indexOf(search, index); if (nextIndex != -1) { retVal += this.substring(index, nextIndex) + newVal; index = nextIndex + searchLength; if (index >= thisLength) index = -1; } else { retVal += this.substring(index); index = -1; } if (replaceFirst) break; } return retVal; }; if (!Array.prototype.indexOf) { Array.prototype.indexOf = function (elt /*, from*/) { var len = this.length >>> 0; var from = trunc(Number(arguments[1]) || 0); if(from < 0) from += len; for(; from < len; from++) { if(from in this && this[from] === elt) return from; } return -1; }; } var trunc = function(num) { return num < 0 ? Math.ceil(num) : Math.floor(num); }; })(); //***** annotation.js *****// // ******* Annotation MANAGER ******** // $axure.internal(function($ax) { var NOTE_SIZE = 10; var _annotationManager = $ax.annotation = {}; var _updateLinkLocations = $ax.annotation.updateLinkLocations = function(elementId) { var textId = $ax.GetTextPanelId(elementId); if(!textId) return; var rotation = $ax.getObjectFromElementId(elementId).style.textRotation; //we have to do this because webkit reports the post-transform position but when you set positions it's pre-transform if(WEBKIT && rotation) { //we can dynamiclly rotate a widget now, show need to remember the transform rather than just remove it //here jquery.css will return 'none' if element is display none var oldShapeTransform = document.getElementById(elementId).style['-webkit-transform']; var oldTextTransform = document.getElementById(textId).style['-webkit-transform']; $('#' + elementId).css('-webkit-transform', 'scale(1)'); $('#' + textId).css('-webkit-transform', 'scale(1)'); } $('#' + textId).find('span[id$=\"_ann\"]').each(function(index, value) { var elementId = value.id.replace('_ann', ''); var annPos = $(value).position(); var left = annPos.left - NOTE_SIZE; var top = annPos.top; $('#' + elementId + 'Note').css('left', left).css('top', top); }); //undo the transform reset if(WEBKIT && rotation) { $('#' + elementId).css('-webkit-transform', oldShapeTransform || ''); $('#' + textId).css('-webkit-transform', oldTextTransform || ''); } }; var dialogs = {}; $ax.annotation.ToggleWorkflow = function(event, id, width, height) { if(dialogs[id]) { var $dialog = dialogs[id]; // reset the dialog dialogs[id] = undefined; if($dialog.dialog(\"isOpen\")) { $dialog.dialog(\"close\"); return; } } // we'll need to save the scroll position just for stupid IE which will skip otherwise var win = $(window); var scrollY = win.scrollTop(); var scrollX = win.scrollLeft(); var bufferH = 10; var bufferV = 10; var blnLeft = false; var blnAbove = false; var sourceTop = event.pageY - scrollY; var sourceLeft = event.pageX - scrollX; if(sourceLeft > width + bufferH) { blnLeft = true; } if(sourceTop > height + bufferV) { blnAbove = true; } var top = 0; var left = 0; if(blnAbove) top = sourceTop - height - 20; else top = sourceTop + 10; if(blnLeft) left = sourceLeft - width - 4; else left = sourceLeft - 6; $ax.globals.MaxZIndex = $ax.globals.MaxZIndex + 1; if(IE_10_AND_BELOW) height += 50; var dObj = $ax.getObjectFromElementId(id); var ann = dObj.annotation; var $dialog = $('') .appendTo('body') .html($ax.legacy.GetAnnotationHtml(ann)) .dialog({ title: dObj.label, width: width, height: height, minHeight: 150, zIndex: $ax.globals.MaxZIndex, position: [left, top], dialogClass: 'dialogFix', autoOpen: false }); $dialog.parent().appendTo('#base'); $dialog.dialog('open'); dialogs[id] = $dialog; // scroll ... just for IE window.scrollTo(scrollX, scrollY); }; $ax.annotation.InitializeAnnotations = function (query) { if(!$ax.document.configuration.showAnnotations) return; query.each(function(dObj, elementId) { if(!dObj.annotation) return; if(dObj.type == 'hyperlink') { var parentId = $ax.GetParentIdFromLink(elementId); var textId = $ax.GetTextPanelId(parentId); var elementIdQuery = $('#' + elementId); elementIdQuery.after(\"&#8203;\"); if($ax.document.configuration.useLabels) { var label = $('#' + elementId).attr(\"data-label\"); if(!label || label == \"\") label = \"?\"; $('#' + textId).append(\"\" + label + \"\"); } else { $('#' + textId).append(\"\"); } $('#' + elementId + 'Note').click(function(e) { $ax.annotation.ToggleWorkflow(e, elementId, 300, 200, false); return false; }); _updateLinkLocations(parentId); } else { if($ax.document.configuration.useLabels) { var label = $('#' + elementId).attr(\"data-label\"); if(!label || label == \"\") label = \"?\"; $('#' + elementId + \"_ann\").append(\"\" + label + \"\"); } else { $('#' + elementId + \"_ann\").append(\"\"); } $('#' + elementId + 'Note').click(function(e) { $ax.annotation.ToggleWorkflow(e, elementId, 300, 200, false); return false; }); } $('#' + elementId + 'Note.annnoteimage').append(\"\"); }); }; $ax.annotation.jQueryAnn = function(query) { var elementIds = []; query.each(function(diagramObject, elementId) { if(diagramObject.annotation) elementIds[elementIds.length] = elementId; }); var elementIdSelectors = jQuery.map(elementIds, function(elementId) { return '#' + elementId + '_ann'; }); var jQuerySelectorText = (elementIdSelectors.length > 0) ? elementIdSelectors.join(', ') : ''; return $(jQuerySelectorText); }; $(window.document).ready(function() { $ax.annotation.InitializeAnnotations($ax(function(dObj) { return dObj.annotation; })); $ax.messageCenter.addMessageListener(function(message, data) { //If the annotations are being hidden via the Sitemap toggle button, hide any open dialogs if(message == 'annotationToggle') { if(data == false) { for(var index in dialogs) { var $dialog = dialogs[index]; if($dialog.dialog(\"isOpen\")) { $dialog.dialog(\"close\"); } } } } }); }); //adjust annotation location to a element's top right corner $ax.annotation.adjustIconLocation = function(id) { var ann = document.getElementById(id + \"_ann\"); if(ann) { var corners = $ax.public.fn.getCornersFromComponent(id); var newTopRight = $ax.public.fn.vectorPlus(corners.relativeTopRight, corners.centerPoint); //note size is 14x8, this is how rp calculated it as well ann.style.left = (newTopRight.x - 7) + \"px\"; ann.style.top = (newTopRight.y - 4) + \"px\"; } var ref = document.getElementById(id + \"_ref\"); if(ref) { if(!corners) corners = $ax.public.fn.getCornersFromComponent(id); var newBottomRight = $ax.public.fn.vectorPlus(corners.relativeBottomRight, corners.centerPoint); ref.style.left = (newBottomRight.x - 8) + 'px'; ref.style.top = (newBottomRight.y - 10) + 'px'; } } }); //***** axQuery.std.js *****// // ******* AxQuery Plugins ******** // $axure.internal(function($ax) { $ax.constants = {}; $ax.constants.TABLE_TYPE = 'table'; $ax.constants.MENU_OBJECT_TYPE = 'menuObject'; $ax.constants.MASTER_TYPE = 'master'; $ax.constants.PAGE_TYPE = 'page'; $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE = 'referenceDiagramObject'; $ax.constants.REPEATER_TYPE = 'repeater'; $ax.constants.DYNAMIC_PANEL_TYPE = 'dynamicPanel'; $ax.constants.LAYER_TYPE = 'layer'; $ax.constants.TEXT_BOX_TYPE = 'textBox'; $ax.constants.TEXT_AREA_TYPE = 'textArea'; $ax.constants.LIST_BOX_TYPE = 'listBox'; $ax.constants.COMBO_BOX_TYPE = 'comboBox'; $ax.constants.CHECK_BOX_TYPE = 'checkbox'; $ax.constants.RADIO_BUTTON_TYPE = 'radioButton'; $ax.constants.BUTTON_TYPE = 'button'; //html button $ax.constants.IMAGE_MAP_REGION_TYPE = 'imageMapRegion'; $ax.constants.IMAGE_BOX_TYPE = 'imageBox'; $ax.constants.VECTOR_SHAPE_TYPE = 'vectorShape'; $ax.constants.SNAPSHOT_TYPE = 'screenshot'; $ax.constants.TREE_NODE_OBJECT_TYPE = 'treeNodeObject'; $ax.constants.TABLE_CELL_TYPE = 'tableCell'; $ax.constants.VERTICAL_LINE_TYPE = 'verticalLine'; $ax.constants.HORIZONTAL_LINE_TYPE = 'horizontalLine'; $ax.constants.INLINE_FRAME_TYPE = 'inlineFrame'; $ax.constants.CONNECTOR_TYPE = 'connector'; $ax.constants.ALL_TYPE = '*'; $ax.constants.TEXT_TYPE = 'richTextPanel'; $ax.constants.LINK_TYPE = 'hyperlink'; // TODO: Need solid passo f this. Constants should be able to bemade local, may need some public lists or something. // public.fn function should take not arg and use this. May need some $ax.IsType fuctions that will take a type arg and be static $ax.public.fn.IsTable = function (type) { return type == $ax.constants.TABLE_TYPE; } $ax.public.fn.IsMenuObject = function (type) { return type == $ax.constants.MENU_OBJECT_TYPE; } $ax.public.fn.IsMaster = function (type) { return type == $ax.constants.MASTER_TYPE; } $ax.public.fn.IsPage = function (type) { return type == $ax.constants.PAGE_TYPE; } $ax.public.fn.IsReferenceDiagramObject = function (type) { return type == $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE; } $ax.public.fn.IsRepeater = function (type) { return type == $ax.constants.REPEATER_TYPE; } $ax.public.fn.IsDynamicPanel = $ax.IsDynamicPanel = function (type) { return type == $ax.constants.DYNAMIC_PANEL_TYPE; } $ax.public.fn.IsLayer = $ax.IsLayer = function (type) { return type == $ax.constants.LAYER_TYPE; } $ax.public.fn.IsTextBox = function (type) { return type == $ax.constants.TEXT_BOX_TYPE; } $ax.public.fn.IsTextArea = function (type) { return type == $ax.constants.TEXT_AREA_TYPE; } $ax.public.fn.IsListBox = function (type) { return type == $ax.constants.LIST_BOX_TYPE; } $ax.public.fn.IsComboBox = function (type) { return type == $ax.constants.COMBO_BOX_TYPE; } $ax.public.fn.IsCheckBox = function (type) { return type == $ax.constants.CHECK_BOX_TYPE; } $ax.public.fn.IsRadioButton = function (type) { return type == $ax.constants.RADIO_BUTTON_TYPE; } $ax.public.fn.IsButton = function (type) { return type == $ax.constants.BUTTON_TYPE; } $ax.public.fn.IsIamgeMapRegion = function (type) { return type == $ax.constants.IMAGE_MAP_REGION_TYPE; } $ax.public.fn.IsImageBox = function (type) { return type == $ax.constants.IMAGE_BOX_TYPE; } $ax.public.fn.IsVector = function (type) { return type == $ax.constants.VECTOR_SHAPE_TYPE; } $ax.public.fn.IsSnapshot = function (type) { return type == $ax.constants.SNAPSHOT_TYPE; } $ax.public.fn.IsTreeNodeObject = function (type) { return type == $ax.constants.TREE_NODE_OBJECT_TYPE; } $ax.public.fn.IsTableCell = function (type) { return type == $ax.constants.TABLE_CELL_TYPE; } $ax.public.fn.IsInlineFrame = function (type) { return type == $ax.constants.INLINE_FRAME_TYPE; } $ax.public.fn.IsConnector = function (type) { return type == $ax.constants.CONNECTOR_TYPE; } $ax.public.fn.IsContainer = function (type) { return type== $ax.constants.VECTOR_SHAPE_TYPE || type == $ax.constants.TABLE_TYPE || type == $ax.constants.MENU_OBJECT_TYPE || type == $ax.constants.TREE_NODE_OBJECT_TYPE; } var PLAIN_TEXT_TYPES = [$ax.constants.TEXT_BOX_TYPE, $ax.constants.TEXT_AREA_TYPE, $ax.constants.LIST_BOX_TYPE, $ax.constants.COMBO_BOX_TYPE, $ax.constants.CHECK_BOX_TYPE, $ax.constants.RADIO_BUTTON_TYPE, $ax.constants.BUTTON_TYPE]; $ax.public.fn.IsResizable = function (type) { return $.inArray(type, RESIZABLE_TYPES) !== -1; } var RESIZABLE_TYPES = [ $ax.constants.BUTTON_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE, $ax.constants.IMAGE_BOX_TYPE, $ax.constants.IMAGE_MAP_REGION_TYPE, $ax.constants.INLINE_FRAME_TYPE, $ax.constants.LAYER_TYPE, $ax.constants.LIST_BOX_TYPE, $ax.constants.COMBO_BOX_TYPE, $ax.constants.VECTOR_SHAPE_TYPE, $ax.constants.TEXT_AREA_TYPE, $ax.constants.TEXT_BOX_TYPE, $ax.constants.SNAPSHOT_TYPE ]; $ax.public.fn.SupportsRichText = function() { var obj = $obj(this.getElementIds()[0]); // Catch root tree nodes as they are not supported. if(obj.type == $ax.constants.TREE_NODE_OBJECT_TYPE) return obj.friendlyType == 'Tree Node'; // Do the same for tree node icons maybe? return $.inArray(obj.type, SUPPORTS_RICH_TEXT_TYPES) != -1; } var SUPPORTS_RICH_TEXT_TYPES = [$ax.constants.CHECK_BOX_TYPE, $ax.constants.RADIO_BUTTON_TYPE, $ax.constants.IMAGE_BOX_TYPE, $ax.constants.VECTOR_SHAPE_TYPE, $ax.constants.TABLE_CELL_TYPE, $ax.constants.CONNECTOR_TYPE]; var _addJQueryFunction = function(name) { $ax.public.fn[name] = function() { var val = $.fn[name].apply(this.jQuery(), arguments); return arguments[0] ? this : val; }; }; var _jQueryFunctionsToAdd = ['text', 'val', 'css']; for (var jqueryFunctionIndex = 0; jqueryFunctionIndex < _jQueryFunctionsToAdd.length; jqueryFunctionIndex++) _addJQueryFunction(_jQueryFunctionsToAdd[jqueryFunctionIndex]); // var _addJQueryEventFunction = function(name) { // $ax.public.fn[name] = function() { // $.fn[name].apply(this.jQuery(), arguments); // return this; // }; // }; // var _addJQueryEventFunction = function(name) { // $ax.public.fn[name] = (function(nn) { // return function() { // $.fn[nn].apply(this.jQuery(), arguments); // return this; // }; // })(name); // }; var _addJQueryEventFunction = function(name) { $ax.public.fn[name] = function() { //With Martin - No idea why this is necessary. We tried encapsulating the function thinking it was related to closure (above), //but that didn't fix the problem. If we don't add this Repeaters will give \"Uncaught TypeError: Object # has no method 'apply'\" //here (but Indeterminately, often on larger/slower Repeaters) because it is Undefined. However it seems the catch is never hit //if we surround the statement with the try/catch. Perhaps the try/catch block creates a scope or closure. try { $.fn[name].apply(this.jQuery(), arguments); } catch(e) { console.log(\"Couldn't find the event: \" + name); } return this; }; }; var _jQueryEventFunctionsToAdd = ['click', 'mouseenter', 'mouseleave', 'bind']; for(var jqueryEventIndex = 0; jqueryEventIndex < _jQueryEventFunctionsToAdd.length; jqueryEventIndex++) _addJQueryEventFunction(_jQueryEventFunctionsToAdd[jqueryEventIndex]); $ax.public.fn.openLink = function(url, includeVariables) { this.jQuery().each(function() { if(!($(this).is('iframe'))) { return; } var objIframe = $(this).get(0); $ax.navigate({ url: url, target: \"frame\", includeVariables: includeVariables, frame: objIframe }); }); return this; }; $ax.public.fn.SetPanelState = function(stateNumber, options, showWhenSet) { var animateInInfo = _getAnimateInfo(options && options.animateIn, 500); var animateOutInfo = _getAnimateInfo(options && options.animateOut, 500); var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; if ($ax.public.fn.IsDynamicPanel($ax.getTypeFromElementId(elementId))) { var stateName = $ax.visibility.GetPanelStateId(elementId, Number(stateNumber) - 1); var wasVisible = $ax.visibility.IsIdVisible(elementId); // If compressing because you are fit to content and the change of state may change size, must be before the change. if(options.compress && $ax.dynamicPanelManager.isIdFitToContent(elementId) && wasVisible) { $ax.dynamicPanelManager.compressDelta(elementId, $ax.visibility.GetPanelState(elementId), stateName, options.vertical, options.compressEasing, options.compressDuration); } $ax.visibility.SetPanelState(elementId, stateName, animateOutInfo.easingType, animateOutInfo.direction, animateOutInfo.duration, animateInInfo.easingType, animateInInfo.direction, animateInInfo.duration, showWhenSet); // If compressing because of a show, must be after state is set. if(options.compress && !wasVisible && showWhenSet) { $ax.dynamicPanelManager.compressToggle(elementId, options.vertical, true, options.compressEasing, options.compressDuration); } } } return this; }; $ax.public.fn.show = function(options, eventInfo) { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; var lightboxId = $ax.repeater.applySuffixToElementId(elementId, '_lightbox'); var lightbox = $jobj(lightboxId); if(options && options.showType == 'lightbox') { $ax.flyoutManager.unregisterPanel(elementId, true); // Add lightbox if there isn't one if(lightbox.length == 0) { lightbox = $(''); lightbox.attr('id', lightboxId); var color = 'rgb(' + options.lightbox.r + ',' + options.lightbox.g + ',' + options.lightbox.b + ')'; lightbox.css({ position: 'fixed', left: '0px', top: '0px', width: '10000px', height: '10000px', 'background-color': color, opacity: options.lightbox.a / 255 }); var parents = $ax('#' + elementId).getParents(true, ['dynamicPanel'])[0]; var fixedParentPanelId = undefined; for(var j = 0; j < parents.length; j++) { var parentId = parents[j]; if($jobj(parentId).css('z-index') != 'auto' || $ax.features.supports.mobile) { fixedParentPanelId = parents[j]; break; } } if(!fixedParentPanelId) $('#base').append(lightbox); else $jobj(fixedParentPanelId).append(lightbox); var wasVisible = $ax.visibility.IsIdVisible(elementId); (function(lightbox, query) { $ax.event.attachClick(lightbox, function() { $ax.action.addAnimation(elementId, $ax.action.queueTypes.fade, function() { if(!wasVisible) query.hide(); else $ax.action.fireAnimationFromQueue(elementId, $ax.action.queueTypes.fade); lightbox.remove(); }); }); })(lightbox, this); } $ax.legacy.BringToFront(lightboxId, true); $ax.legacy.BringToFront(elementId, true); } else if(options && options.showType == 'flyout') { // Remove lightbox if there is one lightbox.remove(); var src = eventInfo.thiswidget; var target = $ax.getWidgetInfo(elementId); var rects = {}; if(src.valid) rects.src = $ax.geometry.genRect(src, true); if(target.valid) rects.target = $ax.geometry.genRect(target, true); $ax.flyoutManager.registerFlyout(rects, elementId, eventInfo.srcElement); //$ax.style.AddRolloverOverride(elementId); $ax.legacy.BringToFront(elementId); } else { // Remove lightbox, unregister flyout lightbox.remove(); $ax.flyoutManager.unregisterPanel(elementId, true); } _setVisibility(elementId, true, options); } return this; }; var _getAnimateInfo = function (options, defaultDuration, useHide) { var animateInfo = { duration: options && (useHide ? options.durationHide : options.duration) || defaultDuration }; var easing = options && (useHide ? options.easingHide : options.easing) || 'none'; switch (easing) { case 'fade': animateInfo.easingType = 'fade'; animateInfo.direction = ''; break; case 'slideLeft': animateInfo.easingType = 'swing'; animateInfo.direction = 'left'; break; case 'slideRight': animateInfo.easingType = 'swing'; animateInfo.direction = 'right'; break; case 'slideUp': animateInfo.easingType = 'swing'; animateInfo.direction = 'up'; break; case 'slideDown': ; animateInfo.easingType = 'swing'; animateInfo.direction = 'down'; break; case 'flipLeft': animateInfo.easingType = 'flip'; animateInfo.direction = 'left'; break; case 'flipRight': animateInfo.easingType = 'flip'; animateInfo.direction = 'right'; break; case 'flipUp': animateInfo.easingType = 'flip'; animateInfo.direction = 'up'; break; case 'flipDown': animateInfo.easingType = 'flip'; animateInfo.direction = 'down'; break; default: animateInfo.easingType = 'none'; animateInfo.direction = ''; } return animateInfo; }; $ax.public.fn.hide = function(options) { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; // var wasShown = $ax.visibility.IsIdVisible(elementId); _setVisibility(elementId, false, options); } return this; }; $ax.public.fn.toggleVisibility = function(options) { var elementIds = this.getElementIds(); for (var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; var show = !$ax.visibility.IsIdVisible(elementId); _setVisibility(elementId, show, options, !show); } return this; }; var _setVisibility = function (elementId, value, options, useHide) { var animateInfo = _getAnimateInfo(options, 0, useHide); var wasShown = $ax.visibility.IsIdVisible(elementId); var compress = options && options.showType == 'compress' && wasShown != value; if (compress) $ax.dynamicPanelManager.compressToggle(elementId, options.vertical, value, options.compressEasing, options.compressDuration); var onComplete = function () { $ax.dynamicPanelManager.fitParentPanel(elementId); }; $ax.visibility.SetWidgetVisibility(elementId, { value: value, easing: animateInfo.easingType, direction: animateInfo.direction, duration: animateInfo.duration, fire: true, onComplete: onComplete }); if(options && options.bringToFront) $ax.legacy.BringToFront(elementId); }; $ax.public.fn.setOpacity = function(opacity, easing, duration) { if(!easing || ! duration) { easing = 'none'; duration = 0; } var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; var onComplete = function() { $ax.action.fireAnimationFromQueue(elementId, $ax.action.queueTypes.fade); }; var query = $jobj(elementId); if(duration == 0 || easing == 'none') { query.css('opacity', opacity); onComplete(); } else query.animate({ opacity: opacity }, { duration: duration, easing: easing, queue: false, complete: onComplete }); } } //move one widget. I didn't combine moveto and moveby, since this is in .public, and separate them maybe more clear for the user var _move = function (elementId, x, y, options, moveTo) { if(!options.easing) options.easing = 'none'; if(!options.duration) options.duration = 500; var obj = $obj(elementId); // Layer move using container now. if($ax.public.fn.IsLayer(obj.type)) { $ax.move.MoveWidget(elementId, x, y, options, moveTo, function () { if(options.onComplete) options.onComplete(); $ax.dynamicPanelManager.fitParentPanel(elementId); }, false); } else { var xDelta = x; var yDelta = y; if (moveTo) { var jobj = $jobj(elementId); var left = Number(jobj.css('left').replace('px', '')); var top = Number(jobj.css('top').replace('px', '')); xDelta = x - left; yDelta = y - top; } $ax.move.MoveWidget(elementId, xDelta, yDelta, options, false, function () { $ax.dynamicPanelManager.fitParentPanel(elementId); }, true); } }; $ax.public.fn.moveTo = function (x, y, options) { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { _move(elementIds[index], x, y, options, true); } return this; }; $ax.public.fn.moveBy = function (x, y, options) { var elementIds = this.getElementIds(); if(x == 0 && y == 0) { for(var i = 0; i < elementIds.length; i++) { var elementId = elementIds[i]; $ax.move.nopMove(elementId, options); //$ax.event.raiseSyntheticEvent(elementId, \"onMove\"); $ax.action.fireAnimationFromQueue(elementId, $ax.action.queueTypes.move); //if($axure.fn.IsLayer($obj(elementId).type)) { // var childrenIds = $ax.public.fn.getLayerChildrenDeep(elementId, true); // for(var j = 0; j < childrenIds.length; j++) $ax.event.raiseSyntheticEvent(childrenIds[j], 'onMove'); //} } return this; } for(var index = 0; index < elementIds.length; index++) { _move(elementIds[index], x, y, options, false); } return this; }; $ax.public.fn.circularMoveAndRotate = function(degreeChange, options, centerPointLeft, centerPointTop, doRotation, moveDelta, resizeOffset, rotatableMove, moveComplete) { if(!rotatableMove) rotatableMove = { x: 0, y: 0 }; var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; var onComplete = function () { $ax.dynamicPanelManager.fitParentPanel(elementId); if (moveComplete) moveComplete(); } $ax.move.circularMove(elementId, degreeChange, { x: centerPointLeft, y: centerPointTop }, moveDelta, rotatableMove, resizeOffset, options, true, onComplete, doRotation); if(doRotation) $ax.move.rotate(elementId, degreeChange, options.easing, options.duration, false, true, function () { $ax.dynamicPanelManager.fitParentPanel(elementId); }); else $ax.action.fireAnimationFromQueue(elementId, $ax.action.queueTypes.rotate); } }; $ax.public.fn.rotate = function (degree, easing, duration, to, axShouldFire) { var elementIds = this.getElementIds(); // this function will no longer handle compound vectors. for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; degree = parseFloat(degree); $ax.move.rotate(elementId, degree, easing, duration, to, axShouldFire, function () { $ax.dynamicPanelManager.fitParentPanel(elementId); }); } }; $ax.public.fn.resize = function(newLocationAndSizeCss, resizeInfo, axShouldFire, moves, onCompletedFunc) { var elementIds = this.getElementIds(); if(!elementIds) return; var completeAndFire = function(moved, id) { if(axShouldFire) { $ax.action.fireAnimationFromQueue(id, $ax.action.queueTypes.resize); if(moves) $ax.action.fireAnimationFromQueue(id, $ax.action.queueTypes.move); } if(onCompletedFunc) onCompletedFunc(); }; for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; var obj = $obj(elementId); if(!$ax.public.fn.IsResizable(obj.type)) { //$ax.dynamicPanelManager.fitParentPanel(elementId); completeAndFire(moves, elementId); continue; } var oldSize = $ax('#' + elementId).size(); var oldWidth = oldSize.width; var oldHeight = oldSize.height; var query = $jobj(elementId); var isDynamicPanel = $ax.public.fn.IsDynamicPanel(obj.type); if(isDynamicPanel) { // No longer fitToContent, calculate additional styling that needs to be done. $ax.dynamicPanelManager.setFitToContentCss(elementId, false, oldWidth, oldHeight); if (query.css('position') == 'fixed' && ((obj.fixedHorizontal && obj.fixedHorizontal == 'center') || (obj.fixedVertical && obj.fixedVertical == 'middle'))) { moves = true; var loc = $ax.dynamicPanelManager.getFixedPosition(elementId, oldWidth, oldHeight, newLocationAndSizeCss.width, newLocationAndSizeCss.height); if(loc) { if (loc[0] != 0 && !$ax.dynamicPanelManager.isPercentWidthPanel(obj)) newLocationAndSizeCss['margin-left'] = '+=' + (Number(newLocationAndSizeCss['margin-left'].substr(2)) + loc[0]); if (loc[1] != 0) newLocationAndSizeCss['margin-top'] = '+=' + (Number(newLocationAndSizeCss['margin-top'].substr(2)) + loc[1]); } } var onComplete = function() { $ax.flyoutManager.updateFlyout(elementId); $ax.dynamicPanelManager.fitParentPanel(elementId); $ax.dynamicPanelManager.updatePanelPercentWidth(elementId); $ax.dynamicPanelManager.updatePanelContentPercentWidth(elementId); completeAndFire(moves, elementId); $ax.event.raiseSyntheticEvent(elementId, 'onResize'); }; } else { //if contains text var textChildren = query.children('div.text'); if(textChildren && textChildren.length != 0) { var textDivId = textChildren.attr('id'); var textObj = $ax('#' + textDivId); var leftPadding = textObj.left(true); var rightPadding = oldWidth - leftPadding - textObj.width(); //greater or equal to 1px var newTextWidth = Math.max(newLocationAndSizeCss.width - leftPadding - rightPadding, 1); var textChildCss = { width: newTextWidth }; var textStepFunction = function() { //change the width of the text div may effect the height //var currentTextHeight = Number($(textChildren.children('p')[0]).css('height').replace('px', '')); //textChildren.css('height', currentTextHeight); var display = $ax.public.fn.displayHackStart(document.getElementById(textDivId)); $ax.style.updateTextAlignmentForVisibility(textDivId); $ax.public.fn.displayHackEnd(display); }; } //get all the other children that matters onComplete = function() { $ax.dynamicPanelManager.fitParentPanel(elementId); completeAndFire(moves, elementId); $ax.annotation.adjustIconLocation(elementId); $ax.event.raiseSyntheticEvent(elementId, 'onResize'); }; } var children = query.children().not('div.text'); while(children && children.length && $(children[0]).attr('id').indexOf('container') != -1) { children = children.children().not('div.text'); } if(children && children.length !== 0) { var childAnimationArray = []; var isConnector = $ax.public.fn.IsConnector(obj.type); children.each(function (i, child) { var childCss = { width: newLocationAndSizeCss.width, height: newLocationAndSizeCss.height }; //$ax.size() use outerWidth/Height(false), which include padding and borders(no margins) var childSizingObj = $ax('#' + child.id).size(); var differentSizedImage = childSizingObj.width - oldWidth != 0 || childSizingObj.height - oldHeight != 0; if ((differentSizedImage || isConnector) && child.tagName == 'IMG') { //oldwidth is zero for connectors var widthOffset = oldWidth ? (childSizingObj.width - oldWidth) * newLocationAndSizeCss.width / oldWidth : childSizingObj.width; var heightOffset = oldHeight ? (childSizingObj.height - oldHeight) * newLocationAndSizeCss.height / oldHeight : childSizingObj.height; childCss.width += widthOffset; childCss.height += heightOffset; } //there are elements like inputs, come with a padding and border, so need to use outerwidth for starting point, due to jquery 1.7 css() on width/height bugs if($(child).css('position') === 'absolute') { if(child.offsetLeft) { childSizingObj.left = child.offsetLeft; childCss.left = oldWidth ? child.offsetLeft * newLocationAndSizeCss.width / oldWidth : child.offsetLeft; //- transformedShift.x; } if(child.offsetTop) { childSizingObj.top = child.offsetTop; childCss.top = oldHeight ? child.offsetTop * newLocationAndSizeCss.height / oldHeight : child.offsetTop; //- transformedShift.y; } } childAnimationArray.push({ obj: child, sizingObj: childSizingObj, sizingCss: childCss }); }); } if(!resizeInfo.easing || resizeInfo.easing == 'none') { query.animate(newLocationAndSizeCss, 0); if(childAnimationArray) { $(childAnimationArray).each(function (i, animationObj) { if(animationObj.resizeMatrixFunction) { $(animationObj.obj).css($ax.public.fn.setTransformHowever(animationObj.resizeMatrixFunction(animationObj.width, animationObj.height))); } else { $(animationObj.obj).animate(animationObj.sizingCss, 0); } }); } //if(childCss) children.animate(childCss, 0); //if(sketchyImage && sketchyImageCss) $(sketchyImage).animate(sketchyImageCss, 0); if(textChildCss) { textChildren.animate(textChildCss, { duration: 0, step: textStepFunction }); } onComplete(); } else { if(childAnimationArray) { $(childAnimationArray).each(function (i, animationObj) { if(animationObj.resizeMatrixFunction) { $(animationObj.sizingObj).animate(animationObj.sizingCss, { queue: false, duration: resizeInfo.duration, easing: resizeInfo.easing, step: function (now) { var widthRatio = (animationObj.width - 1.0) * now + 1.0; var heightRatio = (animationObj.height - 1.0) * now + 1.0; $(animationObj.obj).css($ax.public.fn.setTransformHowever(animationObj.resizeMatrixFunction(widthRatio, heightRatio))); } }); } else { $(animationObj.sizingObj).animate(animationObj.sizingCss, { queue: false, duration: resizeInfo.duration, easing: resizeInfo.easing, step: function (now, tween) { $(animationObj.obj).css(tween.prop, now); } }); } }); } if(textChildCss) { textChildren.animate(textChildCss, { queue: false, duration: resizeInfo.duration, easing: resizeInfo.easing, step: textStepFunction }); } if(isDynamicPanel) { query.animate(newLocationAndSizeCss, { queue: false, duration: resizeInfo.duration, easing: resizeInfo.easing, complete: onComplete }); } else { var locObj = { left: $ax.public.fn.GetFieldFromStyle(query, 'left'), top: $ax.public.fn.GetFieldFromStyle(query, 'top'), width: $ax.public.fn.GetFieldFromStyle(query, 'width'), height: $ax.public.fn.GetFieldFromStyle(query, 'height'), }; $(locObj).animate(newLocationAndSizeCss, { queue: false, duration: resizeInfo.duration, easing: resizeInfo.easing, step: function (now, tween) { query.css(tween.prop, now); }, complete: onComplete }); } } } }; $ax.public.fn.bringToFront = function() { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { $ax.legacy.BringToFront(elementIds[index]); } return this; }; $ax.public.fn.sendToBack = function() { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { $ax.legacy.SendToBack(elementIds[index]); } return this; }; $ax.public.fn.text = function() { if(arguments[0] == undefined) { var firstId = this.getElementIds()[0]; if(!firstId) { return undefined; } return getWidgetText(firstId); } else { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var currentItem = elementIds[index]; var widgetType = $ax.getTypeFromElementId(currentItem); if($ax.public.fn.IsTextBox(widgetType) || $ax.public.fn.IsTextArea(widgetType)) { //For non rtf SetWidgetFormText(currentItem, arguments[0]); } else { var idRtf = '#' + currentItem; if($(idRtf).length == 0) idRtf = '#u' + (Number(currentItem.substring(1)) + 1); if($(idRtf).length != 0) { //If the richtext div already has some text in it, //preserve only the first style and get rid of the rest //If no pre-existing p-span tags, don't do anything if($(idRtf).find('p').find('span').length > 0) { $(idRtf).find('p:not(:first)').remove(); $(idRtf).find('p').find('span:not(:first)').remove(); //Replace new-lines with NEWLINE token, then html encode the string, //finally replace NEWLINE token with linebreak var textWithLineBreaks = arguments[0].replace(/\\n/g, '--NEWLINE--'); var textHtml = $('').text(textWithLineBreaks).html(); $(idRtf).find('span').html(textHtml.replace(/--NEWLINE--/g, '')); } } } } return this; } }; var getWidgetText = function(id) { var idQuery = $jobj(id); var inputQuery = $jobj($ax.INPUT(id)); if(inputQuery.length) idQuery = inputQuery; if (idQuery.is('input') && ($ax.public.fn.IsCheckBox(idQuery.attr('type')) || idQuery.attr('type') == 'radio')) { idQuery = idQuery.parent().find('label').find('div'); } if(idQuery.is('div')) { var $rtfObj = idQuery.hasClass('text') ? idQuery : idQuery.find('.text'); if($rtfObj.length == 0) return ''; var textOut = ''; $rtfObj.children('p').each(function(index) { if(index != 0) textOut += '\\n'; var htmlContent = $(this).html(); if(isSoloBr(htmlContent)) return; // It has a solo br, then it was just put in for a newline, and paragraph already added the new line. //Replace line breaks (set in SetWidgetRichText) with newlines and nbsp's with regular spaces. htmlContent = htmlContent.replace(/]*>/ig, '\\n').replace(/&nbsp;/ig, ' '); textOut += $(htmlContent).text(); }); return textOut; } else { var val = idQuery.val(); return val == undefined ? '' : val; } }; var isSoloBr = function(html) { html = $(html); // Html needs one and only one span var spanChildren = html.length == 1 && html.is('span') ? html.children() : false; // Span children needs exactly one br and no text in the span return spanChildren && spanChildren.length == 1 && spanChildren.is('br') && spanChildren.text().trim() == ''; }; $ax.public.fn.setRichTextHtml = function() { if(arguments[0] == undefined) { //No getter function, so just return undefined return undefined; } else { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var currentItem = elementIds[index]; var widgetType = $ax.getTypeFromElementId(currentItem); if ($ax.public.fn.IsTextBox(widgetType) || $ax.public.fn.IsTextArea(widgetType)) { //Do nothing for non rtf continue; } else { //TODO -- [mas] fix this! var idRtf = '#' + currentItem; if($(idRtf).length == 0) idRtf = '#u' + (parseInt(currentItem.substring(1)) + 1); if($(idRtf).length != 0) SetWidgetRichText(idRtf, arguments[0]); } } return this; } }; $ax.public.fn.value = function() { if(arguments[0] == undefined) { var firstId = this.getElementIds()[0]; if(!firstId) { return undefined; } var widgetType = $ax.getTypeFromElementId(firstId); if ($ax.public.fn.IsComboBox(widgetType) || $ax.public.fn.IsListBox(widgetType)) { //for select lists and drop lists return $('#' + firstId + ' :selected').text(); } else if ($ax.public.fn.IsCheckBox(widgetType) || $ax.public.fn.IsRadioButton(widgetType)) { //for radio/checkboxes return $('#' + firstId + '_input').is(':checked'); } else if ($ax.public.fn.IsTextBox(widgetType)) { //for text box return $('#' + firstId + '_input').val(); } else { //for text based form elements return this.jQuery().first().val(); } } else { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var widgetType = $ax.getTypeFromElementId(elementIds[index]); var elementIdQuery = $('#' + elementIds[index]); if ($ax.public.fn.IsCheckBox(widgetType) || $ax.public.fn.IsRadioButton(widgetType)) { //for radio/checkboxes if(arguments[0] == true) { elementIdQuery.attr('checked', true); } else if(arguments[0] == false) { elementIdQuery.removeAttr('checked'); } } else { //For select lists, drop lists, text based form elements elementIdQuery.val(arguments[0]); } } return this; } }; $ax.public.fn.checked = function() { if(arguments[0] == undefined) { return this.selected(); } else { this.selected(arguments[0]); return this; } }; var _getRelativeLeft = function (id, parent) { var currentNode = window.document.getElementById(id).offsetParent; var left = $ax('#' + id).left(true); while (currentNode != null && currentNode.tagName != \"BODY\" && currentNode != parent) { left += currentNode.offsetLeft; currentNode = currentNode.offsetParent; } return left; }; var _getRelativeTop = function(id, parent) { var currentNode = window.document.getElementById(id).offsetParent; var top = $ax('#' + id).top(true); while(currentNode != null && currentNode.tagName != \"BODY\" && currentNode != parent) { top += currentNode.offsetTop; currentNode = currentNode.offsetParent; } return top; }; var _scrollHelper = function(id, scrollX, scrollY, easing, duration) { var target = window.document.getElementById(id); var scrollable = $ax.legacy.GetScrollable(target); var targetLeft = _getRelativeLeft(id, scrollable); var targetTop = _getRelativeTop(id, scrollable); if(!scrollX) targetLeft = scrollable.scrollLeft; if(!scrollY) targetTop = scrollable.scrollTop; var $scrollable = $(scrollable); if($scrollable.is('body')) { $scrollable = $('html,body'); } if(easing == 'none') { if(scrollY) $scrollable.scrollTop(targetTop); if(scrollX) $scrollable.scrollLeft(targetLeft); } else { if(!scrollX) { $scrollable.animate({ scrollTop: targetTop }, duration, easing); } else if(!scrollY) { $scrollable.animate({ scrollLeft: targetLeft }, duration, easing); } else { $scrollable.animate({ scrollTop: targetTop, scrollLeft: targetLeft }, duration, easing); } } }; $ax.public.fn.scroll = function(scrollOption) { var easing = 'none'; var duration = 500; if(scrollOption && scrollOption.easing) { easing = scrollOption.easing; if(scrollOption.duration) { duration = scrollOption.duration; } } var scrollX = true; var scrollY = true; if(scrollOption.direction == 'vertical') { scrollX = false; } else if(scrollOption.direction == 'horizontal') { scrollY = false; } var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { // if($ax.getTypeFromElementId(elementIds[index]) == IMAGE_MAP_REGION_TYPE) { _scrollHelper(elementIds[index], scrollX, scrollY, easing, duration); // } } return this; }; $ax.public.fn.enabled = function() { if(arguments[0] == undefined) { var firstId = this.getElementIds()[0]; if(!firstId) return undefined; var widgetType = $ax.getTypeFromElementId(firstId); if ($ax.public.fn.IsImageBox(widgetType) || $ax.public.fn.IsVector(widgetType)) return !$ax.style.IsWidgetDisabled(firstId); else return this.jQuery().first().not(':disabled').length > 0; } else { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; var widgetType = $ax.getTypeFromElementId(elementId); var enabled = arguments[0]; if ($ax.public.fn.IsImageBox(widgetType) || $ax.public.fn.IsVector(widgetType)) $ax.style.SetWidgetEnabled(elementId, enabled); if ($ax.public.fn.IsDynamicPanel(widgetType) || $ax.public.fn.IsLayer(widgetType)) { $ax.style.SetWidgetEnabled(elementId, enabled); var children = this.getChildren(false, true)[index].children; for(var i = 0; i < children.length; i++) { $axure('#' + children[i]).enabled(enabled); } } var obj = $obj(elementId); var images = obj.images; if(PLAIN_TEXT_TYPES.indexOf(widgetType) != -1 && images) { var img = $jobj($ax.repeater.applySuffixToElementId(elementId, '_image_sketch')); var key = (enabled ? 'normal~' : 'disabled~') + ($ax.adaptive.currentViewId || ''); img.attr('src', images[key]); } var jobj = $jobj(elementId); var input = $jobj($ax.INPUT(elementId)); if(input.length) jobj = input; if (OS_MAC && WEBKIT && $ax.public.fn.IsComboBox(widgetType)) jobj.css('color', enabled ? '' : 'grayText'); if(enabled) jobj.removeAttr('disabled'); else jobj.attr('disabled', 'disabled'); } return this; } }; $ax.public.fn.visible = function() { var ids = this.getElementIds(); for(var index = 0; index < ids.length; index++) $ax.visibility.SetIdVisible(ids[index], arguments[0]); return this; }; $ax.public.fn.selected = function() { if(arguments[0] == undefined) { var firstId = this.getElementIds()[0]; if(!firstId) return undefined; var widgetType = $ax.getTypeFromElementId(firstId); if ($ax.public.fn.IsTreeNodeObject(widgetType)) { var treeNodeButtonShapeId = ''; var allElementIds = $ax.getAllElementIds(); for(var i = 0; i < allElementIds.length; i++) { var elementId = allElementIds[i]; var currObj = $ax.getObjectFromElementId(elementId); if ($ax.public.fn.IsVector(currObj.type) && currObj.parent && currObj.parent.scriptIds && currObj.parent.scriptIds[0] == firstId) { treeNodeButtonShapeId = elementId; break; } } if(treeNodeButtonShapeId == '') return undefined; return $ax.style.IsWidgetSelected(treeNodeButtonShapeId); } else if ($ax.public.fn.IsImageBox(widgetType) || $ax.public.fn.IsVector(widgetType) || $ax.public.fn.IsTableCell(widgetType) || $ax.public.fn.IsDynamicPanel(widgetType) || $ax.public.fn.IsLayer(widgetType)) { return $ax.style.IsWidgetSelected(firstId); } else if ($ax.public.fn.IsCheckBox(widgetType) || $ax.public.fn.IsRadioButton(widgetType)) { return $jobj($ax.INPUT(firstId)).prop('checked'); } return this; } var elementIds = this.getElementIds(); var func = typeof (arguments[0]) === 'function' ? arguments[0] : null; var enabled = arguments[0]; // If this is a function it will be overridden with the return value; for(var index = 0; index < elementIds.length; index++) { var elementId = elementIds[index]; if(func) { enabled = func($axure('#' + elementId)); } var widgetType = $ax.getTypeFromElementId(elementId); if ($ax.public.fn.IsTreeNodeObject(widgetType)) { //for tree node var treeRootId = $('#' + elementIds[index]).parents('.treeroot').attr('id'); var treeNodeButtonShapeId = ''; var childElementIds = $jobj(elementId).children(); for(var i = 0; i < childElementIds.length; i++) { var elementId = childElementIds[i].id; var currObj = $ax.getObjectFromElementId(elementId); if (currObj && currObj.type == $ax.constants.VECTOR_SHAPE_TYPE && currObj.parent && currObj.parent.scriptIds && currObj.parent.scriptIds[0] == elementIds[index]) { treeNodeButtonShapeId = elementId; break; } } if(treeNodeButtonShapeId == '') continue; $ax.tree.SelectTreeNode(elementId, enabled); } else if ($ax.public.fn.IsImageBox(widgetType) || $ax.public.fn.IsVector(widgetType) || $ax.public.fn.IsVector(widgetType) || $ax.public.fn.IsTableCell(widgetType) || $ax.public.fn.IsDynamicPanel(widgetType) || $ax.public.fn.IsLayer(widgetType)) { $ax.style.SetWidgetSelected(elementIds[index], enabled); } else if ($ax.public.fn.IsCheckBox(widgetType) || $ax.public.fn.IsRadioButton(widgetType)) { var query = $jobj($ax.INPUT(elementId)); var curr = query.prop('checked'); //NOTE: won't fire onselect nore onunselect event if states didn't changes if(curr != enabled) { query.prop('checked', enabled); $ax.event.TryFireCheckChanged(elementId, enabled); } } } return this; }; $ax.public.fn.focus = function() { var firstId = this.getElementIds()[0]; var focusableId = $ax.event.getFocusableWidgetOrChildId(firstId); $('#' + focusableId).focus(); return this; }; $ax.public.fn.expanded = function() { if(arguments[0] == undefined) { var firstId = this.getElementIds()[0]; return firstId && !$ax.public.fn.IsTreeNodeObject($ax.getTypeFromElementId(firstId)) && $ax.visibility.IsIdVisible(firstId + '_children'); } else { var elementIds = this.getElementIds(); for(var index = 0; index < elementIds.length; index++) { if ($ax.public.fn.IsTreeNodeObject($ax.getTypeFromElementId(elementIds[index]))) { var treeNodeId = elementIds[index]; var childContainerId = treeNodeId + '_children'; var scriptId = $ax.repeater.getScriptIdFromElementId(treeNodeId); var itemId = $ax.repeater.getItemIdFromElementId(treeNodeId); var plusMinusId = 'u' + (parseInt(scriptId.substring(1)) + 1); if(itemId) plusMinusId = $ax.repeater.createElementId(plusMinusId, itemId); if($('#' + childContainerId).length == 0 || !$jobj(plusMinusId).children().first().is('img')) plusMinusId = ''; if(arguments[0] == true) { $ax.tree.ExpandNode(treeNodeId, childContainerId, plusMinusId); } else if(arguments[0] == false) { $ax.tree.CollapseNode(treeNodeId, childContainerId, plusMinusId); } } } return this; } }; $ax.public.fn.size = function () { var firstId = this.getElementIds()[0]; if(!firstId) return undefined; var object = $ax.getObjectFromElementIdDisregardHex(firstId); if(object && (object.type == 'layer' || object.generateCompound)) { var boundingRect = $ax.public.fn.getWidgetBoundingRect(firstId); return { width: boundingRect.width, height: boundingRect.height }; } var firstIdObject = $jobj(firstId); var trap = _displayWidget($ax.repeater.removeSuffixFromElementId(firstId)); var size = { width: firstIdObject.outerWidth(), height: firstIdObject.outerHeight() }; trap(); return size; }; $ax.public.fn.width = function() { var firstId = this.getElementIds()[0]; if(!firstId) return undefined; var object = $ax.getObjectFromElementIdDisregardHex(firstId); if (object && (object.type == 'layer' || object.generateCompound)) { var boundingRect = $ax.public.fn.getWidgetBoundingRect(firstId); return boundingRect.width; } var firstIdObject = $jobj(firstId); return firstIdObject.outerWidth(); }; $ax.public.fn.height = function() { var firstId = this.getElementIds()[0]; if(!firstId) return undefined; var object = $ax.getObjectFromElementIdDisregardHex(firstId); if (object && (object.type == 'layer' || object.generateCompound)) { var boundingRect = $ax.public.fn.getWidgetBoundingRect(firstId); return boundingRect.height; } var firstIdObject = $jobj(firstId); return firstIdObject.outerHeight(); }; $ax.public.fn.readAttribute = function(object, attribute) { if(object && object.hasAttribute(attribute)) { return object.getAttribute(attribute); } return null; }; $ax.public.fn.locRelativeIgnoreLayer = function (vert) { var elementId = this.getElementIds()[0]; if(!elementId) return undefined; var parents = this.getParents(true, '*')[0]; for(var i = 0; i < parents.length; i++) { var type = $ax.getTypeFromElementId(parents[i]); if(!$axure.fn.IsLayer(type) && !$axure.fn.IsReferenceDiagramObject(type)) { var func = vert ? _getRelativeTop : _getRelativeLeft; return func(elementId, $jobj(parents[i])[0]); } } var axThis = $ax('#' + elementId); return vert ? axThis.top() : _bodyToWorld(axThis.left(), true); }; var _bodyToWorld = $axure.fn.bodyToWorld = function(x, from) { var body = $('body'); if (body.css('position') != 'relative') return x; var offset = (Number(body.css('left').replace('px', '')) + Math.max(0, ($(window).width() - body.width()) / 2)); if(from) offset *= -1; return x + offset; } $ax.public.fn.left = function (relative) { var firstId = this.getElementIds()[0]; if(!firstId) return undefined; var left = _getLoc(firstId, false, false, relative); // If you are absolute, unless your are a pinned panel... if(relative || $obj(firstId) && $obj(firstId).fixedVertical) return left; // ... or you are in one... var parentPanels = $ax('#' + firstId).getParents(true, 'dynamicPanel')[0]; for(var i = 0; i < parentPanels.length; i++) if ($obj(parentPanels[i]).fixedVertical) return left; // ... you must convert from body to world coordinates return _bodyToWorld(left); }; $ax.public.fn.top = function(relative) { var firstId = this.getElementIds()[0]; return firstId && _getLoc(firstId, true, false, relative); }; var _getLoc = function(id, vert, high, relative) { var mathFunc = high ? 'max' : 'min'; var prop = vert ? 'top' : 'left'; var dim = vert ? 'height' : 'width'; var obj = $jobj(id); var strippedId = $ax.repeater.removeSuffixFromElementId(id); var axObj = $obj(strippedId); var oldDisplay = obj.css('display'); var displaySet = false; if(oldDisplay == 'none') { obj.css('display', ''); displaySet = true; } var loc = Math.NaN; var rdo = axObj.type == $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE; if (!rdo) loc = $ax.getNumFromPx(obj.css(prop)); var fixed = _fixedOffset(id, vert); if(fixed.valid) loc = !vert && fixed.fullWidth ? 0 : fixed.offset; else if (!relative) { var parents = []; var parObj = id.indexOf('text') != -1 ? axObj : axObj.parent; // When working with text id, parent widget is the ax obj we are dealing with, so that should be the first parent while($ax.public.fn.IsContainer(parObj.type)) { parents.push($ax.getScriptIdFromPath([parObj.id], strippedId)); parObj = parObj.parent; } var otherParents = $ax('#' + id).getParents(true, ['item', 'repeater', 'dynamicPanel', 'layer'])[0]; for(var i = 0; i < otherParents.length; i++) { parents.push(otherParents[i]); } for(var i = 0; i < parents.length; i++) { var parentId = $ax.visibility.getWidgetFromContainer(parents[i]); var parent = $ax.visibility.applyWidgetContainer(parentId, true); // Layer may not have container, and will be at 0,0 otherwise. if (!parent.length) continue; fixed = _fixedOffset(parentId, vert); if(fixed.valid) { loc += fixed.offset; break; // If fixed ignore any parents if there are any, they don't matter. } else loc += $ax.getNumFromPx(parent.css(prop)); } } if (high) loc += obj[dim](); // Special Layer code if (axObj.type == 'layer') { // If layer has a container, then use that. Otherwise must deal with children. Children can move in container after created, but ignoring for now. var container = $ax.visibility.applyWidgetContainer(id, true, true); if(container.length) loc += $ax.getNumFromPx(container.css(prop)); else loc += (_getChildLoc(axObj.objs, vert, high, dim, true, id) || 0); } if(displaySet) obj.css('display', oldDisplay); return loc; }; var _getChildLoc = function (children, vert, high, dim, root, path, itemId) { if (typeof (path) == 'string') { itemId = $ax.repeater.getItemIdFromElementId(path); path = $ax.getPathFromScriptId(path); path.pop(); // Remove object id, only want rdo path. } var mathFunc = high ? 'max' : 'min'; var childLoc = NaN; for (var i = 0; i < children.length; i++) { var childObj = children[i]; var childId = $ax.getElementIdFromPath([childObj.id], { relativeTo: path }); if (!childId) continue; childId = $ax.repeater.createElementId(childId, itemId); if($ax.public.fn.IsReferenceDiagramObject(childObj.type)) { path.push(childObj.id); var childProp = _getChildLoc($ax.pageData.masters[$obj(childId).masterId].diagram.objects, vert, high, dim, false, path, itemId); path.pop(); if(isNaN(childProp)) continue; } else if($ax.public.fn.IsLayer(childObj.type)) { childProp = _getChildLoc(childObj.objs, vert, high, dim, false, path, itemId); } else { if(!$ax.visibility.IsIdVisible(childId)) continue; childProp = $ax('#' + childId).locRelativeIgnoreLayer(vert); if(high) childProp += $jobj(childId)[dim](); } if(isNaN(childLoc)) childLoc = childProp; else if(!isNaN(childProp)) childLoc = Math[mathFunc](childLoc, childProp); } return root && isNaN(childLoc) ? 0 : childLoc; }; var _fixedOffset = function (id, vert) { var axObj = $obj(id); //I think this is only for pinned panels? So why are we coming through here for rtps? if(!axObj) return { valid: false }; var dim = vert ? 'height' : 'width'; var alignment = axObj['fixed' + (vert ? 'Vertical' : 'Horizontal')]; if(!alignment) return { valid: false }; var loc = 0; // TODO: This returns 0 for width/height it or any parent is display none. Similar issue when using axquery width/height // TODO: Look into replacing this with axquery width/height and fixing that to use this hack. Potentially want to make js generic trapper. var trap = _displayWidget(id); var query = $jobj(id); var objSize = query[dim](); trap(); if(alignment == 'center' || alignment == 'middle') { loc = $ax.getNumFromPx(query.css('margin-' + (vert ? 'top' : 'left'))); loc += ($(window)[dim]()) / 2; } else if(alignment == 'bottom' || alignment == 'right') { loc = $ax.getNumFromPx(query.css(vert ? 'bottom' : 'right')); loc = $(window)[dim]() - objSize - loc; // subract loc because margin here moves farther left/up as it gets bigger. } else { loc = $ax.getNumFromPx(query.css(vert ? 'top' : 'left')); } var scrollKey = 'scroll' + (vert ? 'Top' : 'Left'); return { offset: $(window)[scrollKey]() + loc, valid: true, fullWidth: axObj.percentWidth == 1 }; }; var _displayWidget = function(id) { var parents = $ax('#' + id).getParents(true, '*')[0]; parents.push(id); // also need to show self var displayed = []; for(var i = 0; i < parents.length; i++) { var currId = parents[i]; var currObj = $jobj(currId); if(currObj.css('display') == 'none') { currObj.css('display', 'block'); displayed.push(currId); } } return function() { for(var i = 0; i < displayed.length; i++) { $jobj(displayed[i]).css('display', 'none'); } }; } }); //***** doc.js *****// $axure.internal(function($ax) { var _pageData; var _initializePageFragment = function(pageFragment, objIdToObject) { var objectArrayHelper = function(objects, parent) { for(var i = 0; i < objects.length; i++) { diagramObjectHelper(objects[i], parent); } }; var diagramObjectHelper = function(diagramObject, parent) { $ax.initializeObject('diagramObject', diagramObject); objIdToObject[pageFragment.packageId + '~' + diagramObject.id] = diagramObject; diagramObject.parent = parent; diagramObject.owner = pageFragment; diagramObject.scriptIds = []; if(diagramObject.diagrams) { //dynamic panel for(var i = 0; i < diagramObject.diagrams.length; i++) { var diagram = diagramObject.diagrams[i]; objectArrayHelper(diagram.objects, diagram); } } else if($ax.public.fn.IsLayer(diagramObject.type)) { var layerObjs = diagramObject.objs; objectArrayHelper(layerObjs, parent); } if(diagramObject.objects) objectArrayHelper(diagramObject.objects, diagramObject); }; objectArrayHelper(pageFragment.diagram.objects, pageFragment.diagram); }; var _initalizeStylesheet = function(stylesheet) { var stylesById = {}; var customStyles = stylesheet.customStyles; for(var key in customStyles) { var style = customStyles[key]; stylesById[style.id] = style; } var duplicateStyles = stylesheet.duplicateStyles; for(var duplicateKey in duplicateStyles) { stylesById[duplicateKey] = stylesById[duplicateStyles[duplicateKey]]; } stylesheet.stylesById = stylesById; }; var _initializeDocumentData = function() { _initalizeStylesheet($ax.document.stylesheet); }; var _initializePageData; // ******* Dictionaries ******** // (function() { var scriptIdToParentLayer = {}; var elementIdToObject = {}; var scriptIdToObject = {}; var scriptIdToRepeaterId = {}; var repeaterIdToScriptIds = {}; var repeaterIdToItemIds = {}; var scriptIdToPath = {}; var _scriptIds = []; var elementIdToText = {}; var radioGroupToSelectedElementId = {}; _initializePageData = function() { if(!_pageData || !_pageData.page || !_pageData.page.diagram) return; var objIdToObject = {}; _initializePageFragment(_pageData.page, objIdToObject); for(var masterId in _pageData.masters) { var master = _pageData.masters[masterId]; _initializePageFragment(master, objIdToObject); } var _pathsToScriptIds = []; _pathToScriptIdHelper(_pageData.objectPaths, [], _pathsToScriptIds, scriptIdToPath); for(var i = 0; i < _pathsToScriptIds.length; i++) { var path = _pathsToScriptIds[i].idPath; var scriptId = _pathsToScriptIds[i].scriptId; var packageId = _pageData.page.packageId; if(path.length > 1) { for(var j = 0; j < path.length - 1; j++) { var rdoId = path[j]; var rdo = objIdToObject[packageId + '~' + rdoId]; packageId = rdo.masterId; } } var diagramObject = objIdToObject[packageId + '~' + path[path.length - 1]]; diagramObject.scriptIds[diagramObject.scriptIds.length] = scriptId; scriptIdToObject[scriptId] = diagramObject; _scriptIds[_scriptIds.length] = scriptId; } // Now map scriptIds to repeaters and layers var mapScriptIdToRepeaterId = function(scriptId, repeaterId) { scriptIdToRepeaterId[scriptId] = repeaterId; var scriptIds = repeaterIdToScriptIds[repeaterId]; if(scriptIds) scriptIds[scriptIds.length] = scriptId; else repeaterIdToScriptIds[repeaterId] = [scriptId]; }; var mapScriptIdToLayerId = function(obj, layerId, path) { var pathCopy = $ax.deepCopy(path); pathCopy[path.length] = obj.id; var scriptId = $ax.getScriptIdFromPath(pathCopy); scriptIdToParentLayer[scriptId] = layerId; } var mapIdsToRepeaterAndLayer = function(path, objs, repeaterId) { var pathCopy = $ax.deepCopy(path); for(var i = 0; i < objs.length; i++) { var obj = objs[i]; pathCopy[path.length] = obj.id; var scriptId = $ax.getScriptIdFromPath(pathCopy); // Rdo have no element on page and are not mapped to the repeater if(repeaterId) mapScriptIdToRepeaterId(scriptId, repeaterId); if($ax.public.fn.IsDynamicPanel(obj.type)) { for(var j = 0; j < obj.diagrams.length; j++) mapIdsToRepeaterAndLayer(path, obj.diagrams[j].objects, repeaterId); } else if($ax.public.fn.IsReferenceDiagramObject(obj.type)) { mapIdsToRepeaterAndLayer(pathCopy, $ax.pageData.masters[obj.masterId].diagram.objects, repeaterId); } else if($ax.public.fn.IsRepeater(obj.type)) { mapScriptIdToRepeaterId(scriptId, scriptId); mapIdsToRepeaterAndLayer(path, obj.objects, scriptId); } else if($ax.public.fn.IsLayer(obj.type)) { var layerObjs = obj.objs; for(var j = 0; j < layerObjs.length; j++) { mapScriptIdToLayerId(layerObjs[j], scriptId, path); } mapIdsToRepeaterAndLayer(path, layerObjs, repeaterId); } else if(obj.objects && obj.objects.length) { if(repeaterId) { for(var j = 0; j < obj.objects.length; j++) { mapIdsToRepeaterAndLayer(path, obj.objects, repeaterId); } } } } }; mapIdsToRepeaterAndLayer([], $ax.pageData.page.diagram.objects); }; $ax.getPathFromScriptId = function(scriptId) { var reversedPath = []; var path = scriptIdToPath[scriptId]; while(path && path.uniqueId) { reversedPath[reversedPath.length] = path.uniqueId; path = path.parent; } return reversedPath.reverse(); }; var _getScriptIdFromFullPath = function(path) { var current = $ax.pageData.objectPaths; for(var i = 0; i < path.length; i++) { current = current[path[i]]; if(!current) return current; } return current && current.scriptId; }; var _getScriptIdFromPath = function(path, relativeTo) { var relativePath = []; var includeMasterInPath = false; if(relativeTo) { var relativeToScriptId; if(relativeTo.srcElement) { //this is eventInfo relativeToScriptId = $ax.repeater.getScriptIdFromElementId(relativeTo.srcElement); includeMasterInPath = relativeTo.isMasterEvent; } else if(typeof relativeTo === 'string') { //this is an element id relativeToScriptId = relativeTo; } if(relativeToScriptId) { relativePath = $ax.getPathFromScriptId(relativeToScriptId); if(!includeMasterInPath) relativePath = relativePath.slice(0, relativePath.length - 1); } else if(relativeTo instanceof Array) { //this is a path relativePath = relativeTo; } } var fullPath = relativePath.concat(path); var scriptId = _getScriptIdFromFullPath(fullPath); return !$ax.visibility.isScriptIdLimbo(scriptId) && scriptId; }; $ax.getScriptIdFromPath = _getScriptIdFromPath; var _getElementIdsFromPath = function(path, eventInfo) { var scriptId = _getScriptIdFromPath(path, eventInfo); if(!scriptId) return []; // Don't need placed check hear. If unplaced, scriptId will be undefined and exit out before here. return $ax.getElementIdsFromEventAndScriptId(eventInfo, scriptId); }; $ax.getElementIdsFromPath = _getElementIdsFromPath; var _getElementIdFromPath = function(path, params) { var scriptId = _getScriptIdFromPath(path, params.relativeTo); if(!scriptId) return scriptId; var itemNum = params.itemNum; if(params.relativeTo && typeof params.relativeTo === 'string') { if($jobj(params.relativeTo)) itemNum = $ax.repeater.getItemIdFromElementId(params.relativeTo); } return $ax.repeater.createElementId(scriptId, itemNum); }; $ax.getElementIdFromPath = _getElementIdFromPath; var _getElementsIdFromEventAndScriptId = function(eventInfo, scriptId) { var itemId = eventInfo && $ax.repeater.getItemIdFromElementId(eventInfo.srcElement); var target = false; // Try to get itemId from target if you can't get it from source. if(!itemId) { itemId = eventInfo && eventInfo.targetElement && $ax.repeater.getItemIdFromElementId(eventInfo.targetElement); if(itemId) target = true; } var parentRepeater = $ax.getParentRepeaterFromScriptId(scriptId); if(parentRepeater && scriptId != parentRepeater) { if(itemId && (!eventInfo || parentRepeater == $ax.getParentRepeaterFromScriptId($ax.repeater.getScriptIdFromElementId(target ? eventInfo.targetElement : eventInfo.srcElement)))) { return [$ax.repeater.createElementId(scriptId, itemId)]; } var elementIds = []; var itemIds = $ax.getItemIdsForRepeater(parentRepeater); if(!itemIds) return []; for(var i = 0; i < itemIds.length; i++) elementIds[i] = $ax.repeater.createElementId(scriptId, itemIds[i]); return elementIds; } return [scriptId]; }; $ax.getElementIdsFromEventAndScriptId = _getElementsIdFromEventAndScriptId; var _getSrcElementIdFromEvent = function(event) { var currentQuery = $(event.srcElement || event.target); while(currentQuery && currentQuery.length && (!$obj(currentQuery.attr('id')) || $jobj(currentQuery.attr('id')).hasClass('text'))) { currentQuery = currentQuery.parent(); }; return currentQuery.attr('id'); }; $ax.getSrcElementIdFromEvent = _getSrcElementIdFromEvent; var _getEventInfoFromEvent = function(event, skipShowDescriptions, elementId) { var eventInfo = {}; eventInfo.srcElement = elementId; eventInfo.now = new Date(); if(event != null) { //elementId can be empty string, so can't simple use \"or\" assignment here. eventInfo.srcElement = elementId || elementId == '' ? elementId : _getSrcElementIdFromEvent(event); eventInfo.which = event.which; // When getting locations in mobile, need to extract the touch object to get the mouse location attributes var mouseEvent = (event.originalEvent && event.originalEvent.changedTouches && event.originalEvent.changedTouches[0]) || event.originalEvent; if(mouseEvent && !mouseEvent.type) mouseEvent.type = event.type; if(skipShowDescriptions) eventInfo.skipShowDescriptions = true; // Always update mouse location if possible $ax.event.updateMouseLocation(mouseEvent); } // Always set event info about cursor var _cursor = eventInfo.cursor = {}; _cursor.x = $ax.mouseLocation.x; _cursor.y = $ax.mouseLocation.y; var body = $('body'); if(body.css('position') == 'relative') { _cursor.x -= (Number(body.css('left').replace('px', '')) + Math.max(0, ($(window).width() - body.width()) / 2)); } eventInfo.pageX = _cursor.x + 'px'; eventInfo.pageY = _cursor.y + 'px'; // Do Keyboard Info eventInfo.keyInfo = $ax.event.keyState(); eventInfo.window = _getWindowInfo(); eventInfo.thiswidget = _getWidgetInfo(eventInfo.srcElement); eventInfo.item = _getItemInfo(eventInfo.srcElement); eventInfo.dragInfo = $ax.drag.GetWidgetDragInfo(); return eventInfo; }; $ax.getEventInfoFromEvent = _getEventInfoFromEvent; $ax.getBasicEventInfo = function() { var eventInfo = {}; eventInfo.now = new Date(); eventInfo.window = _getWindowInfo(); eventInfo.cursor = { x: 0, y: 0}; return eventInfo; }; var _getWindowInfo = function() { var win = {}; win.width = $(window).width(); win.height = $(window).height(); win.scrollx = $(window).scrollLeft(); win.scrolly = $(window).scrollTop(); return win; }; $ax.getWindowInfo = _getWindowInfo; var repeaterInfoCache = []; $ax.cacheRepeaterInfo = function(repeaterId, repeaterInfo) { repeaterInfoCache[repeaterId] = repeaterInfo; } $ax.removeCachedRepeaterInfo = function(repeaterId) { repeaterInfoCache[repeaterId] = undefined; } var _getItemInfo = function(elementId) { if(!elementId) return { valid: false }; elementId = _getParentElement(elementId); var index = $ax.repeater.getItemIdFromElementId(elementId); if(!index) return { valid: false }; var item = { valid: true }; var scriptId = $ax.repeater.getScriptIdFromElementId(elementId); var repeaterId = $ax.getParentRepeaterFromScriptId(scriptId); item.repeater = repeaterInfoCache[repeaterId] ? repeaterInfoCache[repeaterId] : _getWidgetInfo(repeaterId); $ax.repeater.setDisplayProps(item, repeaterId, index); item.ismarked = $ax.repeater.isEditItem(repeaterId, index); item.isvisible = Boolean($jobj(elementId).length); return item; }; $ax.getItemInfo = _getItemInfo; var _getWidgetInfo = function(elementId) { if(!elementId) return { valid: false }; elementId = _getParentElement(elementId); var elementAxQuery = $ax('#' + elementId); var elementQuery = $jobj(elementId); var obj = $obj(elementId); var widget = { valid: true, isWidget: true, obj: obj, elementQuery: elementQuery, isLayer: $ax.public.fn.IsLayer(obj.type) }; widget.elementId = elementId; widget.name = widget.label = (elementQuery.data('label') ? elementQuery.data('label') : ''); widget.text = $ax('#' + elementId).text(); widget.opacity = Number(elementQuery.css('opacity')) * 100; widget.rotation = $ax.move.getRotationDegree(widget.elementId); var scriptId = $ax.repeater.getScriptIdFromElementId(elementId); var repeaterId = $ax.getParentRepeaterFromScriptId(scriptId); if(repeaterId) widget.repeater = $ax.public.fn.IsRepeater(obj.type) ? widget : _getWidgetInfo(repeaterId); //if($ax.public.fn.IsLayer(obj.type)) { // var boundingRect = $ax.public.fn.getWidgetBoundingRect(elementId); // widget.x = boundingRect.left; // widget.y = boundingRect.top; // widget.width = boundingRect.width; // widget.height = boundingRect.height; // if(elementQuery.length != 0) { // widget.pagex = elementAxQuery.left(); // widget.pagey = elementAxQuery.top(); // } //} else { // var elementExists = elementQuery.length > 0; // var x = elementExists ? elementAxQuery.locRelativeIgnoreLayer(false) : 0; // var y = elementExists ? elementAxQuery.locRelativeIgnoreLayer(true) : 0; // widget.x = x; // widget.y = y; // if(elementExists) { // widget.pagex = elementAxQuery.left(); // widget.pagey = elementAxQuery.top(); // widget.width = elementAxQuery.width(); // widget.height = elementAxQuery.height(); // } // //if (obj.generateCompound) { // // // assume this means that this is a compound vector. // // widget.x = boundingRect.left; // // widget.y = boundingRect.top; // // //widget.pagex += boundingRect.left; // // //widget.pagey += boundingRect.top; // //} //} // Right now only dynamic panel can scroll if($ax.public.fn.IsDynamicPanel(obj.type)) { var stateQuery = $('#' + $ax.visibility.GetPanelState(elementId)); widget.scrollx = stateQuery.scrollLeft(); widget.scrolly = stateQuery.scrollTop(); widget.stateQuery = stateQuery; //if($ax.dynamicPanelManager.isIdFitToContent(elementId)) { // widget.width = stateQuery.width(); // widget.height = stateQuery.height(); //} } else { widget.scrollx = 0; widget.scrolly = 0; } // repeater only props if($ax.public.fn.IsRepeater(obj.type)) { widget.visibleitemcount = repeaterIdToItemIds[scriptId] ? repeaterIdToItemIds[scriptId].length : $ax.repeater.getVisibleDataCount(scriptId); widget.itemcount = $ax.repeater.getFilteredDataCount(scriptId); widget.datacount = $ax.repeater.getDataCount(scriptId); widget.pagecount = $ax.repeater.getPageCount(scriptId); widget.pageindex = $ax.repeater.getPageIndex(scriptId); } //widget.left = widget.leftfixed = widget.x; //widget.top = widget.topfixed = widget.y; //widget.right = widget.rightfixed = widget.x + widget.width; //widget.bottom = widget.bottomfixed = widget.y + widget.height; //if(elementQuery.css('position') == 'fixed') { // var windowScrollLeft = $(window).scrollLeft(); // var windowScrollTop = $(window).scrollTop(); // widget.leftfixed = widget.left - windowScrollLeft; // widget.topfixed = widget.top - windowScrollTop; // widget.rightfixed = widget.right - windowScrollLeft; // widget.bottomfixed = widget.bottom - windowScrollTop; //} // Get widget info funcs widget.elementAxQuery = function () { return this.elementAxQueryProp || (this.elementAxQueryProp = $ax('#' + this.elementId)); } widget.isFitToContent = function () { if (this.isFitToContentProp === undefined) { if (!this.stateQuery) this.isFitToContentProp = false; else this.isFitToContentProp = $ax.dynamicPanelManager.isIdFitToContent(this.elementId); } return this.isFitToContentProp; } widget.x = function () { return this.getProp('x'); } widget.y = function () { return this.getProp('y'); } widget.pagex = function () { return this.getProp('pagex'); } widget.pagey = function () { return this.getProp('pagey'); } widget.width = function () { return this.getProp('width'); } widget.height = function () { return this.getProp('height'); } widget.left = function () { return this.x(); } widget.top = function () { return this.y(); } widget.right = function () { return this.x() + this.width(); } widget.bottom = function () { return this.y() + this.height(); } widget.getProp = function (prop) { var propName = prop + 'Prop'; if (typeof (this[propName]) != 'undefined') return this[propName]; return this[propName] = this.cacheProp(prop); }; widget.cacheProp = function (prop) { // I'm keeping the returned undefineds the same as before, but really I could probably return undefined right away if elementQuery is empty if (this.isLayer) { if (prop == 'pagex' || prop == 'pagey') { if (this.elementQuery.length > 0) { if (prop == 'pagex') return this.elementAxQuery().left(); else return this.elementAxQuery().top(); } return undefined; // Otherwise, it is undefined as there is no element } var boundingRect = $ax.public.fn.getWidgetBoundingRect(this.elementId); this.xProp = boundingRect.left; this.yProp = boundingRect.top; this.widthProp = boundingRect.width; this.heightProp = boundingRect.height; return this[prop + 'Prop']; } if (this.elementQuery.length 0) { optionsList.push('width=' + selectedOptions.width); width = selectedOptions.width; } var features = optionsList.join(','); if(selectedOptions.centerwindow) { var winl = (window.screen.width - width) / 2; var wint = (window.screen.height - height) / 2; features = features + ',left=' + winl + ',top=' + wint; } return features; }; /** Closes a window */ $ax.public.closeWindow = $ax.closeWindow = function() { parent.window.close(); }; /** Goes back */ $ax.public.back = $ax.back = function() { window.history.go(-1); }; /** Reloads the current page. # includeVariables: true if it should re-include the variables when the page is reloaded */ $ax.public.reload = $ax.reload = function(includeVariables) { var targetUrl = (includeVariables === false) ? $axure.utils.getReloadPath() + \"#\" + encodeURI($ax.pageData.url) : $axure.utils.getReloadPath() + \"#\" + encodeURI($ax.globalVariableProvider.getLinkUrl($ax.pageData.url)); window.location.href = targetUrl; }; /** Sets a variable. # name: The name of the global variable to set # value: The value that should be set */ $ax.public.setGlobalVariable = $ax.setGlobalVariable = function(name, value) { if(!name || !value) { return; } $ax.globalVariableProvider.setVariableValue(name, value); }; /** Gets the value of a global variable # name: The name of the global variable value to get */ $ax.public.getGlobalVariable = $ax.getGlobalVariable = function(name) { $ax.globalVariableProvider.getVariableValue(name); }; $ax.getObjectFromElementIdDisregardHex = function (elementId) { var elementIdInput = elementId.charAt(0) == '#' ? elementId.substring(1) : elementId; return this.getObjectFromElementId(elementIdInput); } $ax.getTypeFromElementId = function(elementId) { var obj = this.getObjectFromElementIdDisregardHex(elementId); return obj && obj.type; }; $ax.getNumFromPx = function(pxNum) { return Number(pxNum.replace('px', '')); } });"},{"title":"","date":"2023-02-27T14:44:57.224Z","updated":"2023-02-27T14:44:57.224Z","comments":true,"path":"imgs/axure/我的考试_files/prototypePost.js","permalink":"https://justsso1.github.io/imgs/axure/%E6%88%91%E7%9A%84%E8%80%83%E8%AF%95_files/prototypePost.js","excerpt":"","text":"// 8.0.0.3382. Generated 1/14/2019 10:26:32 PM UTC //***** messagecenter.js *****// if (typeof console == 'undefined') console = { log: function () { } }; // sniff chrome var CHROME_5_LOCAL = false; var CHROME = false; var SAFARI = false; var FIREFOX = false; var WEBKIT = false; var OS_MAC = false; var IOS = false; var ANDROID = false; var MOBILE_DEVICE = false; var IE = false; var IE_10_AND_BELOW = false; //ie 10 and lower var IE_11_AND_ABOVE = false; //ie 11 and above var BROWSER_VERSION = 5000; (function () { if(!window.$axure) window.$axure = function() {}; var useragent = window.navigator.userAgent; var edgeRegex = /Edge\\/([0-9]+)/g; var edgeMatch = edgeRegex.exec(useragent); $axure.browser = { isEdge: Boolean(edgeMatch) }; if(!$axure.browser.isEdge) { var chromeRegex = /Chrome\\/([0-9]+).([0-9]+)/g; var chromeMatch = chromeRegex.exec(useragent); CHROME = Boolean(chromeMatch); CHROME_5_LOCAL = chromeMatch && Number(chromeMatch[1]) >= 5 && location.href.indexOf('file://') >= 0; } var safariRegex = /Safari\\/([0-9]+)/g; var safariMatch = safariRegex.exec(useragent); SAFARI = Boolean(safariMatch) && !CHROME; //because chrome also inserts safari string into user agent var webkitRegex = /WebKit\\//g ; WEBKIT = Boolean(webkitRegex.exec(useragent)); FIREFOX = useragent.toLowerCase().indexOf('firefox') > -1; var macRegex = /Mac/g ; OS_MAC = Boolean(macRegex.exec(window.navigator.platform)); IOS = useragent.match(/iPhone/i) || useragent.match(/iPad/i) || useragent.match(/iPod/i); ANDROID = useragent.match(/Android/i); MOBILE_DEVICE = ANDROID || IOS || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Tablet PC/i) || navigator.userAgent.match(/Windows Phone/i); if($.browser) { if($.browser.msie) IE_10_AND_BELOW = true; else IE_11_AND_ABOVE = useragent.toLowerCase().indexOf('trident') > -1; BROWSER_VERSION = $.browser.version; } IE = IE_10_AND_BELOW || IE_11_AND_ABOVE; //Used by sitemap and variables.js getLinkUrl functions so that they know //whether to embed global variables in URL as query string or hash string //_shouldSendVars persists the value for sitemap instead of re-checking every time var _shouldSendVars; var _shouldSendVarsToServer = function(url) { if(typeof _shouldSendVars != 'undefined') { return _shouldSendVars; } if(SAFARI || (IE_10_AND_BELOW && BROWSER_VERSION < 10)) { var urlToCheck = typeof url != 'undefined' ? url : window.location.href; var serverRegex = /http:\\/\\/127\\.0\\.0\\.1:[0-9]{5}/g; var serverMatch = serverRegex.exec(urlToCheck); var previewRegex = /[0-9]{2}\\.[0-9]{2}\\.[0-9]{2}/g; var previewMatch = previewRegex.exec(urlToCheck); if(Boolean(serverMatch) && Boolean(previewMatch)) { _shouldSendVars = true; return _shouldSendVars; } } _shouldSendVars = false; return _shouldSendVars; }; $axure.shouldSendVarsToServer = _shouldSendVarsToServer; })(); (function() { var _topMessageCenter; var _messageCenter = {}; var _listeners = []; var _stateListeners = []; var _state = {}; var _eventObject = null; var _queuedMessages = []; var _initialized = false; // this is for the non Chrome 5 local scenarios. The \"top\" message center will dispatch to all the bottom ones var _childrenMessageCenters = []; // create $axure if it hasn't been created if (!window.$axure) window.$axure = function() {}; $axure.messageCenter = _messageCenter; // isolate scope, and initialize _topMessageCenter. (function() { if (!CHROME_5_LOCAL) { var topAxureWindow = window; try { while(topAxureWindow.parent && topAxureWindow.parent !== topAxureWindow && topAxureWindow.parent.$axure) topAxureWindow = topAxureWindow.parent; } catch(e) {} _topMessageCenter = topAxureWindow.$axure.messageCenter; } })(); $(window.document).ready(function() { if (CHROME_5_LOCAL) { $('body').append(\"\" + \"\"); _eventObject = window.document.createEvent('Event'); _eventObject.initEvent('axureMessageSenderEvent', true, true); $('#axureEventReceiverDiv').bind('axureMessageReceiverEvent', function () { var request = JSON.parse($(this).text()); _handleRequest(request); }); } else { if (_topMessageCenter != _messageCenter) { _topMessageCenter.addChildMessageCenter(_messageCenter); console.log('adding from ' + window.location.toString()); } } }); var _handleRequest = function (request) { // route the request to all the listeners for(var i = 0; i < _listeners.length; i++) _listeners[i](request.message, request.data); // now handle the queued messages if we're initializing if (request.message == 'initialize') { _initialized = true; // send all the queued messages and return for (var i = 0; i < _queuedMessages.length; i++) { var qRequest = _queuedMessages[i]; _messageCenter.postMessage(qRequest.message, qRequest.data); } _queuedMessages = []; } // and then handle the set state messages, if necessary if (request.message == 'setState') { _state[request.data.key] = request.data.value; for (var i = 0; i < _stateListeners.length; i++) { var keyListener = _stateListeners[i]; // if thep passed a null or empty value, always post the message if (!keyListener.key || keyListener.key == request.data.key) { keyListener.listener(request.data.key, request.data.value); } } } }; // ----------------------------------------------------------------------------------------- // This method allows for dispatching messages in the non-chromelocal scenario. // Each child calls this on _topMessageCenter // ----------------------------------------------------------------------------------------- _messageCenter.addChildMessageCenter = function(messageCenter) { _childrenMessageCenters[_childrenMessageCenters.length] = messageCenter; }; // ----------------------------------------------------------------------------------------- // This method allows for dispatching messages in the non-chromelocal scenario. // Each child calls this on _topMessageCenter // ----------------------------------------------------------------------------------------- _messageCenter.dispatchMessage = function(message, data) { _handleRequest({ message: message, data: data }); }; // ----------------------------------------------------------------------------------------- // ----------------------------------------------------------------------------------------- _messageCenter.dispatchMessageRecursively = function(message, data) { console.log(\"dispatched to \" + window.location.toString()); // dispatch to the top center first _messageCenter.dispatchMessage(message, data); $('iframe').each(function(index, frame) { //try,catch to handle permissions error in FF when loading pages from another domain try { if (frame.contentWindow.$axure && frame.contentWindow.$axure.messageCenter) { frame.contentWindow.$axure.messageCenter.dispatchMessageRecursively(message, data); } }catch(e) {} }); }; var _combineEventMessages = false; var _compositeEventMessageData = []; _messageCenter.startCombineEventMessages = function() { _combineEventMessages = true; } _messageCenter.endCombineEventMessages = function () { _messageCenter.sendCompositeEventMessage(); _combineEventMessages = false; } _messageCenter.sendCompositeEventMessage = function () { _messageCenter.postMessage('axCompositeEventMessage', _compositeEventMessageData); _compositeEventMessageData = []; } _messageCenter.postMessage = function (message, data) { if(_combineEventMessages) { if(message == 'axEvent' || message == 'axCase' || message == 'axAction' || message == 'axEventComplete') { _compositeEventMessageData.push({ 'message': message, 'data': data }); if(_compositeEventMessageData.length >= 10) _messageCenter.sendCompositeEventMessage(); return; } } if(!CHROME_5_LOCAL) { _topMessageCenter.dispatchMessageRecursively(message, data); } else { var request = { message: message, data: data }; if(_initialized) { var senderDiv = window.document.getElementById('axureEventSenderDiv'); var messageText = JSON.stringify(request); // console.log('sending event: ' + messageText); senderDiv.innerText = messageText; senderDiv.dispatchEvent(_eventObject); // console.log('event sent'); } else { _queuedMessages[_queuedMessages.length] = request; } } }; _messageCenter.setState = function(key, value) { var data = { key: key, value: value }; _messageCenter.postMessage('setState', data); }; _messageCenter.getState = function(key) { return _state[key]; }; _messageCenter.addMessageListener = function(listener) { _listeners[_listeners.length] = listener; }; _messageCenter.addStateListener = function(key, listener) { _stateListeners[_stateListeners.length] = { key: key, listener: listener }; }; })(); //***** events.js *****// // ******* Features MANAGER ******** // $axure.internal(function($ax) { var _features = $ax.features = {}; var _supports = _features.supports = {}; _supports.touchstart = typeof window.ontouchstart !== 'undefined'; _supports.touchmove = typeof window.ontouchmove !== 'undefined'; _supports.touchend = typeof window.ontouchend !== 'undefined'; _supports.mobile = _supports.touchstart && _supports.touchend && _supports.touchmove; // Got this from http://stackoverflow.com/questions/11381673/javascript-solution-to-detect-mobile-browser var check = navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Tablet PC/i) || navigator.userAgent.match(/Windows Phone/i); _supports.windowsMobile = navigator.userAgent.match(/Tablet PC/i) || navigator.userAgent.match(/Windows Phone/i); if(!check && _supports.mobile) { _supports.touchstart = false; _supports.touchmove = false; _supports.touchend = false; _supports.mobile = false; } var _eventNames = _features.eventNames = {}; _eventNames.mouseDownName = _supports.touchstart ? 'touchstart' : 'mousedown'; _eventNames.mouseUpName = _supports.touchend ? 'touchend' : 'mouseup'; _eventNames.mouseMoveName = _supports.touchmove ? 'touchmove' : 'mousemove'; }); // ******* EVENT MANAGER ******** // $axure.internal(function($ax) { var _objectIdToEventHandlers = {}; var _jBrowserEvent = undefined; $ax.setjBrowserEvent = function(event) { _jBrowserEvent = event; }; $ax.getjBrowserEvent = function() { return _jBrowserEvent; }; var _event = {}; $ax.event = _event; //initilize state _event.mouseOverObjectId = ''; _event.mouseDownObjectId = ''; _event.mouseOverIds = []; var EVENT_NAMES = ['mouseenter', 'mouseleave', 'contextmenu', 'change', 'focus', 'blur']; // Tap, double tap, and touch move, or synthetic. if(!$ax.features.supports.mobile) { EVENT_NAMES[EVENT_NAMES.length] = 'click'; EVENT_NAMES[EVENT_NAMES.length] = 'dblclick'; EVENT_NAMES[EVENT_NAMES.length] = 'mousemove'; } // add the event names for the touch events EVENT_NAMES[EVENT_NAMES.length] = $ax.features.eventNames.mouseDownName; EVENT_NAMES[EVENT_NAMES.length] = $ax.features.eventNames.mouseUpName; for(var i = 0; i < EVENT_NAMES.length; i++) { var eventName = EVENT_NAMES[i]; //we need the function here to circumvent closure modifying eventName _event[eventName] = (function(event_Name) { return function(elementId, fn) { var elementIdQuery = $jobj(elementId); var type = $ax.getTypeFromElementId(elementId); //we need specially track link events so we can enable and disable them along with //their parent widgets if(elementIdQuery.is('a')) _attachCustomObjectEvent(elementId, event_Name, fn); //see notes below else if($ax.IsTreeNodeObject(type)) _attachTreeNodeEvent(elementId, event_Name, fn); else if ($ax.IsImageFocusable(type) && (event_Name == 'focus' || event_Name == 'blur')) { var suitableChild; var imgChild = $ax.repeater.applySuffixToElementId(elementId, '_img'); var divChild = $ax.repeater.applySuffixToElementId(elementId, '_div'); for (var j = 0; j < elementIdQuery[0].children.length; j++) { if (elementIdQuery[0].children[j].id == imgChild) suitableChild = imgChild; if (!suitableChild && elementIdQuery[0].children[j].id == divChild) suitableChild = divChild; } if(!suitableChild) suitableChild = imgChild; _attachDefaultObjectEvent($jobj(suitableChild), elementId, event_Name, fn); } else { var inputId = $ax.INPUT(elementId); var isInput = $jobj(inputId).length != 0; var id = isInput && (event_Name == 'focus' || event_Name == 'blur') ? inputId : elementId; _attachDefaultObjectEvent($jobj(id), elementId, event_Name, fn); } }; })(eventName); } var AXURE_TO_JQUERY_EVENT_NAMES = { 'onMouseOver': 'mouseenter', 'onMouseOut': 'mouseleave', 'onContextMenu': 'contextmenu', 'onChange': 'change', 'onFocus': 'focus', 'onLostFocus': 'blur' }; // Tap, double tap, and touch move, or synthetic. if(!$ax.features.supports.mobile) { AXURE_TO_JQUERY_EVENT_NAMES.onClick = 'click'; AXURE_TO_JQUERY_EVENT_NAMES.onDoubleClick = 'dblclick'; AXURE_TO_JQUERY_EVENT_NAMES.onMouseMove = 'mousemove'; } AXURE_TO_JQUERY_EVENT_NAMES.onMouseDown = $ax.features.eventNames.mouseDownName; AXURE_TO_JQUERY_EVENT_NAMES.onMouseUp = $ax.features.eventNames.mouseUpName; //for dp, if mouse entered without leaving, don't fire mouse enter again var mouseEnterGuard = {}; var _attachEvents = function (diagramObject, elementId, doMouseEnterGuard) { var inputId = $ax.repeater.applySuffixToElementId(elementId, '_input'); var id = $jobj(inputId).length ? inputId : elementId; for(var eventName in diagramObject.interactionMap) { var jQueryEventName = AXURE_TO_JQUERY_EVENT_NAMES[eventName]; if(!jQueryEventName) continue; _event[jQueryEventName](id, //this is needed to escape closure (function(axEventObject) { return function (e) { if(e.type == 'mouseenter' && doMouseEnterGuard) { if(mouseEnterGuard[elementId]) return; else mouseEnterGuard[elementId] = true; } $ax.setjBrowserEvent(e); // console.log(axEventObject.description); var eventInfo = $ax.getEventInfoFromEvent($ax.getjBrowserEvent(), false, elementId); _handleEvent(elementId, eventInfo, axEventObject); }; })(diagramObject.interactionMap[eventName]) ); if(jQueryEventName.toLowerCase() == 'mouseenter' && doMouseEnterGuard) { $jobj(elementId).on('mouseleave touchend', function() { mouseEnterGuard[elementId] = false; }); } } }; var _descriptionToKey = { 'OnFocus': 'onFocus', 'OnLostFocus': 'onLostFocus' }; var _createProxies = function(diagramObject, elementId) { var createFocus = _needsProxy(diagramObject, elementId, 'onFocus'); var createLostFocus = _needsProxy(diagramObject, elementId, 'onLostFocus'); if(!createFocus && !createLostFocus) return; if(!diagramObject.interactionMap) diagramObject.interactionMap = {}; if(createFocus) diagramObject.interactionMap.onFocus = { proxy: true, description: 'OnFocus' }; if(createLostFocus) diagramObject.interactionMap.onLostFocus = { proxy: true, description: 'OnLostFocus' }; } var preventDefaultEvents = ['OnContextMenu', 'OnKeyUp', 'OnKeyDown']; var allowBubble = ['OnFocus', 'OnResize', 'OnMouseOut', 'OnMouseOver']; var _canClick = true; var _startScroll = []; var _setCanClick = function(canClick) { _canClick = canClick; if(_canClick) _startScroll = [$(window).scrollLeft(), $(window).scrollTop()]; }; var _getCanClick = function() { if(!$ax.features.supports.mobile) return true; var endScroll = [$(window).scrollLeft(), $(window).scrollTop()]; return _canClick && _startScroll[0] == endScroll[0] && _startScroll[1] == endScroll[1]; }; //var _notAllowedInvisible = function (type) { // $ax.getTypeFromElementId(elementId); // return !$ax.public.fn.IsReferenceDiagramObject(type) && !$ax.public.fn.IsLayer(type); //} var _notAllowedInvisible = function (id) { var type = $ax.getTypeFromElementId(id); if ($ax.public.fn.IsReferenceDiagramObject(type) || $ax.public.fn.IsLayer(type)) return false; return !($ax.public.fn.IsVector(type) && _hasCompoundImage(id)); } var _hasCompoundImage = function (id) { var query = $jobj(id); return $ax.public.fn.isCompoundVectorHtml(query[0]); } var _suppressedEvents = {}; // Suppressed for next occurance. var _blockedEvents = {}; // Blocked until unblocked. _event.addSuppressedEvent = function(id, event) { if(!_suppressedEvents[id]) _suppressedEvents[id] = []; var events = _suppressedEvents[id]; if(events.indexOf(event) != -1) return; events.push(event); } _event.blockEvent = function(id, event) { if(!_blockedEvents[id]) _blockedEvents[id] = {}; var events = _blockedEvents[id]; if(events[event]) ++events[event]; else events[event] = 1; return function() { _unblockEvent(id, event); }; } var _isSuppressedEvent = function(id, event) { var suppressedEvents = _suppressedEvents[id]; var blockedEvents = _blockedEvents[id]; return (suppressedEvents && suppressedEvents.indexOf(event) != -1) || (blockedEvents && blockedEvents[event]); } var _removeSuppressedEvent = function(id, event) { var events = _suppressedEvents[id]; if(!events) return; if(events.length == 1) { delete _suppressedEvents[id]; } else { var eventIndex = events.indexOf(event); for(var i = eventIndex + 1; i < events.length; i++) events[i - 1] = events[i]; events.pop(); } } var _unblockEvent = function(id, event) { var events = _blockedEvents[id]; if(events) { if(--events[event] > 0) return; } _removeSuppressedEvent(id, event); } var _unblockEvent = function(id, event) { var events = _blockedEvents[id]; if(events) { if(--events[event] > 0) return; } _removeSuppressedEvent(id, event); } var eventNesting = 0; var eventNestingTime = new Date().getTime(); var _handleEvent = $ax.event.handleEvent = function (elementId, eventInfo, axEventObject, skipShowDescriptions, synthetic) { var eventDescription = axEventObject.description; if(_enteredWidgets[elementId] && eventDescription == 'OnMouseEnter') return; // Suppress entering a widget when already in widget (ie only) if(_isSuppressedEvent(elementId, eventDescription)) { _removeSuppressedEvent(elementId, eventDescription); return; } if(axEventObject.proxy) { var firingId = _widgetToFocusParent[elementId]; if(firingId) { var firingObj = $obj(firingId); var nextEventObj = firingObj.interactionMap && firingObj.interactionMap[_descriptionToKey[eventDescription]]; if(!nextEventObj) nextEventObj = axEventObject; _handleEvent(firingId, eventInfo, nextEventObj, skipShowDescriptions, synthetic); } return; } // var x = JSON.stringify(eventInfo); // var y = JSON.stringify(axEventObject); var fireTime = new Date().getTime(); if(fireTime - eventNestingTime > 100) { eventNestingTime = fireTime; eventNesting = 0; } if(eventNesting === 0) { $ax.recording.maybeRecordEvent(elementId, eventInfo, axEventObject, fireTime); } eventNesting += 1; if(!_getCanClick() && (eventDescription == 'OnClick' || eventDescription == 'OnPageClick')) return; // If you are supposed to suppress, do that right away. if(suppressedEventStatus[eventDescription]) { return; } var currentEvent = $ax.getjBrowserEvent(); if(!synthetic && currentEvent && currentEvent.originalEvent && currentEvent.originalEvent.handled && !eventInfo.isMasterEvent) return; if(!synthetic && elementId && !$ax.style.getObjVisible(elementId) && _notAllowedInvisible(elementId)) return; //if debug var axObj = $obj(elementId); var axObjLabel = axObj ? axObj.label : eventInfo.label; var axObjType = axObj ? axObj.friendlyType : eventInfo.friendlyType; if(!skipShowDescriptions || eventDescription == 'OnPageLoad') $ax.messageCenter.postMessage('axEvent', { 'label': axObjLabel, 'type': axObjType, 'event': axEventObject }); var bubble = true; var showCaseDescriptions = !skipShowDescriptions && _shouldShowCaseDescriptions(axEventObject); if(!showCaseDescriptions) { //handle case descriptions var caseGroups = []; var currentCaseGroup = []; caseGroups[0] = currentCaseGroup; // Those refreshes not after a wait var guaranteedRefreshes = {}; var caseGroupIndex = 0; for(var i = 0; i < axEventObject.cases.length; i++) { var currentCase = axEventObject.cases[i]; if(currentCase.isNewIfGroup && i != 0) { caseGroupIndex++; currentCaseGroup = []; caseGroups[caseGroups.length] = currentCaseGroup; // Joon: Isn't caseGroups.length always equal to caseGroupIndex? } currentCaseGroup[currentCaseGroup.length] = currentCase; for(var j = 0; j < currentCase.actions.length; j++) { var action = currentCase.actions[j]; if(action.action == 'wait') break; if(action.action != 'refreshRepeater') continue; for(var k = 0; k < action.repeatersToRefresh.length; k++) { var id = $ax.getElementIdsFromPath(action.repeatersToRefresh[k], eventInfo)[0]; if(id) guaranteedRefreshes[id] = caseGroupIndex; } } } for(var i = 0; i < caseGroups.length; i++) { var groupRefreshes = []; for(var key in guaranteedRefreshes) { if(guaranteedRefreshes[key] == i) groupRefreshes[groupRefreshes.length] = key; } bubble = _handleCaseGroup(eventInfo, caseGroups[i], groupRefreshes) && bubble; } } else { _showCaseDescriptions(elementId, eventInfo, axEventObject, synthetic); bubble = false; } // If not handled, synthetically bubble if you can if(bubble && _widgetToFocusParent[elementId]) { firingId = _widgetToFocusParent[elementId]; if(firingId) { firingObj = $obj(firingId); nextEventObj = firingObj.interactionMap && firingObj.interactionMap[_descriptionToKey[axEventObject.description]]; if(!nextEventObj) nextEventObj = axEventObject; _handleEvent(firingId, eventInfo, nextEventObj, skipShowDescriptions, synthetic); } return; } // Only trigger a supression if it handled this event if(!bubble && suppressingEvents[eventDescription]) { suppressedEventStatus[suppressingEvents[eventDescription]] = true; } $ax.action.flushAllResizeMoveActions(eventInfo); // This should not be needed anymore. All refreshes should be inserted, or handled earlier. var repeaters = $ax.deepCopy($ax.action.repeatersToRefresh); while($ax.action.repeatersToRefresh.length) $ax.action.repeatersToRefresh.pop(); for(i = 0; i < repeaters.length; i++) $ax.repeater.refreshRepeater(repeaters[i], eventInfo); if(currentEvent && currentEvent.originalEvent) { currentEvent.originalEvent.handled = !synthetic && !bubble && allowBubble.indexOf(eventDescription) == -1; //currentEvent.originalEvent.donotdrag = currentEvent.donotdrag || (!bubble && eventDescription == 'OnMouseDown'); // Prevent default if necessary if(currentEvent.originalEvent.handled && preventDefaultEvents.indexOf(eventDescription) != -1) { currentEvent.preventDefault(); } } eventNesting -= 1; if(!showCaseDescriptions) $ax.messageCenter.postMessage('axEventComplete'); }; var _handleScrollEvent = function (elementId, eventInfo, originalEvent, scrolledUp, scrolledDown, interactionMap, skipShowDescription, synthetic) { if (!interactionMap) return; if (interactionMap.onScroll) _handleEvent(elementId, eventInfo, interactionMap.onScroll, skipShowDescription, synthetic); var wasHandled = originalEvent.handled; if (interactionMap.onScrollUp && scrolledUp) { originalEvent.handled = false; _handleEvent(elementId, eventInfo, interactionMap.onScrollUp, skipShowDescription, synthetic); } else if (interactionMap.onScrollDown && scrolledDown) { originalEvent.handled = false; _handleEvent(elementId, eventInfo, interactionMap.onScrollDown, skipShowDescription, synthetic); } originalEvent.handled |= wasHandled; } var _showCaseDescriptions = function(elementId, eventInfo, axEventObject, synthetic) { if(axEventObject.cases.length == 0) return true; var linksId = elementId + \"linkBox\"; $('#' + linksId).remove(); var $container = $(\"\"); if(!_isEventSimulating(axEventObject)) { var copy = $ax.eventCopy(eventInfo); for(var i = 0; i < axEventObject.cases.length; i++) { var $link = $(\"\" + axEventObject.cases[i].description + \"\"); $link.click(function(j) { return function () { var currentCase = axEventObject.cases[j]; $ax.messageCenter.postMessage('axCase', { 'description': currentCase.description }); for(var k = 0; k < currentCase.actions.length; k++) { $ax.messageCenter.postMessage('axAction', { 'description': currentCase.actions[k].description }); } $ax.messageCenter.postMessage('axEventComplete'); var bubble = $ax.action.dispatchAction(copy, axEventObject.cases[j].actions); $ax.action.flushAllResizeMoveActions(copy); $('#' + linksId).remove(); return bubble; }; } (i) ); $container.append($link); } } else { var fullDescription = axEventObject.description + \":\"; for(var i = 0; i < axEventObject.cases.length; i++) { var currentCase = axEventObject.cases[i]; fullDescription += \"&nbsp;&nbsp;\" + currentCase.description.replace(//g, '&nbsp;&nbsp;') + \":\"; for(var j = 0; j < currentCase.actions.length; j++) { fullDescription += \"&nbsp;&nbsp;&nbsp;&nbsp;\" + currentCase.actions[j].description.replace(//g, '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;') + \"\"; } } fullDescription = fullDescription.substring(0, fullDescription.length - 4); var $link = $(\"\" + fullDescription + \"\"); $link.click(function() { _handleEvent(elementId, eventInfo, axEventObject, true, synthetic); $ax.messageCenter.postMessage('axEventComplete'); $('#' + linksId).remove(); return; }); $container.append($link); } $container.mouseleave(function(e) { $ax.legacy.SuppressBubble(e); }); $('body').append($container); _showCaseLinks(eventInfo, linksId); }; var _showCaseLinks = function(eventInfo, linksId) { var links = window.document.getElementById(linksId); links.style.top = eventInfo.pageY; var left = eventInfo.pageX; links.style.left = left; $ax.visibility.SetVisible(links, true); $ax.legacy.BringToFront(linksId, true); // Switch to using jquery if this is still needed. Really old legacy code, likely for a browser no longer supported. //$ax.legacy.RefreshScreen(); }; var _shouldShowCaseDescriptions = function(axEventObject) { if($ax.document.configuration.linkStyle == \"alwaysDisplayTargets\") return true; if($ax.document.configuration.linkStyle == \"neverDisplayTargets\") return false; if(axEventObject.cases.length == 0) return false; if(_isEventSimulating(axEventObject)) return false; if(axEventObject.cases.length >= 2) return true; return false; }; var _isEventSimulating = function(axEventObject) { for(var i = 0; i < axEventObject.cases.length; i++) { if(axEventObject.cases[i].condition) return true; } return false; }; var _handleCaseGroup = function(eventInfo, caseGroup, groupRefreshes) { for(var i = 0; i < caseGroup.length; i++) { var currentCase = caseGroup[i]; if(!currentCase.condition || _processCondition(currentCase.condition, eventInfo)) { $ax.messageCenter.postMessage('axCase', { 'description': currentCase.description }); for(var j = 0; j < currentCase.actions.length; j++) { if(currentCase.actions[j].action != 'refreshRepeater') $ax.messageCenter.postMessage('axAction', { 'description': currentCase.actions[j].description }); } for(var j = 0; j < currentCase.actions.length; j++) { var action = currentCase.actions[j]; if(action.action == 'wait') break; if(action.action != 'refreshRepeater') continue; for(var k = 0; k < action.repeatersToRefresh.length; k++) { var id = $ax.getElementIdsFromPath(action.repeatersToRefresh[i], eventInfo)[i]; if(id) { var index = groupRefreshes.indexOf(id); if(index != -1) $ax.splice(groupRefreshes, index); } } } // Any guaranteed refreshes that aren't accounted for must be run still. $ax.action.tryRefreshRepeaters(groupRefreshes, eventInfo); $ax.action.dispatchAction(eventInfo, currentCase.actions); return false; } } // Any guaranteed refreshes that aren't accounted for must be run still. $ax.action.tryRefreshRepeaters(groupRefreshes, eventInfo); return true; }; var _processCondition = function(expr, eventInfo) { return $ax.expr.evaluateExpr(expr, eventInfo); }; var _attachTreeNodeEvent = function(elementId, eventName, fn) { //we need to set the cursor here because we want to make sure that every tree node has the default //cursor set and then it's overridden if it has a click if(eventName == 'click') window.document.getElementById(elementId).style.cursor = 'pointer'; _attachCustomObjectEvent(elementId, eventName, fn); }; var _attachDefaultObjectEvent = function(elementIdQuery, elementId, eventName, fn) { var func = function() { if(!$ax.style.IsWidgetDisabled(elementId)) return fn.apply(this, arguments); return true; }; var bind = !elementIdQuery[eventName]; if(bind) elementIdQuery.bind(eventName, func); else elementIdQuery[eventName](func); }; var _attachCustomObjectEvent = function(elementId, eventName, fn) { var handlers = _objectIdToEventHandlers[elementId]; if(!handlers) _objectIdToEventHandlers[elementId] = handlers = {}; var fnList = handlers[eventName]; if(!fnList) handlers[eventName] = fnList = []; fnList[fnList.length] = fn; }; var _fireObjectEvent = function(elementId, event, originalArgs) { var element = window.document.getElementById(elementId); var handlerList = _objectIdToEventHandlers[elementId] && _objectIdToEventHandlers[elementId][event]; if(handlerList) { for(var i = 0; i < handlerList.length; i++) handlerList[i].apply(element, originalArgs); } eventNesting -= 1; }; var _layerToFocusableWidget = {}; var _widgetToFocusParent = {}; _event.layerMapFocus = function(layer, elementId) { var mainObj = layer.objs[0]; // If first child non existant return if (!mainObj) return; var mainId = $ax.getElementIdFromPath([mainObj.id], { relativeTo: elementId }); _widgetToFocusParent[mainId] = elementId; // If first child is a layer, call recursively if ($ax.public.fn.IsLayer(mainObj.type)) { _event.layerMapFocus(mainObj, mainId); var baseId = _layerToFocusableWidget[mainId]; if(baseId) _layerToFocusableWidget[elementId] = baseId; return; } _layerToFocusableWidget[elementId] = mainId; } var _needsProxy = function(obj, id, proxyName) { // layers don't need on focus ever, proxies will handle them if ($ax.public.fn.IsLayer(obj.type)) return false; // If you already focus you don't need to force yourself to proxy. if(obj.interactionMap && obj.interactionMap[proxyName]) return false; var parentId = _widgetToFocusParent[id]; if(parentId) return _needsProxyHelper(parentId, proxyName); return false; } var _needsProxyHelper = function(id, proxyName) { var obj = $obj(id); if(obj.interactionMap && obj.interactionMap[proxyName]) return true; var parentId = _widgetToFocusParent[id]; if(parentId) return _needsProxyHelper(parentId, proxyName); return false; } //for button shapes and images the img is focusable instead of the div to get better outlines // For layers, we remember who their proxy is. $ax.event.getFocusableWidgetOrChildId = function (elementId) { var mappedId = _layerToFocusableWidget[elementId]; if (mappedId) elementId = mappedId; var inputId = $ax.repeater.applySuffixToElementId(elementId, '_input'); var inputQuery = $jobj(inputId); if(inputQuery.length > 0) return inputId; var imgId = $ax.repeater.applySuffixToElementId(elementId, '_img'); var imgQuery = $jobj(imgId); if (imgQuery.length > 0) return imgId; var divId = $ax.repeater.applySuffixToElementId(elementId, '_div'); var divQuery = $jobj(divId); if (divQuery.length > 0) return divId; return elementId; }; var _enteredWidgets = {}; // key is the suppressing event, and the value is the event that is supressed var suppressingEvents = {}; // key is the event that will cancel the suppression, and value is the event that was being suppressed var cancelSuppressions = {}; // suppressed event maps to true if it is supressed var suppressedEventStatus = {}; var initSuppressingEvents = function () { suppressingEvents['OnLongClick'] = 'OnClick'; cancelSuppressions['onMouseDown'] = 'OnClick'; // Have to cancel suppressed event here. Only works for non-synthetic events currently for(var key in cancelSuppressions) { var jEventName = AXURE_TO_JQUERY_EVENT_NAMES[key]; if(!jEventName) continue; $('body').bind(jEventName, function () { suppressedEventStatus[cancelSuppressions[key]] = false; }); } }; // TODO: It may be a good idea to split this into multiple functions, or at least pull out more similar functions into private methods var _initializeObjectEvents = function(query, refreshType) { query.each(function(dObj, elementId) { var $element = $jobj(elementId); var itemId = $ax.repeater.getItemIdFromElementId(elementId); // Focus has to be done before on focus fires // Set up focus if ($ax.public.fn.IsTextArea(dObj.type) || $ax.public.fn.IsTextBox(dObj.type) || $ax.public.fn.IsCheckBox(dObj.type) || $ax.public.fn.IsRadioButton(dObj.type) || $ax.public.fn.IsListBox(dObj.type) || $ax.public.fn.IsComboBox(dObj.type) || $ax.public.fn.IsButton(dObj.type) || (dObj.tabbable && ($ax.public.fn.IsImageBox(dObj.type) || $ax.public.fn.IsVector(dObj.type) || $ax.IsTreeNodeObject(dObj.type) || $ax.public.fn.IsTableCell(dObj.type)))) { var focusObj = $jobj($ax.event.getFocusableWidgetOrChildId(elementId)); focusObj.focus(function() { window.lastFocusedControl = elementId; }); } // [MAS: Supressing events were here] _createProxies(dObj, elementId); var isDynamicPanel = $ax.public.fn.IsDynamicPanel(dObj.type); if(dObj.interactionMap) { _attachEvents(dObj, elementId, isDynamicPanel); }; if (IE || $axure.browser.isEdge) { $element.mouseenter(function() { _enteredWidgets[elementId] = true; }).mouseleave(function() { _enteredWidgets[elementId] = false; }); } _attachIxStyleEvents(dObj, elementId, $element); var $axElement = $ax('#' + elementId); // Base case is set up selected disabled based on the default in the axobj, for non, repeaters and resetting repeaters var itemReset = refreshType == $ax.repeater.refreshType.reset; if(!itemId || itemReset) { //initialize disabled elements, do this first before selected, cause if a widget is disabled, we don't want to apply selected style anymore if($ax.public.fn.IsVector(dObj.type) || $ax.public.fn.IsImageBox(dObj.type) || isDynamicPanel || $ax.public.fn.IsLayer(dObj.type)) { if(dObj.disabled) $axElement.enabled(false); // Initialize selected elements if(dObj.selected) $axElement.selected(true); } } else if(refreshType == $ax.repeater.refreshType.preEval) { // Otherwise everything should be set up correctly by pre-eval, want to set up selected disabled dictionaries (and disabled status) // Disabled layer/dynamic panel don't have the disabled class, but they do have the disabled attr written out, so use that in that case if ($element.hasClass('disabled') || (($ax.IsLayer(dObj.type) || $ax.IsDynamicPanel(dObj.type)) && $element.attr('disabled'))) $axElement.enabled(false); if($element.hasClass('selected')) $axElement.selected(true); } else { // Persist means we want to leave it as is, but we want to make sure we use selected based off of the backing data, and not some class that exists because of the reset $element.removeClass('selected'); } if(OS_MAC && WEBKIT) { if ($ax.public.fn.IsComboBox(dObj.type) && dObj.disabled) { $jobj($ax.INPUT(elementId)).css('color', 'grayText'); } }; // Initialize Placeholders. Right now this is text boxes and text areas. // Also, the assuption is being made that these widgets with the placeholder, have no other styles (this may change...) var hasPlaceholder = dObj.placeholderText == '' ? true : Boolean(dObj.placeholderText); if(($ax.public.fn.IsTextArea(dObj.type) || $ax.public.fn.IsTextBox(dObj.type)) && hasPlaceholder) { // This is needed to initialize the placeholder state var inputJobj = $jobj($ax.INPUT(elementId)); inputJobj.bind('focus', function () { if(dObj.HideHintOnFocused) { var id = this.id; var inputIndex = id.indexOf('_input'); if (inputIndex == -1) return; var inputId = id.substring(0, inputIndex); if (!$ax.placeholderManager.isActive(inputId)) return; $ax.placeholderManager.updatePlaceholder(inputId, false, true); } $ax.placeholderManager.moveCaret(this.id); }).bind('mouseup', function() { $ax.placeholderManager.moveCaret(this.id); }).bind('blur', function() { var id = this.id; var inputIndex = id.indexOf('_input'); if(inputIndex == -1) return; var inputId = id.substring(0, inputIndex); if($jobj(id).val()) return; $ax.placeholderManager.updatePlaceholder(inputId, true); }); if(ANDROID) { //input fires before keyup, to avoid flicker, supported in ie9 and above inputJobj.bind('input', function() { if(!dObj.HideHintOnFocused) { //hide on type var id = this.id; var inputIndex = id.indexOf('_input'); if(inputIndex == -1) return; var inputId = id.substring(0, inputIndex); if($ax.placeholderManager.isActive(inputId)) { $ax.placeholderManager.updatePlaceholder(inputId, false, true); } else if(!$jobj(id).val()) { $ax.placeholderManager.updatePlaceholder(inputId, true, false); $ax.placeholderManager.moveCaret(id, 0); } } }); } else { inputJobj.bind('keydown', function() { if(!dObj.HideHintOnFocused) { var id = this.id; var inputIndex = id.indexOf('_input'); if(inputIndex == -1) return; var inputId = id.substring(0, inputIndex); if(!$ax.placeholderManager.isActive(inputId)) return; $ax.placeholderManager.updatePlaceholder(inputId, false, true); } }).bind('keyup', function() { var id = this.id; var inputIndex = id.indexOf('_input'); if(inputIndex == -1) return; var inputId = id.substring(0, inputIndex); if($ax.placeholderManager.isActive(inputId)) return; if(!dObj.HideHintOnFocused && !$jobj(id).val()) { $ax.placeholderManager.updatePlaceholder(inputId, true); $ax.placeholderManager.moveCaret(id, 0); } }); } $ax.placeholderManager.registerPlaceholder(elementId, dObj.placeholderText, inputJobj.attr('type') == 'password'); $ax.placeholderManager.updatePlaceholder(elementId, !($jobj($ax.repeater.applySuffixToElementId(elementId, '_input')).val())); } // Initialize assigned submit buttons if(dObj.submitButton) { $element.keyup(function(e) { if(e.keyCode == '13') { var scriptId = $ax.repeater.getScriptIdFromElementId(elementId); var path = $ax.deepCopy(dObj.submitButton.path); path[path.length] = dObj.submitButton.id; var itemNum = $ax.repeater.getItemIdFromElementId(elementId); var submitId = $ax.getScriptIdFromPath(path, scriptId); if(itemNum && $ax.getParentRepeaterFromScriptId(submitId) == $ax.getParentRepeaterFromScriptId(scriptId)) { submitId = $ax.repeater.createElementId(submitId, itemNum); } var inputId = $ax.INPUT(submitId); if($jobj(inputId).length) submitId = inputId; $ax.setjBrowserEvent(e); $ax.event.fireClick(submitId); } }).keydown(function(e) { if(e.keyCode == '13') { e.preventDefault(); } }); } // Don't drag after mousing down on a plain text object if ($ax.public.fn.IsTextArea(dObj.type) || $ax.public.fn.IsTextBox(dObj.type) || $ax.public.fn.IsListBox(dObj.type) || $ax.public.fn.IsComboBox(dObj.type) || $ax.public.fn.IsCheckBox(dObj.type) || $ax.public.fn.IsRadioButton(dObj.type)) { $element.bind($ax.features.eventNames.mouseDownName, function(event) { event.originalEvent.donotdrag = true; }); } if($ax.features.supports.mobile) { $element.bind($ax.features.eventNames.mouseDownName, function() { _setCanClick(true); }); if (isDynamicPanel) { $element.scroll(function() { _setCanClick(false); }); } } //initialize tree node cursors to default so they will override their parent if ($ax.public.fn.IsTreeNodeObject(dObj.type) && !(dObj.interactionMap && dObj.interactionMap.onClick)) { $element.css('cursor', 'default'); } //initialize widgets that are clickable to have the pointer over them when hovering if($ax.event.HasClick(dObj)) { if($element) $element.css('cursor', 'pointer'); } // TODO: not sure if we need this. It appears to be working without //initialize panels for DynamicPanels if (isDynamicPanel) { $element.children().each(function() { var parts = this.id.split('_'); var state = parts[parts.length - 1].substring(5); if(state != 0) $ax.visibility.SetVisible(this, false); }); } //initialize TreeNodes if ($ax.public.fn.IsTreeNodeObject(dObj.type)) { if($element.hasClass('treeroot')) return; var childrenId = elementId + '_children'; var children = $element.children('[id=\"' + childrenId + '\"]:first'); if(children.length > 0) { var plusMinusId = 'u' + (parseInt($ax.repeater.getScriptIdFromElementId(elementId).substring(1)) + 1); if(itemId) plusMinusId = $ax.repeater.createElementId(plusMinusId, itemId); if(!$jobj(plusMinusId).children().first().is('img')) plusMinusId = ''; $ax.tree.InitializeTreeNode(elementId, plusMinusId, childrenId); } $element.click(function() { $ax.tree.SelectTreeNode(elementId, true); }); } //initialize submenus if ($ax.public.fn.IsMenuObject(dObj.type)) { if($element.hasClass('sub_menu')) { var tableCellElementId = $ax.getElementIdFromPath([dObj.parentCellId], { relativeTo: elementId }); $ax.menu.InitializeSubmenu(elementId, tableCellElementId); } } // Attach handles for dynamic panels that propagate styles to inner items. if ((isDynamicPanel || $ax.public.fn.IsLayer(dObj.type)) && dObj.propagate) { $element.mouseenter(function() { dynamicPanelMouseOver(this.id); }).mouseleave(function() { dynamicPanelMouseLeave(this.id); }).bind($ax.features.eventNames.mouseDownName, function() { dynamicPanelMouseDown(this.id); }).bind($ax.features.eventNames.mouseUpName, function() { dynamicPanelMouseUp(this.id); }); } // These are the dynamic panel functions for propagating rollover styles and mouse down styles to inner objects var dynamicPanelMouseOver = function(elementId, fromChild) { var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent) { dynamicPanelMouseOver(parent.id, true); if(parent.direct) return; } if($.inArray(elementId, _event.mouseOverIds) != -1) return; // If this event is coming from a child, don't mark that it's actually entered. // Only mark that this has been entered if this event has naturally been triggered. (For reason see mouseleave) if(!fromChild) _event.mouseOverIds[_event.mouseOverIds.length] = elementId; if(elementId == _event.mouseOverObjectId) return; _event.mouseOverObjectId = elementId; $ax.dynamicPanelManager.propagateMouseOver(elementId, true); }; var dynamicPanelMouseLeave = function(elementId, fromChild) { var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent) { dynamicPanelMouseLeave(parent.id, true); if(parent.direct) return; } var index = $.inArray(elementId, _event.mouseOverIds); // If index != -1, this has been natuarally entered. If naturally entered, then leaving child should not trigger leaving, // but instead wait for natural mouse leave. If natural mouse enter never triggered, natural mouse leave won't so do this now. if((index != -1) && fromChild) return; $ax.splice(_event.mouseOverIds, index, 1); if(elementId == _event.mouseOverObjectId) { _event.mouseOverObjectId = ''; } $ax.dynamicPanelManager.propagateMouseOver(elementId, false); }; //attach handlers for button shape and tree node mouse over styles // TODO: Can this really be removed? Trees seem to work with out (the generic hover case works for it). // query.filter(function(obj) { // return $ax.public.fn.IsVector(obj.type) && $ax.public.fn.IsTreeNodeObject(obj.parent.type) && // obj.parent.style && obj.parent.style.stateStyles && // obj.parent.style.stateStyles.mouseOver; // }).mouseenter(function() { // $ax.style.SetWidgetHover(this.id, true); // }).mouseleave(function() { // $ax.style.SetWidgetHover(this.id, false); // }); //handle treeNodeObject events and prevent them from bubbling up. this is necessary because otherwise //both a sub menu and it's parent would get a click if ($ax.public.fn.IsTreeNodeObject(dObj.type)) { $element.click(function() { //todo -- this was bubbling, but then selecting a child tree node would bubble and select the parent (don't know if there is a better way) _fireObjectEvent(this.id, 'click', arguments); return false; }).each(function() { if(!this.style.cursor) { this.style.cursor = 'default'; } }); } // Synthetic events var map = dObj.interactionMap; // Attach dynamic panel synthetic drag and swipe events if(dObj.type == \"dynamicPanel\" && map && ( map.onDragStart || map.onDrag || map.onDragDrop || map.onSwipeLeft || map.onSwipeRight || map.onSwipeUp || map.onSwipeDown)) { $element.bind($ax.features.eventNames.mouseDownName, function(e) { $ax.drag.StartDragWidget(e.originalEvent, elementId); }); } // Attach dynamic panel synthetic scroll event if (isDynamicPanel && map && (map.onScroll || map.onScrollUp || map.onScrollDown)) { var diagrams = dObj.diagrams; for(var i = 0; i < diagrams.length; i++) { var panelId = $ax.repeater.applySuffixToElementId(elementId, '_state' + i); (function(id) { if ($('#' + id).data('lastScrollTop') == undefined) $('#' + id).data('lastScrollTop', '0'); _attachDefaultObjectEvent($('#' + id), elementId, 'scroll', function(e) { $ax.setjBrowserEvent(e); var currentEvent = $ax.getjBrowserEvent(); var eventInfoFromEvent = $ax.getEventInfoFromEvent(currentEvent, false, elementId); var currentTop = $('#' + id).scrollTop(); var lastTop = $('#' + id).data('lastScrollTop'); _handleScrollEvent(elementId, eventInfoFromEvent, currentEvent.originalEvent, currentTop < lastTop, currentTop > lastTop, map); $('#' + id).data('lastScrollTop', currentTop); }); })(panelId); } } // Attach synthetic hover event if (map && map.onMouseHover) { var MIN_HOVER_HOLD_TIME = 1000; // So when the timeout fires, you know whether it is the same mouseenter that is active or not. var hoverMouseCount = 0; // Update eventInfo regularly, so position is accurate. var hoverEventInfo; $element.mouseenter(function(e) { $ax.setjBrowserEvent(e); hoverEventInfo = $ax.getEventInfoFromEvent($ax.getjBrowserEvent(), false, elementId); (function(currCount) { window.setTimeout(function() { if(currCount == hoverMouseCount) _raiseSyntheticEvent(elementId, 'onMouseHover', false, hoverEventInfo, true); }, MIN_HOVER_HOLD_TIME); })(hoverMouseCount); }).mouseleave(function(e) { $ax.setjBrowserEvent(e); hoverMouseCount++; }).mousemove(function(e) { $ax.setjBrowserEvent(e); hoverEventInfo = $ax.getEventInfoFromEvent($ax.getjBrowserEvent(), false, elementId); }); } // Attach synthetic tap and hold event. if (map && map.onLongClick) { var MIN_LONG_CLICK_HOLD_TIME = 750; // So when the timeout fires, you know whether it is the same mousedown that is active or not. var longClickMouseCount = 0; $element.bind($ax.features.eventNames.mouseDownName, function(e) { (function(currCount) { $ax.setjBrowserEvent(e); var eventInfo = $ax.getEventInfoFromEvent($ax.getjBrowserEvent(), false, elementId); window.setTimeout(function() { if(currCount == longClickMouseCount) _raiseSyntheticEvent(elementId, 'onLongClick', false, eventInfo, true); }, MIN_LONG_CLICK_HOLD_TIME); if(e.preventDefault) e.preventDefault(); })(longClickMouseCount); }).bind($ax.features.eventNames.mouseUpName, function(e) { $ax.setjBrowserEvent(e); longClickMouseCount++; }); }; // Attach synthetic onSelectionChange event to droplist and listbox elements if ($ax.event.HasSelectionChanged(dObj)) { $element.bind('change', function(e) { $ax.setjBrowserEvent(e); _raiseSyntheticEvent(elementId, 'onSelectionChange'); }); }; // Highjack key up and key down to keep track of state of keyboard. if($ax.event.HasKeyUpOrDown(dObj)) _event.initKeyEvents($element); // Attach synthetic onTextChange event to textbox and textarea elements if ($ax.event.HasTextChanged(dObj)) { var element = $jobj($ax.INPUT(elementId)); $ax.updateElementText(elementId, element.val()); //Key down needed because when holding a key down, key up only fires once, but keydown fires repeatedly. //Key up because last mouse down will only show the state before the last character. element.bind('keydown', function(e) { $ax.setjBrowserEvent(e); $ax.event.TryFireTextChanged(elementId); }).bind('keyup', function(e) { $ax.setjBrowserEvent(e); $ax.event.TryFireTextChanged(elementId); }); }; // Attach synthetic onCheckedChange event to radiobutton and checkbox elements if ($ax.public.fn.IsCheckBox(dObj.type) || $ax.public.fn.IsRadioButton(dObj.type)) { var input = $jobj($ax.INPUT(elementId)); if ($ax.public.fn.IsRadioButton(dObj.type) && input.prop('checked')) { $ax.updateRadioButtonSelected(input.attr('name'), elementId); } $element.bind('change', function(e) { $ax.setjBrowserEvent(e); var eTarget = e.target || e.srcElement; _tryFireCheckedChanged(elementId, eTarget.checked); }); }; var hasTap = map && (map.onClick || map.onDoubleClick); var hasMove = map && map.onMouseMove; _event.initMobileEvents(hasTap ? $element : $(), hasMove ? $element : $(), elementId); //attach link alternate styles if(dObj.type == 'hyperlink') { $element.mouseenter(function() { var linkId = this.id; if(_event.mouseOverIds.indexOf(linkId) != -1) return true; _event.mouseOverIds[_event.mouseOverIds.length] = linkId; var mouseOverObjectId = _event.mouseOverObjectId; if(mouseOverObjectId && $ax.style.IsWidgetDisabled(mouseOverObjectId)) return true; $ax.style.SetLinkHover(linkId); var bubble = _fireObjectEvent(linkId, 'mouseenter', arguments); $ax.annotation.updateLinkLocations($ax.GetParentIdFromLink(linkId)); return bubble; }).mouseleave(function() { var linkId = this.id; $ax.splice(_event.mouseOverIds, _event.mouseOverIds.indexOf(linkId), 1); var mouseOverObjectId = _event.mouseOverObjectId; if(mouseOverObjectId && $ax.style.IsWidgetDisabled(mouseOverObjectId)) return true; $ax.style.SetLinkNotHover(linkId); var bubble = _fireObjectEvent(linkId, 'mouseleave', arguments); $ax.annotation.updateLinkLocations($ax.GetParentIdFromLink(linkId)); return bubble; }).bind($ax.features.eventNames.mouseDownName, function() { var linkId = this.id; var mouseOverObjectId = _event.mouseOverObjectId; if($ax.style.IsWidgetDisabled(mouseOverObjectId)) return undefined; if(mouseOverObjectId) $ax.style.SetWidgetMouseDown(mouseOverObjectId, true); $ax.style.SetLinkMouseDown(linkId); $ax.annotation.updateLinkLocations($ax.GetParentIdFromLink(linkId)); return false; }).bind($ax.features.eventNames.mouseUpName, function() { var linkId = this.id; var mouseOverObjectId = _event.mouseOverObjectId; if(mouseOverObjectId && $ax.style.IsWidgetDisabled(mouseOverObjectId)) return; if(mouseOverObjectId) $ax.style.SetWidgetMouseDown(mouseOverObjectId, false); $ax.style.SetLinkNotMouseDown(linkId); $ax.annotation.updateLinkLocations($ax.GetParentIdFromLink(linkId)); }).click(function() { var elementId = this.id; var mouseOverObjectId = _event.mouseOverObjectId; if(mouseOverObjectId && $ax.style.IsWidgetDisabled(mouseOverObjectId)) return undefined; return _fireObjectEvent(elementId, 'click', arguments); }); } // Init inline frames if (dObj.type == 'inlineFrame') { var target = dObj.target; var url = ''; if(target.includeVariables && target.url) { var origSrc = target.url; url = origSrc.toLowerCase().indexOf('http://') == -1 ? $ax.globalVariableProvider.getLinkUrl(origSrc) : origSrc; } else if(target.urlLiteral) { url = $ax.expr.evaluateExpr(target.urlLiteral, $ax.getEventInfoFromEvent(undefined, true, elementId), true); } if(url) $jobj($ax.INPUT(elementId)).attr('src', url); }; }); } $ax.initializeObjectEvents = _initializeObjectEvents; $ax.event.updateIxStyleEvents = function(elementId) { _dettachIxStyleEvents(elementId); _attachIxStyleEvents($ax.getObjectFromElementId(elementId), elementId, $jobj(elementId), true); } function clearMouseDownIxStyle(e) { if(_event.mouseDownObjectId) { $('#' + _event.mouseDownObjectId).trigger( { type: \"mouseup\", checkMouseOver: e.data && e.data.checkMouseOver } ); } } var _dettachIxStyleEvents = function(elementId) { var $element = $jobj(elementId); $element.off('mouseenter.ixStyle') .off('mouseleave.ixStyle') .off($ax.features.eventNames.mouseDownName + '.ixStyle') .off($ax.features.eventNames.mouseUpName + '.ixStyle'); } var _attachIxStyleEvents = function(dObj, elementId, $element, ignoreHasIxStyles) { //attach button shape alternate styles var isDynamicPanel = $ax.public.fn.IsDynamicPanel(dObj.type); var needsMouseFilter = (ignoreHasIxStyles || $ax.event.HasIxStyles(dObj)) && dObj.type != 'hyperlink' && !$ax.public.fn.IsLayer(dObj.type) && !isDynamicPanel && dObj.type != $ax.constants.TEXT_TYPE && !$ax.public.fn.IsRepeater(dObj.type) && !$ax.public.fn.IsCheckBox(dObj.type) && !$ax.public.fn.IsRadioButton(dObj.type) && !$ax.public.fn.IsTreeNodeObject(dObj.type); if(needsMouseFilter) { //$element.mouseenter(function () { $element.on('mouseenter.ixStyle', function () { var elementId = this.id; var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent && parent.direct) return; if($.inArray(elementId, _event.mouseOverIds) != -1) return; _event.mouseOverIds[_event.mouseOverIds.length] = elementId; if(elementId == _event.mouseOverObjectId) return; _event.mouseOverObjectId = elementId; $ax.style.SetWidgetHover(elementId, true); $ax.annotation.updateLinkLocations(elementId); //}).mouseleave(function () { }).on('mouseleave.ixStyle', function () { var elementId = this.id; var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent && parent.direct) return; $ax.splice(_event.mouseOverIds, $.inArray(elementId, _event.mouseOverIds), 1); if(elementId == _event.mouseOverObjectId) { _event.mouseOverObjectId = ''; } $ax.style.SetWidgetHover(elementId, false); $ax.annotation.updateLinkLocations(elementId); }); //$element.bind($ax.features.eventNames.mouseDownName, function () { $element.on($ax.features.eventNames.mouseDownName + '.ixStyle', function () { var elementId = this.id; var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent) { dynamicPanelMouseDown(parent.id); if(parent.direct) return; } _event.mouseDownObjectId = elementId; //since we don't do mouse capture, it's possible that the mouseup not get triggered later //in that case, detect the mouseup on document and dragend $(document).one(\"mouseup\", {checkMouseOver: true}, clearMouseDownIxStyle); $(\"#\" + elementId).one(\"dragend\", clearMouseDownIxStyle); $ax.style.SetWidgetMouseDown(this.id, true); $ax.annotation.updateLinkLocations(elementId); //}).bind($ax.features.eventNames.mouseUpName, function () { }).on($ax.features.eventNames.mouseUpName + '.ixStyle', function (e) { var elementId = this.id; var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent) { dynamicPanelMouseUp(parent.id); if(parent.direct) return; } $(document).off(\"mouseup\", clearMouseDownIxStyle); $(\"#\" + _event.mouseDownObjectId).off(\"dragend\", clearMouseDownIxStyle); _event.mouseDownObjectId = ''; if(!$ax.style.ObjHasMouseDown(elementId)) return; $ax.style.SetWidgetMouseDown(elementId, false, e.checkMouseOver); $ax.annotation.updateLinkLocations(elementId); //there used to be something we needed to make images click, because swapping out the images prevents the click // this is a note that we can eventually delete. }); } }; var dynamicPanelMouseDown = function (elementId) { var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent) { dynamicPanelMouseDown(parent.id); if(parent.direct) return; } _event.mouseDownObjectId = elementId; $ax.dynamicPanelManager.propagateMouseDown(elementId, true); }; var dynamicPanelMouseUp = function (elementId) { var parent = $ax.dynamicPanelManager.parentHandlesStyles(elementId); if(parent) { dynamicPanelMouseUp(parent.id); if(parent.direct) return; } _event.mouseDownObjectId = ''; $ax.dynamicPanelManager.propagateMouseDown(elementId, false); }; // Handle key up and key down events (function() { var _keyState = {}; _keyState.ctrl = false; _keyState.alt = false; _keyState.shift = false; _keyState.keyCode = 0; $ax.event.keyState = function() { return $ax.deepCopy(_keyState); }; var modifierCodes = [16, 17, 18]; var clearKeyCode = false; $ax.event.initKeyEvents = function($query) { $query.keydown(function (e) { if(clearKeyCode) { clearKeyCode = false; _keyState.keyCode = 0; } var elementId = this.id; _keyState.ctrl = e.ctrlKey; _keyState.alt = e.altKey; _keyState.shift = e.shiftKey; // If a modifier was pressed, then don't set the keyCode; if(modifierCodes.indexOf(e.keyCode) == -1) _keyState.keyCode = e.keyCode; $ax.setjBrowserEvent(e); if (!elementId) fireEventThroughContainers('onKeyDown', undefined, false, [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE, $ax.constants.REPEATER], [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.LAYER_TYPE]); else _raiseSyntheticEvent(elementId, 'onKeyDown', false, undefined, true); }); $query.keyup(function(e) { var elementId = this.id; if (modifierCodes.indexOf(e.keyCode) == -1) clearKeyCode = true; else if (clearKeyCode) { clearKeyCode = false; _keyState.keyCode = 0; } $ax.setjBrowserEvent(e); // Fire event before updating modifiers. if (!elementId) fireEventThroughContainers('onKeyUp', undefined, false, [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE, $ax.constants.REPEATER], [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.LAYER_TYPE]); else _raiseSyntheticEvent(elementId, 'onKeyUp', false, undefined, true); //_keyState.ctrl = e.ctrlKey; //_keyState.alt = e.altKey; //_keyState.shift = e.shiftKey; //// If a non-modifier was lifted, clear the keycode ///if(modifierCodes.indexOf(e.keyCode) == -1) _keyState.keyCode = 0; }); }; })(); // Handle adding mobile events (function() { // NOTE: Multi touch is NOT handled currently. var CLICK_THRESHOLD_PX = 25; var CLICK_THRESHOLD_PX_SQ = CLICK_THRESHOLD_PX * CLICK_THRESHOLD_PX; var DBLCLICK_THRESHOLD_MS = 500; // Location in page cooridinates var tapDownLoc; var lastClickEventTime; _event.initMobileEvents = function($tapQuery, $moveQuery, elementId) { if(!$ax.features.supports.mobile) return; // Handle touch start $tapQuery.bind('touchstart', function(e) { // We do NOT support multiple touches. This isn't necessarily the touch we want. var touch = e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]; if(!touch) return; tapDownLoc = [touch.pageX, touch.pageY]; var time = (new Date()).getTime(); if(time - lastClickEventTime < DBLCLICK_THRESHOLD_MS) { var dObj = elementId === '' ? $ax.pageData.page : $ax.getObjectFromElementId(elementId); var axEventObject = dObj && dObj.interactionMap && dObj.interactionMap['onDoubleClick']; if(axEventObject) e.preventDefault(); //for Chrome on Android } }).bind('touchend', function(e) { var touch = e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]; if(!touch || !tapDownLoc || $ax.style.IsWidgetDisabled(elementId)) return; var tapUpLoc = [touch.pageX, touch.pageY]; var xDiff = tapUpLoc[0] - tapDownLoc[0]; var yDiff = tapUpLoc[1] - tapDownLoc[1]; if((xDiff * xDiff + yDiff * yDiff) < CLICK_THRESHOLD_PX_SQ) { $ax.setjBrowserEvent(e); _raiseSyntheticEvent(elementId, 'onClick', false, undefined, true); var time = (new Date()).getTime(); if(time - lastClickEventTime < DBLCLICK_THRESHOLD_MS) { _raiseSyntheticEvent(elementId, 'onDoubleClick', false, undefined, true); if(e.originalEvent && e.originalEvent.handled) e.preventDefault(); //for iOS } lastClickEventTime = time; } }); // Handles touch move $moveQuery.bind('touchmove', function(e) { $ax.setjBrowserEvent(e); _raiseSyntheticEvent(elementId, 'onMouseMove', false, undefined, true); if(e.originalEvent && e.originalEvent.handled) e.preventDefault(); }); }; })(); // Handle adding device independent click events to non-widgets (function() { var CLICK_THRESHOLD_PX = 25; var CLICK_THRESHOLD_PX_SQ = CLICK_THRESHOLD_PX * CLICK_THRESHOLD_PX; // Location in page cooridinates var tapDownLoc; _event.attachClick = function(query, clickHandler) { if(!$ax.features.supports.mobile) { query.click(clickHandler); return; } $(query).bind('touchstart', function(e) { // We do NOT support multiple touches. This isn't necessarily the touch we want. var touch = e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]; if(!touch) return; tapDownLoc = [touch.pageX, touch.pageY]; }); $(query).bind('touchend', function(e) { var touch = e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]; if(!touch) return; var tapUpLoc = [touch.pageX, touch.pageY]; var xDiff = tapUpLoc[0] - tapDownLoc[0]; var yDiff = tapUpLoc[1] - tapDownLoc[1]; if((xDiff * xDiff + yDiff * yDiff) < CLICK_THRESHOLD_PX_SQ) { clickHandler(); } }); }; })(); // Handle firing device independent click events on widgets (function() { _event.fireClick = function(elementId) { if(!$ax.features.supports.mobile) { $('#' + elementId).click(); return; } _raiseSyntheticEvent(elementId, 'onClick', false, undefined, true); }; })(); var _mouseLocation = $ax.mouseLocation = { x: 0, y: 0 }; var _lastmouseLocation = $ax.lastMouseLocation = { x: 0, y: 0 }; var _updateMouseLocation = function(e, end) { if(!e) return; if(IE_10_AND_BELOW && typeof (e.type) == 'unknown') return; if(e.type != 'mousemove' && e.type != 'touchstart' && e.type != 'touchmove' && e.type != 'touchend') return; var newX; var newY; if(IE_10_AND_BELOW) { newX = e.clientX + $('html').scrollLeft(); newY = e.clientY + $('html').scrollTop(); } else { newX = e.pageX; newY = e.pageY; } //var body = $('body'); //if(body.css('position') == 'relative') newX = Math.round(newX - Number(body.css('left').replace('px', '')) - Math.max(0, ($(window).width() - body.width()) / 2)); if(_mouseLocation.x == newX && _mouseLocation.y == newY) return; _lastmouseLocation.x = _mouseLocation.x; _lastmouseLocation.y = _mouseLocation.y; _mouseLocation.x = newX; _mouseLocation.y = newY; $ax.geometry.tick(_mouseLocation.x, _mouseLocation.y, end); }; _event.updateMouseLocation = _updateMouseLocation; var _leavingState = function(stateId) { var mouseOverIds = _event.mouseOverIds; if(mouseOverIds.length == 0) return; var stateQuery = $jobj(stateId); for(var i = mouseOverIds.length - 1; i >= 0; i--) { var id = mouseOverIds[i]; if(stateQuery.find('#' + id).length) { $ax.splice(mouseOverIds, $.inArray(id, mouseOverIds), 1); $ax.style.SetWidgetMouseDown(id, false); $ax.style.SetWidgetHover(id, false); } } }; _event.leavingState = _leavingState; var _raiseSelectedEvents = function(elementId, value) { $ax.event.raiseSyntheticEvent(elementId, 'onSelectedChange'); if(value) $ax.event.raiseSyntheticEvent(elementId, 'onSelect'); else $ax.event.raiseSyntheticEvent(elementId, 'onUnselect'); }; $ax.event.raiseSelectedEvents = _raiseSelectedEvents; var _raiseSyntheticEvent = function(elementId, eventName, skipShowDescription, eventInfo, nonSynthetic) { // Empty string used when this is an event directly on the page. var dObj = elementId === '' ? $ax.pageData.page : $ax.getObjectFromElementId(elementId); var axEventObject = dObj && dObj.interactionMap && dObj.interactionMap[eventName]; if(!axEventObject) return; eventInfo = eventInfo || $ax.getEventInfoFromEvent($ax.getjBrowserEvent(), skipShowDescription, elementId); // $ax.recording.maybeRecordEvent(elementId, eventInfo, axEventObject, new Date().getTime()); _handleEvent(elementId, eventInfo, axEventObject, false, !nonSynthetic); }; $ax.event.raiseSyntheticEvent = _raiseSyntheticEvent; var _hasSyntheticEvent = function(scriptId, eventName) { var dObj = $ax.getObjectFromScriptId(scriptId); var axEventObject = dObj && dObj.interactionMap && dObj.interactionMap[eventName]; return Boolean(axEventObject); }; $ax.event.hasSyntheticEvent = _hasSyntheticEvent; var _addEvent = function (target, eventType, handler, useCapture) { //this return value is only for debug purpose var succeed = undefined; if(target.attachEvent) { if($ax.features.supports.windowsMobile) { succeed = target.attachEvent(eventType, handler); } else { succeed = target.attachEvent('on' + eventType, handler); } } else if(target.addEventListener) { target.addEventListener(eventType, handler, useCapture); succeed = true; } return succeed; } $ax.event.addEvent = _addEvent; var _removeEvent = function(target, eventType, handler, useCapture, skipCheckingWindowsMobile) { //this return value is only for debug purpose var succeed = undefined; if(target.detachEvent) { if(!skipCheckingWindowsMobile && $ax.features.supports.windowsMobile) { succeed = target.detachEvent(eventType, handler); } else { succeed = target.detachEvent('on' + eventType, handler); } } else if(target.removeEventListener) { target.removeEventListener(eventType, handler, useCapture); succeed = true; } return succeed; } $ax.event.removeEvent = _removeEvent; var _initialize = function() { $ax.repeater.load(); // Make sure key events for page are initialized first. That way they will update the value of key pressed before any other events occur. _event.initKeyEvents($(window)); initSuppressingEvents(); // Anything with an item id is in a repeater and should be handled by that repeater. _initializeObjectEvents($ax(function(obj, elementId) { return !$ax.repeater.getItemIdFromElementId(elementId); })); //finally, process the pageload _pageLoad(); // _loadDynamicPanelsAndMasters(); // $ax.repeater.init(); // and wipe out the basic links. $('.basiclink').click(function() { return false; }); }; _event.initialize = _initialize; $ax.event.HasIxStyles = function(diagramObject) { if(diagramObject.style.stateStyles) return true; if(diagramObject.adaptiveStyles) { for(var viewId in diagramObject.adaptiveStyles) { if(diagramObject.adaptiveStyles[viewId].stateStyles) return true; } } return false; }; $ax.event.HasTextChanged = function(diagramObject) { if (!$ax.public.fn.IsTextBox(diagramObject.type) && !$ax.public.fn.IsTextArea(diagramObject.type)) return false; var map = diagramObject.interactionMap; return map && map.onTextChange; }; $ax.event.TryFireTextChanged = function(elementId) { var query = $jobj($ax.repeater.applySuffixToElementId(elementId, '_input')); if(!$ax.hasElementTextChanged(elementId, query.val())) return; $ax.updateElementText(elementId, query.val()); $ax.event.raiseSyntheticEvent(elementId, 'onTextChange'); }; $ax.event.HasSelectionChanged = function(diagramObject) { if (!$ax.public.fn.IsListBox(diagramObject.type) && !$ax.public.fn.IsComboBox(diagramObject.type)) return false; var map = diagramObject.interactionMap; return map && map.onSelectionChange; }; $ax.event.HasKeyUpOrDown = function (diagramObject) { if($ax.public.fn.IsTextBox(diagramObject.type) || $ax.public.fn.IsTextArea(diagramObject.type)) return true; var map = diagramObject.interactionMap; return map && (map.onKeyUp || map.onKeyDown); }; $ax.event.HasCheckedChanged = function(diagramObject) { if (!$ax.public.fn.IsCheckBox(diagramObject.type) && !$ax.public.fn.IsRadioButton(diagramObject.type)) return false; var map = diagramObject.interactionMap; return map && map.onSelectedChange; }; $ax.event.HasClick = function (diagramObject) { var map = diagramObject.interactionMap; return map && map.onClick; }; var _tryFireCheckedChanged = $ax.event.TryFireCheckChanged = function(elementId, value) { var isRadio = $ax.public.fn.IsRadioButton($obj(elementId).type); if(isRadio) { if(!value) { $ax.updateRadioButtonSelected($jobj($ax.INPUT(elementId)).attr('name'), undefined); } else { var last = $ax.updateRadioButtonSelected($jobj($ax.INPUT(elementId)).attr('name'), elementId); // If no change, this should not fire if(last == elementId) return; // Initially selecting one, last may be undefined if(last) { //here last is the previouse selected elementid $ax.event.raiseSelectedEvents(last, false); } } } $ax.event.raiseSelectedEvents(elementId, value); }; //onload everything now, not only dp and master var _loadDynamicPanelsAndMasters = function(objects, path, itemId) { fireEventThroughContainers('onLoad', objects, true, [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE], [$ax.constants.ALL_TYPE], path, itemId); }; $ax.loadDynamicPanelsAndMasters = _loadDynamicPanelsAndMasters; var _viewChangePageAndMasters = function(forceSwitchTo) { fireEventThroughContainers('onAdaptiveViewChange', undefined, true, [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE], [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE]); _postAdaptiveViewChanged(forceSwitchTo); }; $ax.viewChangePageAndMasters = _viewChangePageAndMasters; //if forceSwitchTo is true, we will also update the checkmark in sitemap.js var _postAdaptiveViewChanged = function(forceSwitchTo) { //only trigger adaptive view changed if the window is on the mainframe. Also triggered on init, even if default. try { if(window.name == 'mainFrame' || (!CHROME_5_LOCAL && window.parent.$ && window.parent.$('#mainFrame').length > 0)) { var data = { viewId: $ax.adaptive.currentViewId, forceSwitchTo: forceSwitchTo }; $axure.messageCenter.postMessage('adaptiveViewChange', data); } } catch(e) { } }; $ax.postAdaptiveViewChanged = _postAdaptiveViewChanged; var _postResize = $ax.postResize = function(e) { $ax.setjBrowserEvent(e); return fireEventThroughContainers('onResize', undefined, false, [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE, $ax.constants.REPEATER], [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE]); }; //fire events for table, menu and tree, including its sub items var _fireEventsForTableMenuAndTree = function (object, event, skipShowDescription, eventInfo, path, synthetic) { if (!path) path = []; var pathCopy = path.slice(); pathCopy[path.length] = object.id; var scriptId = $ax.getScriptIdFromPath(pathCopy); $ax.event.raiseSyntheticEvent(scriptId, event, skipShowDescription, eventInfo, !synthetic); if(object.objects) { for(var index = 0; index < object.objects.length; index++) { var subObj = object.objects[index]; if ($ax.public.fn.IsTableCell(subObj.type)) { pathCopy[path.length] = subObj.id; scriptId = $ax.getScriptIdFromPath(pathCopy); $ax.event.raiseSyntheticEvent(scriptId, event, skipShowDescription, eventInfo, !synthetic); } else if ($ax.public.fn.IsTable(object.type) || $ax.public.fn.IsMenuObject(object.type) || $ax.public.fn.IsTreeNodeObject(object.type)) { _fireEventsForTableMenuAndTree(subObj, event, skipShowDescription, eventInfo, path, synthetic); } } } } //remember the scroll bar position, so we can detect scroll up/down var lastScrollTop; var fireEventForPageOrMaster = function (elementId, eventName, interactionMap, isPage, skipShowDescription, synthetic) { if(!interactionMap) return; var axEvent = interactionMap[eventName]; var scrolling = eventName === \"onScroll\"; if (scrolling && !axEvent) axEvent = interactionMap.onScrollUp || interactionMap.onScrollDown; if (axEvent) { var currentEvent = $ax.getjBrowserEvent(); var eventInfo = $ax.getEventInfoFromEvent(currentEvent, skipShowDescription, elementId); if(isPage) { eventInfo.label = $ax.pageData.page.name; eventInfo.friendlyType = 'Page'; } else eventInfo.isMasterEvent = true; if(scrolling) _handleScrollEvent(elementId, eventInfo, currentEvent.originalEvent, _event.windowScrollingUp, _event.windowScrollingDown, interactionMap, skipShowDescription, synthetic); else _handleEvent(elementId, eventInfo, axEvent, skipShowDescription, synthetic); } } // Filters include page, referenceDiagramObject, dynamicPanel, and repeater. var _callFilterCheck = function(callFilter, type) { for(var index = 0; index < callFilter.length; index++) { var currentType = callFilter[index]; if(currentType === $ax.constants.ALL_TYPE || currentType === type) return true; } return false; }; var fireEventThroughContainers = function(eventName, objects, synthetic, searchFilter, callFilter, path, itemId) { // TODO: may want to pass in this as a parameter. At that point, may want to convert some of them to an option parameter. For now this is the only case var skipShowDescription = eventName == 'onLoad'; // If objects undefined, load page if(!objects) { if(_callFilterCheck(callFilter, $ax.constants.PAGE_TYPE)) { //if scrolling, set direction, later master will know if(eventName === \"onScroll\") { var currentScrollTop = $(window).scrollTop(); _event.windowScrollingUp = currentScrollTop < lastScrollTop; _event.windowScrollingDown = currentScrollTop > lastScrollTop; } fireEventForPageOrMaster('', eventName, $ax.pageData.page.interactionMap, true, skipShowDescription, synthetic); } if(searchFilter.indexOf($ax.constants.PAGE_TYPE) != -1) fireEventThroughContainers(eventName, $ax.pageData.page.diagram.objects, synthetic, searchFilter, callFilter); //reset and save scrolling info at the end if(currentScrollTop) { lastScrollTop = currentScrollTop; _event.windowScrollingUp = undefined; _event.windowScrollingDown = undefined; } return; } if(!path) path = []; var pathCopy = []; for(var j = 0; j < path.length; j++) pathCopy[j] = path[j]; for(var i = 0; i < objects.length; i++) { var obj = objects[i]; pathCopy[path.length] = obj.id; if (!$ax.public.fn.IsReferenceDiagramObject(obj.type) && !$ax.public.fn.IsDynamicPanel(obj.type) && !$ax.public.fn.IsRepeater(obj.type) && !$ax.public.fn.IsLayer(obj.type)) { if(_callFilterCheck(callFilter)) { //fire current event for all types if ($ax.public.fn.IsTable(obj.type) || $ax.public.fn.IsMenuObject(obj.type) || $ax.public.fn.IsTreeNodeObject(obj.type)) { _fireEventsForTableMenuAndTree(obj, eventName, skipShowDescription, undefined, path, !synthetic); } else { var scriptId = $ax.getScriptIdFromPath(pathCopy); if(scriptId && itemId) scriptId = $ax.repeater.createElementId(scriptId, itemId); $ax.event.raiseSyntheticEvent(scriptId, eventName, skipShowDescription, undefined, !synthetic); } } continue; } var objId = $ax.getScriptIdFromPath(pathCopy); // If limboed, move on to next item if(!objId) continue; if(itemId) objId = $ax.repeater.createElementId(objId, itemId); if($ax.public.fn.IsReferenceDiagramObject(obj.type)) { if(_callFilterCheck(callFilter, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE)) { fireEventForPageOrMaster(objId, eventName, $ax.pageData.masters[obj.masterId].interactionMap, false, skipShowDescription, synthetic); } if(searchFilter.indexOf($ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE) != -1) fireEventThroughContainers(eventName, $ax.pageData.masters[obj.masterId].diagram.objects, synthetic, searchFilter, callFilter, pathCopy, itemId); } else if($ax.public.fn.IsDynamicPanel(obj.type)) { if(_callFilterCheck(callFilter, $ax.constants.DYNAMIC_PANEL_TYPE)) $ax.event.raiseSyntheticEvent(objId, eventName, skipShowDescription, undefined, !synthetic); if(searchFilter.indexOf($ax.constants.DYNAMIC_PANEL_TYPE) != -1) { var diagrams = obj.diagrams; for(var j = 0; j < diagrams.length; j++) { fireEventThroughContainers(eventName, diagrams[j].objects, synthetic, searchFilter, callFilter, path, itemId); } } } else if($ax.public.fn.IsRepeater(obj.type)) { // TODO: possible an option for repeater item? Now fires overall for the repeater if(_callFilterCheck(callFilter, $ax.constants.REPEATER)) $ax.event.raiseSyntheticEvent(objId, eventName, skipShowDescription, undefined, !synthetic); if(searchFilter.indexOf($ax.constants.REPEATER) != -1) { var itemIds = $ax.getItemIdsForRepeater(objId); for(var j = 0; j < itemIds.length; j++) { fireEventThroughContainers(eventName, obj.objects, synthetic, searchFilter, callFilter, path, itemIds[j]); } } } else if($ax.public.fn.IsLayer(obj.type)) { if(_callFilterCheck(callFilter, $ax.constants.LAYER_TYPE)) $ax.event.raiseSyntheticEvent(objId, eventName, skipShowDescription, undefined, !synthetic); if(obj.objs && obj.objs.length > 0) { fireEventThroughContainers(eventName, obj.objs, synthetic, searchFilter, callFilter, path, itemId); } } } eventNesting -= 1; }; // FOCUS stuff (function() { })(); var _pageLoad = function() { // Map of axure event names to pair of what it should attach to, and what the jquery event name is. var PAGE_AXURE_TO_JQUERY_EVENT_NAMES = { 'onScroll': [window, 'scroll'], 'onScrollUp': [window, 'scrollup'], 'onScrollDown': [window, 'scrolldown'], //'onResize': [window, 'resize'], 'onContextMenu': [window, 'contextmenu'] }; var $win = $(window); if(!$ax.features.supports.mobile) { PAGE_AXURE_TO_JQUERY_EVENT_NAMES.onClick = ['html', 'click']; PAGE_AXURE_TO_JQUERY_EVENT_NAMES.onDoubleClick = ['html', 'dblclick']; PAGE_AXURE_TO_JQUERY_EVENT_NAMES.onMouseMove = ['html', 'mousemove']; } else { _event.initMobileEvents($win, $win, ''); $win.bind($ax.features.eventNames.mouseDownName, _updateMouseLocation); $win.bind($ax.features.eventNames.mouseUpName, function(e) { _updateMouseLocation(e, true); }); $win.scroll(function() { _setCanClick(false); }); $win.bind($ax.features.eventNames.mouseDownName, (function() { _setCanClick(true); })); } $win.bind($ax.features.eventNames.mouseMoveName, _updateMouseLocation); $win.scroll($ax.flyoutManager.reregisterAllFlyouts); for(key in PAGE_AXURE_TO_JQUERY_EVENT_NAMES) { if(!PAGE_AXURE_TO_JQUERY_EVENT_NAMES.hasOwnProperty(key)) continue; (function(axureName) { var jqueryEventNamePair = PAGE_AXURE_TO_JQUERY_EVENT_NAMES[axureName]; var actionName = jqueryEventNamePair[1]; if(actionName == \"scrollup\" || actionName == \"scrolldown\") return; $(jqueryEventNamePair[0])[actionName](function (e) { $ax.setjBrowserEvent(e); return fireEventThroughContainers(axureName, undefined, false, [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE, $ax.constants.REPEATER], [$ax.constants.PAGE_TYPE, $ax.constants.REFERENCE_DIAGRAM_OBJECT_TYPE]); }); })(key); } eventNesting -= 1; lastScrollTop = 0; }; _event.pageLoad = _pageLoad; }); //***** recording.js *****// // ******* Recording MANAGER ******** // $axure.internal(function($ax) { var _recording = $ax.recording = {}; $ax.recording.recordEvent = function(element, eventInfo, axEventObject, timeStamp) { var elementHtml = $jobj(element); var className = elementHtml.attr('class'); var inputValue; if(className === 'ax_checkbox') { inputValue = elementHtml.find('#' + element + '_input')[0].checked; eventInfo.inputType = className; eventInfo.inputValue = inputValue; } if(className === 'ax_text_field') { inputValue = elementHtml.find('#' + element + '_input').val(); eventInfo.inputType = className; eventInfo.inputValue = inputValue; } var scriptId = $ax.repeater.getScriptIdFromElementId(element); var diagramObjectPath = $ax.getPathFromScriptId(scriptId); var form = { recordingId: $ax.recording.recordingId, elementID: element, eventType: axEventObject.description, 'eventInfo': eventInfo, // eventObject: axEventObject, 'timeStamp': timeStamp, 'path': diagramObjectPath // , // 'trigger': function() { // $ax.event.handleEvent(element, eventInfo, axEventObject); // return false; // } }; $ax.messageCenter.postMessage('logEvent', form); }; $ax.recording.maybeRecordEvent = function(element, eventInfo, axEventObject, timeStamp) { }; $ax.recording.recordingId = \"\"; $ax.recording.recordingName = \"\"; $ax.messageCenter.addMessageListener(function(message, data) { if(message === 'startRecording') { $ax.recording.maybeRecordEvent = $ax.recording.recordEvent; $ax.recording.recordingId = data.recordingId; $ax.recording.recordingName = data.recordingName; } else if(message === 'stopRecording') { $ax.recording.maybeRecordEvent = function(element, eventInfo, axEventObject, timeStamp) { }; } else if(message === 'playEvent') { var eventType = makeFirstLetterLower(data.eventType); var inputElement; var dObj = data.element === '' ? $ax.pageData.page : $ax.getObjectFromElementId(data.element); if(!data.axEventObject) { data.axEventObject = dObj && dObj.interactionMap && dObj.interactionMap[eventType]; } data.eventInfo.thiswidget = $ax.getWidgetInfo(data.element); data.eventInfo.item = $ax.getItemInfo(data.element); if(data.eventInfo.inputType && data.eventInfo.inputType === 'ax_checkbox') { inputElement = $jobj(data.element + '_input'); inputElement[0].checked = data.eventInfo.inputValue; } if(data.eventInfo.inputType && data.eventInfo.inputType === 'ax_text_field') { inputElement = $jobj(data.element + '_input'); inputElement.val(data.eventInfo.inputValue); } $ax.event.handleEvent(data.element, data.eventInfo, data.axEventObject, false, true); } }); var makeFirstLetterLower = function(eventName) { return eventName.substr(0, 1).toLowerCase() + eventName.substr(1); }; }); //***** action.js *****// $axure.internal(function($ax) { var _actionHandlers = {}; var _action = $ax.action = {}; var queueTypes = _action.queueTypes = { none: 0, move: 1, setState: 2, fade: 3, resize: 4, rotate: 5 }; var animationQueue = {}; // using array as the key doesn't play nice var nextAnimationId = 1; var animationsToCount = {}; var actionToActionGroups = {}; var getAnimation = function(id, type) { return animationQueue[id] && animationQueue[id][type] && animationQueue[id][type][0]; }; var _addAnimation = _action.addAnimation = function (id, type, func, suppressFire) { var wasEmpty = !getAnimation(id, type); // Add the func to the queue. Create the queue if necessary. var idQueue = animationQueue[id]; if(!idQueue) animationQueue[id] = idQueue = {}; var queue = idQueue[type]; if(!queue) idQueue[type] = queue = []; queue[queue.length] = func; // If it was empty, there isn't a callback waiting to be called on this. You have to fire it manually. // If this is waiting on something, suppress it, and it will fire when it's ready if(wasEmpty && !suppressFire) func(); }; var _addAnimations = function (animations) { if(animations.length == 1) { _addAnimation(animations[0].id, animations[0].type, animations[0].func); return; } var allReady = true; var readyCount = 0; for(var i = 0; i < animations.length; i++) { var animation = animations[i]; var thisReady = !getAnimation(animation.id, animation.type); allReady = allReady && thisReady; if (thisReady) readyCount++; else { var typeToGroups = actionToActionGroups[animation.id]; if (!typeToGroups) actionToActionGroups[animation.id] = typeToGroups = {}; var groups = typeToGroups[animation.type]; if (!groups) typeToGroups[animation.type] = groups = []; groups[groups.length] = animations; } } for(i = 0; i < animations.length; i++) { animation = animations[i]; _addAnimation(animation.id, animation.type, animation.func, true); } if (allReady) { for (i = 0; i < animations.length; i++) animations[i].func(); } else { animations.id = nextAnimationId++; animationsToCount[animations.id] = readyCount; } } var _fireAnimationFromQueue = _action.fireAnimationFromQueue = function (id, type) { // Remove the function that was just fired if (animationQueue[id] && animationQueue[id][type]) $ax.splice(animationQueue[id][type], 0, 1); // Fire the next func if there is one var func = getAnimation(id, type); if(func && !_checkFireActionGroup(id, type, func)) func(); }; var _checkFireActionGroup = function(id, type, func) { var group = actionToActionGroups[id]; group = group && group[type]; if (!group || group.length == 0) return false; var animations = group[0]; var found = false; for (var i = 0; i < animations.length; i++) { var animation = animations[i]; if (animation.id == id && animation.type == type) { found = func == animation.func; break; } } // if found then update this action group, otherwise, keep waiting for right action to fire if(!found) return false; $ax.splice(group, 0, 1); var count = animationsToCount[animations.id] + 1; if(count != animations.length) { animationsToCount[animations.id] = count; return true; } delete animationsToCount[animations.id]; // Funcs is needed because an earlier func can try to cascade right away (when no animation for example) and will kill this func and move on to the // next one (which may not even exist). If we get all funcs before calling any, then we know they are all the func we want. var funcs = []; for(i = 0; i < animations.length; i++) { animation = animations[i]; funcs.push(getAnimation(animation.id, animation.type)); } for(i = 0; i < funcs.length; i++) { funcs[i](); } return true; } var _refreshing = []; _action.refreshStart = function(repeaterId) { _refreshing.push(repeaterId); }; _action.refreshEnd = function() { _refreshing.pop(); }; // TODO: [ben] Consider moving this to repeater.js var _repeatersToRefresh = _action.repeatersToRefresh = []; var _ignoreAction = function(repeaterId) { for(var i = 0; i < _refreshing.length; i++) if(_refreshing[i] == repeaterId) return true; return false; }; var _addRefresh = function(repeaterId) { if(_repeatersToRefresh.indexOf(repeaterId) == -1) _repeatersToRefresh.push(repeaterId); }; var _getIdToResizeMoveState = function(eventInfo) { if(!eventInfo.idToResizeMoveState) eventInfo.idToResizeMoveState = {}; return eventInfo.idToResizeMoveState; } var _queueResizeMove = function (id, type, eventInfo, actionInfo) { if (type == queueTypes.resize || type == queueTypes.rotate) $ax.public.fn.convertToSingleImage($jobj(id)); var idToResizeMoveState = _getIdToResizeMoveState(eventInfo); if(!idToResizeMoveState[id]) { idToResizeMoveState[id] = {}; idToResizeMoveState[id][queueTypes.move] = { queue: [], used: 0 }; idToResizeMoveState[id][queueTypes.resize] = { queue: [], used: 0 }; idToResizeMoveState[id][queueTypes.rotate] = { queue: [], used: 0 }; } var state = idToResizeMoveState[id]; // If this is not a type being queued (no action of it's type waiting already) then if it is an instant, fire right away. var myOptions = type == queueTypes.resize ? actionInfo : actionInfo.options; if(!state[type].queue.length && (!myOptions.easing || myOptions.easing == 'none' || !myOptions.duration)) { var func = type == queueTypes.resize ? _addResize : type == queueTypes.rotate ? _addRotate : _addMove; func(id, eventInfo, actionInfo, { easing: 'none', duration: 0, stop: { instant: true } }); return; } // Check other 2 types to see if either is empty, if so, we can't do anything, so just queue it up var otherType1 = type == queueTypes.move ? queueTypes.resize : queueTypes.move; var otherType2 = type == queueTypes.rotate ? queueTypes.resize : queueTypes.rotate; if (!state[otherType1].queue.length || !state[otherType2].queue.length) { state[type].queue.push({ eventInfo: eventInfo, actionInfo: actionInfo }); } else { var duration = myOptions.duration; var used1 = state[otherType1].used; var used2 = state[otherType2].used; while(state[otherType1].queue.length && state[otherType2].queue.length && duration != 0) { var other1 = state[otherType1].queue[0]; var otherOptions1 = otherType1 == queueTypes.resize ? other1.actionInfo : other1.actionInfo.options; // If queue up action is a non animation, then don't combo it, just queue it and move on if(!otherOptions1.easing || otherOptions1.easing == 'none' || !otherOptions1.duration) { func = otherType1 == queueTypes.resize ? _addResize : otherType1 == queueTypes.rotate ? _addRotate : _addMove; func(id, eventInfo, actionInfo, { easing: 'none', duration: 0, stop: { instant: true } }); continue; } var other2 = state[otherType2].queue[0]; var otherOptions2 = otherType2 == queueTypes.resize ? other2.actionInfo : other2.actionInfo.options; // If queue up action is a non animation, then don't combo it, just queue it and move on if(!otherOptions2.easing || otherOptions2.easing == 'none' || !otherOptions2.duration) { func = otherType2 == queueTypes.resize ? _addResize : otherType2 == queueTypes.rotate ? _addRotate : _addMove; func(id, eventInfo, actionInfo, { easing: 'none', duration: 0, stop: { instant: true } }); continue; } // Other duration is what is left over. When in queue it may be partly finished already var otherDuration1 = otherOptions1.duration - used1; var otherDuration2 = otherOptions2.duration - used2; var resizeInfo = type == queueTypes.resize ? actionInfo : otherType1 == queueTypes.resize ? other1.actionInfo : other2.actionInfo; var rotateInfo = type == queueTypes.rotate ? actionInfo : otherType1 == queueTypes.rotate ? other1.actionInfo : other2.actionInfo; var moveInfo = type == queueTypes.move ? actionInfo : otherType1 == queueTypes.move ? other1.actionInfo : other2.actionInfo; var options = { easing: moveInfo.options.easing, duration: Math.min(duration, otherDuration1, otherDuration2) }; // Start for self is whole duration - duration left, end is start plus duration of combo to be queued, length is duration var stop = { start: myOptions.duration - duration, len: myOptions.duration }; stop.end = stop.start + options.duration; // Start for other is used (will be 0 after 1st round), end is start plus length is duration of combo to be queued, length is other duration var otherStop1 = { start: used1, end: options.duration + used1, len: otherOptions1.duration }; var otherStop2 = { start: used2, end: options.duration + used2, len: otherOptions2.duration }; options.stop = type == queueTypes.resize ? stop : otherType1 == queueTypes.resize ? otherStop1 : otherStop2; options.moveStop = type == queueTypes.move ? stop : otherType1 == queueTypes.move ? otherStop1 : otherStop2; options.rotateStop = type == queueTypes.rotate ? stop : otherType1 == queueTypes.rotate ? otherStop1 : otherStop2; _addResize(id, eventInfo, resizeInfo, options, moveInfo, rotateInfo); // Update duration for this animation duration -= options.duration; // For others update used and remove from queue if necessary if(otherDuration1 == options.duration) { $ax.splice(state[otherType1].queue, 0, 1); used1 = 0; } else used1 += options.duration; if(otherDuration2 == options.duration) { $ax.splice(state[otherType2].queue, 0, 1); used2 = 0; } else used2 += options.duration; } // Start queue for new type if necessary if(duration) { state[type].queue.push({ eventInfo: eventInfo, actionInfo: actionInfo }); state[type].used = myOptions.duration - duration; } // Update used for others state[otherType1].used = used1; state[otherType2].used = used2; } }; _action.flushAllResizeMoveActions = function (eventInfo) { var idToResizeMoveState = _getIdToResizeMoveState(eventInfo); for(var id in idToResizeMoveState) _flushResizeMoveActions(id, idToResizeMoveState); }; var _flushResizeMoveActions = function(id, idToResizeMoveState) { var state = idToResizeMoveState[id]; var move = state[queueTypes.move]; var moveInfo = move.queue[0]; var resize = state[queueTypes.resize]; var resizeInfo = resize.queue[0]; var rotate = state[queueTypes.rotate]; var rotateInfo = rotate.queue[0]; while (moveInfo || resizeInfo || rotateInfo) { var eventInfo = moveInfo ? moveInfo.eventInfo : resizeInfo ? resizeInfo.eventInfo : rotateInfo.eventInfo; moveInfo = moveInfo && moveInfo.actionInfo; resizeInfo = resizeInfo && resizeInfo.actionInfo; rotateInfo = rotateInfo && rotateInfo.actionInfo; // Resize is used by default, then rotate if(resizeInfo) { // Check for instant resize if(!resizeInfo.duration || resizeInfo.easing == 'none') { _addResize(id, resize.queue[0].eventInfo, resizeInfo, { easing: 'none', duration: 0, stop: { instant: true } }); _updateResizeMoveUsed(id, queueTypes.resize, 0, idToResizeMoveState); resizeInfo = resize.queue[0]; continue; } var duration = resizeInfo.duration - resize.used; if(moveInfo) duration = Math.min(duration, moveInfo.options.duration - move.used); if(rotateInfo) duration = Math.min(duration, rotateInfo.options.duration - rotate.used); var baseOptions = moveInfo ? moveInfo.options : resizeInfo; var options = { easing: baseOptions.easing, duration: duration }; options.stop = { start: resize.used, end: resize.used + duration, len: resizeInfo.duration }; if(moveInfo) options.moveStop = { start: move.used, end: move.used + duration, len: moveInfo.options.duration }; if(rotateInfo) options.rotateStop = { start: rotate.used, end: rotate.used + duration, len: rotateInfo.options.duration }; _addResize(id, eventInfo, resizeInfo, options, moveInfo, rotateInfo); _updateResizeMoveUsed(id, queueTypes.resize, duration, idToResizeMoveState); resizeInfo = resize.queue[0]; if(rotateInfo) { _updateResizeMoveUsed(id, queueTypes.rotate, duration, idToResizeMoveState); rotateInfo = rotate.queue[0]; } if(moveInfo) { _updateResizeMoveUsed(id, queueTypes.move, duration, idToResizeMoveState); moveInfo = move.queue[0]; } } else if (rotateInfo) { // Check for instant rotate if(!rotateInfo.options.duration || rotateInfo.options.easing == 'none') { _addRotate(id, rotate.queue[0].eventInfo, rotateInfo, { easing: 'none', duration: 0, stop: { instant: true } }); _updateResizeMoveUsed(id, queueTypes.rotate, 0, idToResizeMoveState); rotateInfo = rotate.queue[0]; continue; } duration = rotateInfo.options.duration - rotate.used; if(moveInfo) duration = Math.min(duration, moveInfo.options.duration - move.used); baseOptions = moveInfo ? moveInfo.options : rotateInfo.options; options = { easing: baseOptions.easing, duration: duration }; options.stop = { start: rotate.used, end: rotate.used + duration, len: rotateInfo.options.duration }; if(moveInfo) options.moveStop = { start: move.used, end: move.used + duration, len: moveInfo.options.duration }; _addRotate(id, eventInfo, rotateInfo, options, moveInfo); _updateResizeMoveUsed(id, queueTypes.rotate, duration, idToResizeMoveState); rotateInfo = rotate.queue[0]; if(moveInfo) { _updateResizeMoveUsed(id, queueTypes.move, duration, idToResizeMoveState); moveInfo = move.queue[0]; } } else { if(!moveInfo.options.duration || moveInfo.options.easing == 'none') { _addMove(id, eventInfo, moveInfo, { easing: 'none', duration: 0, stop: { instant: true } }); _updateResizeMoveUsed(id, queueTypes.move, 0, idToResizeMoveState); moveInfo = move.queue[0]; continue; } duration = moveInfo.options.duration - move.used; options = { easing: moveInfo.options.easing, duration: duration }; options.stop = { start: move.used, end: moveInfo.options.duration, len: moveInfo.options.duration }; _addMove(id, eventInfo, moveInfo, options); _updateResizeMoveUsed(id, queueTypes.move, duration, idToResizeMoveState); moveInfo = move.queue[0]; } } }; var _updateResizeMoveUsed = function(id, type, duration, idToResizeMoveState) { var state = idToResizeMoveState[id][type]; state.used += duration; var options = state.queue[0].actionInfo; if(options.options) options = options.options; var optionDur = (options.easing && options.easing != 'none' && options.duration) || 0; if(optionDur = actions.length) return; //actions are responsible for doing their own dispatching _actionHandlers[actions[currentIndex].action](eventInfo, actions, currentIndex); }; _actionHandlers.wait = function(eventInfo, actions, index) { var action = actions[index]; var infoCopy = $ax.eventCopy(eventInfo); window.setTimeout(function() { infoCopy.now = new Date(); infoCopy.idToResizeMoveState = undefined; _dispatchAction(infoCopy, actions, index + 1); _action.flushAllResizeMoveActions(infoCopy); }, action.waitTime); }; _actionHandlers.expr = function(eventInfo, actions, index) { var action = actions[index]; $ax.expr.evaluateExpr(action.expr, eventInfo); //this should be a block _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.setFunction = _actionHandlers.expr; _actionHandlers.linkWindow = function(eventInfo, actions, index) { linkActionHelper(eventInfo, actions, index); }; _actionHandlers.closeCurrent = function(eventInfo, actions, index) { $ax.closeWindow(); _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.linkFrame = function(eventInfo, actions, index) { linkActionHelper(eventInfo, actions, index); }; _actionHandlers.setAdaptiveView = function(eventInfo, actions, index) { var action = actions[index]; var view = action.setAdaptiveViewTo; if(view) $ax.adaptive.setAdaptiveView(view); }; var linkActionHelper = function(eventInfo, actions, index) { var action = actions[index]; eventInfo.link = true; if(action.linkType != 'frame') { var includeVars = _includeVars(action.target, eventInfo); if(action.target.targetType == \"reloadPage\") { $ax.reload(action.target.includeVariables); } else if(action.target.targetType == \"backUrl\") { $ax.back(); } var url = action.target.url; if(!url && action.target.urlLiteral) { url = $ax.expr.evaluateExpr(action.target.urlLiteral, eventInfo, true); } if(url) { if(action.linkType == \"popup\") { $ax.navigate({ url: url, target: action.linkType, includeVariables: includeVars, popupOptions: action.popup }); } else { $ax.navigate({ url: url, target: action.linkType, includeVariables: includeVars }); } } } else linkFrame(eventInfo, action); eventInfo.link = false; _dispatchAction(eventInfo, actions, index + 1); }; var _includeVars = function(target, eventInfo) { if(target.includeVariables) return true; // If it is a url literal, that is a string literal, that has only 1 sto, that is an item that is a page, include vars. if(target.urlLiteral) { var literal = target.urlLiteral; var sto = literal.stos[0]; if(literal.exprType == 'stringLiteral' && literal.value.indexOf('[[') == 0 && literal.value.indexOf(']]' == literal.value.length - 2) && literal.stos.length == 1 && sto.sto == 'item' && eventInfo.item) { var data = $ax.repeater.getData(eventInfo, eventInfo.item.repeater.elementId, eventInfo.item.index, sto.name, 'data'); if (data && $ax.public.fn.IsPage(data.type)) return true; } } return false; }; var linkFrame = function(eventInfo, action) { for(var i = 0; i < action.framesToTargets.length; i++) { var framePath = action.framesToTargets[i].framePath; var target = action.framesToTargets[i].target; var includeVars = _includeVars(target, eventInfo); var url = target.url; if(!url && target.urlLiteral) { url = $ax.expr.evaluateExpr(target.urlLiteral, eventInfo, true); } var id = $ax.getElementIdsFromPath(framePath, eventInfo)[0]; if(id) $ax('#' + $ax.INPUT(id)).openLink(url, includeVars); } }; var _repeatPanelMap = {}; _actionHandlers.setPanelState = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.panelsToStates.length; i++) { var panelToState = action.panelsToStates[i]; var stateInfo = panelToState.stateInfo; var elementIds = $ax.getElementIdsFromPath(panelToState.panelPath, eventInfo); for(var j = 0; j < elementIds.length; j++) { var elementId = elementIds[j]; // Need new scope for elementId and info (function(elementId, stateInfo) { _addAnimation(elementId, queueTypes.setState, function() { var stateNumber = stateInfo.stateNumber; if(stateInfo.setStateType == \"value\") { var oldTarget = eventInfo.targetElement; eventInfo.targetElement = elementId; var stateName = $ax.expr.evaluateExpr(stateInfo.stateValue, eventInfo); eventInfo.targetElement = oldTarget; // Try for state name first var states = $ax.getObjectFromElementId(elementId).diagrams; var stateNameFound = false; for(var k = 0; k < states.length; k++) { if(states[k].label == stateName) { stateNumber = k + 1; stateNameFound = true; } } // Now check for index if(!stateNameFound) { stateNumber = Number(stateName); var panelCount = $('#' + elementId).children().length; // Make sure number is not NaN, is in range, and is a whole number. // Wasn't a state name or number, so return if(isNaN(stateNumber) || stateNumber panelCount || Math.round(stateNumber) != stateNumber) return _fireAnimationFromQueue(elementId, queueTypes.setState); } } else if(stateInfo.setStateType == 'next' || stateInfo.setStateType == 'previous') { var info = $ax.deepCopy(stateInfo); var repeat = info.repeat; // Only map it, if repeat exists. if(typeof (repeat) == 'number') _repeatPanelMap[elementId] = info; return _progessPanelState(elementId, info, info.repeatSkipFirst); } delete _repeatPanelMap[elementId]; // If setting to current (to stop repeat) break here if(stateInfo.setStateType == 'current') return _fireAnimationFromQueue(elementId, queueTypes.setState); $ax('#' + elementId).SetPanelState(stateNumber, stateInfo.options, stateInfo.showWhenSet); }); })(elementId, stateInfo); } } _dispatchAction(eventInfo, actions, index + 1); }; var _progessPanelState = function(id, info, skipFirst) { var direction = info.setStateType; var loop = info.loop; var repeat = info.repeat; var options = info.options; var hasRepeat = typeof (repeat) == 'number'; var currentStateId = $ax.visibility.GetPanelState(id); var stateNumber = ''; if(currentStateId != '') { currentStateId = $ax.repeater.getScriptIdFromElementId(currentStateId); var currentStateNumber = Number(currentStateId.substr(currentStateId.indexOf('state') + 5)); if(direction == \"next\") { stateNumber = currentStateNumber + 2; if(stateNumber > $ax.visibility.GetPanelStateCount(id)) { if(loop) stateNumber = 1; else { delete _repeatPanelMap[id]; return _fireAnimationFromQueue(id, queueTypes.setState); } } } else if(direction == \"previous\") { stateNumber = currentStateNumber; if(stateNumber repeat) repeat = animate.duration; animate = options && options.animateOut; if(animate && animate.easing && animate.easing != 'none' && animate.duration > repeat) repeat = animate.duration; window.setTimeout(function() { // Either new repeat, or no repeat anymore. if(_repeatPanelMap[id] != info) return; _addAnimation(id, queueTypes.setState, function() { _progessPanelState(id, info, false); }); }, repeat); } else delete _repeatPanelMap[id]; } }; _actionHandlers.fadeWidget = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.objectsToFades.length; i++) { var fadeInfo = action.objectsToFades[i].fadeInfo; var elementIds = $ax.getElementIdsFromPath(action.objectsToFades[i].objectPath, eventInfo); for(var j = 0; j < elementIds.length; j++) { var elementId = elementIds[j]; // Need new scope for elementId and info (function(elementId, fadeInfo) { _addAnimation(elementId, queueTypes.fade, function() { if(fadeInfo.fadeType == \"hide\") { $ax('#' + elementId).hide(fadeInfo.options); } else if(fadeInfo.fadeType == \"show\") { $ax('#' + elementId).show(fadeInfo.options, eventInfo); } else if(fadeInfo.fadeType == \"toggle\") { $ax('#' + elementId).toggleVisibility(fadeInfo.options); } }); })(elementId, fadeInfo); } } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.setOpacity = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.objectsToSetOpacity.length; i++) { var opacityInfo = action.objectsToSetOpacity[i].opacityInfo; var elementIds = $ax.getElementIdsFromPath(action.objectsToSetOpacity[i].objectPath, eventInfo); for(var j = 0; j < elementIds.length; j++) { var elementId = elementIds[j]; (function(elementId, opacityInfo) { _addAnimation(elementId, queueTypes.fade, function () { var oldTarget = eventInfo.targetElement; eventInfo.targetElement = elementId; var opacity = $ax.expr.evaluateExpr(opacityInfo.opacity, eventInfo); eventInfo.targetElement = oldTarget; opacity = Math.min(100, Math.max(0, opacity)); $ax('#' + elementId).setOpacity(opacity/100, opacityInfo.easing, opacityInfo.duration); }) })(elementId, opacityInfo); } } _dispatchAction(eventInfo, actions, index + 1); } _actionHandlers.moveWidget = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.objectsToMoves.length; i++) { var moveInfo = action.objectsToMoves[i].moveInfo; var elementIds = $ax.getElementIdsFromPath(action.objectsToMoves[i].objectPath, eventInfo); for(var j = 0; j < elementIds.length; j++) { var elementId = elementIds[j]; _queueResizeMove(elementId, queueTypes.move, eventInfo, moveInfo); //_addMove(eventInfo, elementId, moveInfo, eventInfo.dragInfo); } } _dispatchAction(eventInfo, actions, index + 1); }; var _compoundChildrenShallow = function (id) { var deep = []; var children = $ax('#' + id).getChildren()[0].children; var piecePrefix = id + 'p'; for (var i = 0; i < children.length; i++) { if(children[i].substring(0, id.length + 1) == piecePrefix) { deep.push(children[i]); } } return deep; }; var _addMove = function (elementId, eventInfo, moveInfo, optionsOverride) { var eventInfoCopy = $ax.eventCopy(eventInfo); var idToResizeMoveState = _getIdToResizeMoveState(eventInfoCopy); eventInfoCopy.targetElement = elementId; var options = $ax.deepCopy(moveInfo.options); options.easing = optionsOverride.easing; options.duration = optionsOverride.duration; options.dragInfo = eventInfo.dragInfo; if($ax.public.fn.IsLayer($obj(elementId).type)) { var childrenIds = $ax.public.fn.getLayerChildrenDeep(elementId, true); if(childrenIds.length == 0) return; var animations = []; // Get move delta once, then apply to all children animations.push({ id: elementId, type: queueTypes.move, func: function() { var layerInfo = $ax.public.fn.getWidgetBoundingRect(elementId); var deltaLoc = _getMoveLoc(elementId, moveInfo, eventInfoCopy, optionsOverride.stop, idToResizeMoveState[elementId], options, layerInfo); // $ax.event.raiseSyntheticEvent(elementId, \"onMove\"); $ax.visibility.pushContainer(elementId, false); options.onComplete = function () { _fireAnimationFromQueue(elementId, queueTypes.move); $ax.visibility.popContainer(elementId, false); }; $ax('#' + elementId).moveBy(deltaLoc.x, deltaLoc.y, options); } }); //for(var i = 0; i < childrenIds.length; i++) { // (function(childId) { // animations.push({ // id: childId, // type: queueTypes.move, // func: function () { // // Nop, while trying to move as container // //$ax.event.raiseSyntheticEvent(childId, \"onMove\"); // //if($ax.public.fn.IsLayer($obj(childId).type)) _fireAnimationFromQueue(childId, queueTypes.move); // //else $ax('#' + childId).moveBy(deltaLoc.x, deltaLoc.y, moveInfo.options); // } // }); // })(childrenIds[i]); //} _addAnimations(animations); } else { _addAnimation(elementId, queueTypes.move, function() { var loc = _getMoveLoc(elementId, moveInfo, eventInfoCopy, optionsOverride.stop, idToResizeMoveState[elementId], options); // $ax.event.raiseSyntheticEvent(elementId, \"onMove\"); if(loc.moveTo) $ax('#' + elementId).moveTo(loc.x, loc.y, options); else $ax('#' + elementId).moveBy(loc.x, loc.y, options); }); } }; var _moveSingleWidget = function (elementId, delta, options, onComplete) { if(!delta.x && !delta.y) { $ax.action.fireAnimationFromQueue(elementId, $ax.action.queueTypes.move); return; } var fixedInfo = $ax.dynamicPanelManager.getFixedInfo(elementId); var xProp = 'left'; var xDiff = '+='; if(fixedInfo) { if(fixedInfo.horizontal == 'right') { xProp = 'right'; xDiff = '-='; } else if(fixedInfo.horizontal == 'center') { xProp = 'margin-left'; } } var yProp = 'top'; var yDiff = '+='; if(fixedInfo) { if(fixedInfo.vertical == 'bottom') { yProp = 'bottom'; yDiff = '-='; } else if(fixedInfo.vertical == 'middle') { yProp = 'margin-top'; } } var css = {}; css[xProp] = xDiff + delta.x; css[yProp] = yDiff + delta.y; var moveInfo = $ax.move.PrepareForMove(elementId, delta.x, delta.y,false, options); $jobjAll(elementId).animate(css, { duration: options.duration, easing: options.easing, queue: false, complete: function () { if(onComplete) onComplete(); if(moveInfo.rootLayer) $ax.visibility.popContainer(moveInfo.rootLayer, false); $ax.action.fireAnimationFromQueue(elementId, $ax.action.queueTypes.move); } }); } var _getMoveLoc = function (elementId, moveInfo, eventInfoCopy, stopInfo, comboState, options, layerInfo) { var moveTo = false; var moveWithThis = false; var xValue = 0; var yValue = 0; var moveResult = comboState.moveResult; var widgetDragInfo = eventInfoCopy.dragInfo; var jobj = $jobj(elementId); var startX; var startY; switch(moveInfo.moveType) { case \"location\": // toRatio is ignoring anything before start since that has already taken effect we just know whe have from start to len to finish // getting to the location we want to get to. var toRatio = stopInfo.instant ? 1 : (stopInfo.end - stopInfo.start) / (stopInfo.len - stopInfo.start); // If result already caluculated, don't recalculate again, other calculate and save if (moveResult) { xValue = moveResult.x; yValue = moveResult.y; } else { comboState.moveResult = moveResult = { x: $ax.expr.evaluateExpr(moveInfo.xValue, eventInfoCopy), y: $ax.expr.evaluateExpr(moveInfo.yValue, eventInfoCopy) }; xValue = moveResult.x; yValue = moveResult.y; } // If this is final stop for this move, then clear out the result so next move won't use it if(stopInfo.instant || stopInfo.end == stopInfo.len) comboState.moveResult = undefined; if (layerInfo) { startX = layerInfo.left; startY = layerInfo.top; //} else if ($ax.public.fn.isCompoundVectorHtml(jobj[0])) { // var dimensions = $ax.public.fn.compoundWidgetDimensions(jobj); // startX = dimensions.left; // startY = dimensions.top; } else { startX = $ax('#' + elementId).locRelativeIgnoreLayer(false); startY = $ax('#' + elementId).locRelativeIgnoreLayer(true); if(jobj.css('position') == 'fixed') { startX -= $(window).scrollLeft(); startY -= $(window).scrollTop(); } } xValue = xValue == '' ? 0 : (xValue - startX) * toRatio; yValue = yValue == '' ? 0 : (yValue - startY) * toRatio; break; case \"delta\": var ratio = stopInfo.instant ? 1 : (stopInfo.end - stopInfo.start) / stopInfo.len; // See case location above if(moveResult) { xValue = moveResult.x * ratio; yValue = moveResult.y * ratio; } else { comboState.moveResult = moveResult = { x: $ax.expr.evaluateExpr(moveInfo.xValue, eventInfoCopy), y: $ax.expr.evaluateExpr(moveInfo.yValue, eventInfoCopy) }; xValue = moveResult.x * ratio; yValue = moveResult.y * ratio; } if (stopInfo.instant || stopInfo.end == stopInfo.len) comboState.moveResult = undefined; break; case \"drag\": xValue = widgetDragInfo.xDelta; yValue = widgetDragInfo.yDelta; break; case \"dragX\": xValue = widgetDragInfo.xDelta; yValue = 0; break; case \"dragY\": xValue = 0; yValue = widgetDragInfo.yDelta; break; case \"locationBeforeDrag\": var location = widgetDragInfo.movedWidgets[eventInfoCopy.targetElement]; if (location) { var axObj = $ax('#' + eventInfoCopy.targetElement); xValue = location.x - axObj.left(); yValue = location.y - axObj.top(); } else { _fireAnimationFromQueue(eventInfoCopy.srcElement, queueTypes.move); return { x: 0, y: 0 }; } //moveTo = true; break; case \"withThis\": moveWithThis = true; var widgetMoveInfo = $ax.move.GetWidgetMoveInfo(); var srcElementId = $ax.getElementIdsFromEventAndScriptId(eventInfoCopy, eventInfoCopy.srcElement)[0]; var delta = widgetMoveInfo[srcElementId]; options.easing = delta.options.easing; options.duration = delta.options.duration; xValue = delta.x; yValue = delta.y; break; } if (options && options.boundaryExpr) { //$ax.public.fn.removeCompound(jobj); if(jobj.css('position') == 'fixed') { //swap page coordinates with fixed coordinates options.boundaryExpr.leftExpr.value = options.boundaryExpr.leftExpr.value.replace('.top', '.topfixed').replace('.left', '.leftfixed').replace('.bottom', '.bottomfixed').replace('.right', '.rightfixed'); options.boundaryExpr.leftExpr.stos[0].leftSTO.prop = options.boundaryExpr.leftExpr.stos[0].leftSTO.prop + 'fixed'; options.boundaryStos.boundaryScope.direcval0.value = options.boundaryStos.boundaryScope.direcval0.value.replace('.top', '.topfixed').replace('.left', '.leftfixed').replace('.bottom', '.bottomfixed').replace('.right', '.rightfixed'); options.boundaryStos.boundaryScope.direcval0.stos[0].leftSTO.prop = options.boundaryStos.boundaryScope.direcval0.stos[0].leftSTO.prop + 'fixed'; } if(moveWithThis && (xValue || yValue)) { _updateLeftExprVariable(options.boundaryExpr, xValue.toString(), yValue.toString()); } if(!$ax.expr.evaluateExpr(options.boundaryExpr, eventInfoCopy)) { var boundaryStoInfo = options.boundaryStos; if(boundaryStoInfo) { if(moveWithThis) { var stoScopes = boundaryStoInfo.boundaryScope; if(stoScopes) { for(var s in stoScopes) { var boundaryScope = stoScopes[s]; if(!boundaryScope.localVariables) continue; if(boundaryScope.localVariables.withx) boundaryScope.localVariables.withx.value = xValue.toString(); if(boundaryScope.localVariables.withy) boundaryScope.localVariables.withy.value = yValue.toString(); } } } if(layerInfo) { startX = layerInfo.left; startY = layerInfo.top; } else { startX = $ax('#' + elementId).locRelativeIgnoreLayer(false); startY = $ax('#' + elementId).locRelativeIgnoreLayer(true); if(jobj.css('position') == 'fixed') { startX -= $(window).scrollLeft(); startY -= $(window).scrollTop(); } } if(boundaryStoInfo.ySto) { var currentTop = layerInfo ? layerInfo.top : startY; var newTop = $ax.evaluateSTO(boundaryStoInfo.ySto, boundaryStoInfo.boundaryScope, eventInfoCopy); if(moveTo) yValue = newTop; else yValue = newTop - currentTop; } if(boundaryStoInfo.xSto) { var currentLeft = layerInfo ? layerInfo.left : startX; var newLeft = $ax.evaluateSTO(boundaryStoInfo.xSto, boundaryStoInfo.boundaryScope, eventInfoCopy); if(moveTo) xValue = newLeft; else xValue = newLeft - currentLeft; } } } //$ax.public.fn.restoreCompound(jobj); } return { x: Number(xValue), y: Number(yValue), moveTo: moveTo }; }; //we will have something like [[Target.right + withX]] for leftExpr, and this function set the value of withX var _updateLeftExprVariable = function (exprTree, xValue, yValue) { if(exprTree.leftExpr && !exprTree.leftExpr.op) { var localVars = exprTree.leftExpr.localVariables; if(localVars) { if(localVars.withx) localVars.withx.value = xValue; if(localVars.withy) localVars.withy.value = yValue; } } //traversal if(exprTree.op) { if(exprTree.leftExpr) _updateLeftExprVariable(exprTree.leftExpr, xValue, yValue); if(exprTree.rightExpr) _updateLeftExprVariable(exprTree.rightExpr, xValue, yValue); } } var widgetRotationFilter = [ $ax.constants.IMAGE_BOX_TYPE, $ax.constants.IMAGE_MAP_REGION_TYPE, $ax.constants.DYNAMIC_PANEL_TYPE, $ax.constants.VECTOR_SHAPE_TYPE, $ax.constants.VERTICAL_LINE_TYPE, $ax.constants.HORIZONTAL_LINE_TYPE ]; _actionHandlers.rotateWidget = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.objectsToRotate.length; i++) { var rotateInfo = action.objectsToRotate[i].rotateInfo; var elementIds = $ax.getElementIdsFromPath(action.objectsToRotate[i].objectPath, eventInfo); for(var j = 0; j < elementIds.length; j++) { var elementId = elementIds[j]; _queueResizeMove(elementId, queueTypes.rotate, eventInfo, rotateInfo); } } _dispatchAction(eventInfo, actions, index + 1); }; var _addRotate = function (elementId, eventInfo, rotateInfo, options, moveInfo) { var idToResizeMoveState = _getIdToResizeMoveState(eventInfo); rotateInfo = $ax.deepCopy(rotateInfo); rotateInfo.options.easing = options.easing; rotateInfo.options.duration = options.duration; var eventInfoCopy = $ax.eventCopy(eventInfo); eventInfoCopy.targetElement = elementId; //calculate degree value at start of animation var rotateDegree; var offset = {}; var eval = function(boundingRect) { rotateDegree = parseFloat($ax.expr.evaluateExpr(rotateInfo.degree, eventInfoCopy)); offset.x = Number($ax.expr.evaluateExpr(rotateInfo.offsetX, eventInfoCopy)); offset.y = Number($ax.expr.evaluateExpr(rotateInfo.offsetY, eventInfoCopy)); if(!rotateInfo.options.clockwise) rotateDegree = -rotateDegree; _updateOffset(offset, rotateInfo.anchor, boundingRect); } if(moveInfo) { var moveOptions = { dragInfo: eventInfoCopy.dragInfo, duration: options.duration, easing: options.easing, boundaryExpr: moveInfo.options.boundaryExpr, boundaryStos: moveInfo.options.boundaryStos }; } var obj = $obj(elementId); if($ax.public.fn.IsLayer(obj.type)) { var childrenIds = $ax.public.fn.getLayerChildrenDeep(elementId, true, true); if(childrenIds.length == 0) return; var animations = []; //get center point of the group, and degree delta var centerPoint, degreeDelta, moveDelta; animations.push({ id: elementId, type: queueTypes.rotate, func: function () { var boundingRect = $axure.fn.getWidgetBoundingRect(elementId); eval(boundingRect); centerPoint = boundingRect.centerPoint; centerPoint.x += offset.x; centerPoint.y += offset.y; degreeDelta = _initRotateLayer(elementId, rotateInfo, rotateDegree, options, options.stop); _fireAnimationFromQueue(elementId, queueTypes.rotate); moveDelta = { x: 0, y: 0 }; if (moveInfo) { moveDelta = _getMoveLoc(elementId, moveInfo, eventInfoCopy, options.moveStop, idToResizeMoveState[elementId], moveOptions, boundingRect); if (moveDelta.moveTo) { moveDelta.x -= $ax.getNumFromPx($jobj(elementId).css('left')); moveDelta.y -= $ax.getNumFromPx($jobj(elementId).css('top')); } $ax.event.raiseSyntheticEvent(elementId, 'onMove'); } } }); for(var idIndex = 0; idIndex < childrenIds.length; idIndex++) { var childId = childrenIds[idIndex]; (function(id) { var childObj = $obj(id); var rotate = $.inArray(childObj.type, widgetRotationFilter) != -1; var isLayer = $ax.public.fn.IsLayer(childObj.type); animations.push({ id: id, type: queueTypes.rotate, func: function() { $ax.event.raiseSyntheticEvent(id, \"onRotate\"); if(isLayer) _fireAnimationFromQueue(id, queueTypes.rotate); else $ax('#' + id).circularMoveAndRotate(degreeDelta, options, centerPoint.x, centerPoint.y, rotate, moveDelta); } }); if(!isLayer) animations.push({ id: id, type: queueTypes.move, func: function() {} }); })(childId); } _addAnimations(animations); } else { animations = []; animations.push({ id: elementId, type: queueTypes.rotate, func: function () { var jobj = $jobj(elementId); var unrotatedDim = { width: $ax.getNumFromPx(jobj.css('width')), height: $ax.getNumFromPx(jobj.css('height')) }; eval(unrotatedDim); var delta = { x: 0, y: 0 }; if(moveInfo) { delta = _getMoveLoc(elementId, moveInfo, eventInfoCopy, options.moveStop, idToResizeMoveState[elementId], moveOptions); if(delta.moveTo) { delta.x -= $ax.getNumFromPx($jobj(elementId).css('left')); delta.y -= $ax.getNumFromPx($jobj(elementId).css('top')); } } $ax.event.raiseSyntheticEvent(elementId, 'onRotate'); if(offset.x == 0 && offset.y == 0) _rotateSingle(elementId, rotateDegree, rotateInfo.rotateType == 'location', delta, options, options.stop, true); else _rotateSingleOffset(elementId, rotateDegree, rotateInfo.rotateType == 'location', delta, { x: offset.x, y: offset.y }, options, options.stop); if(moveInfo) $ax.event.raiseSyntheticEvent(elementId, 'onMove'); } }); animations.push({ id: elementId, type: queueTypes.move, func: function () { } }); _addAnimations(animations); } } var _updateOffset = function(offset, anchor, boundingRect) { if (anchor.indexOf('left') != -1) offset.x -= boundingRect.width / 2; if (anchor.indexOf('right') != -1) offset.x += boundingRect.width / 2; if (anchor.indexOf('top') != -1) offset.y -= boundingRect.height / 2; if (anchor.indexOf('bottom') != -1) offset.y += boundingRect.height / 2; } var _rotateSingle = function(elementId, rotateDegree, rotateTo, delta, options, stop, handleMove) { var degreeDelta = _applyRotateStop(rotateDegree, $ax.move.getRotationDegree(elementId), rotateTo, stop); $ax('#' + elementId).rotate(degreeDelta, options.easing, options.duration, false, true); if(handleMove) { if (delta.x || delta.y) _moveSingleWidget(elementId, delta, options); else $ax.action.fireAnimationFromQueue(elementId, $ax.action.queueTypes.move); } }; var _rotateSingleOffset = function (elementId, rotateDegree, rotateTo, delta, offset, options, stop, resizeOffset) { var obj = $obj(elementId); var currRotation = $ax.move.getRotationDegree(elementId); // Need to fix offset. Want to to stay same place on widget after rotation, so need to take the offset and rotate it to where it should be. if(currRotation) { offset = $axure.fn.getPointAfterRotate(currRotation, offset, { x: 0, y: 0 }); } var degreeDelta = _applyRotateStop(rotateDegree, currRotation, rotateTo, stop); var widgetCenter = $axure.fn.getWidgetBoundingRect(elementId).centerPoint; var rotate = $.inArray(obj.type, widgetRotationFilter) != -1; $ax('#' + elementId).circularMoveAndRotate(degreeDelta, options, widgetCenter.x + offset.x, widgetCenter.y + offset.y, rotate, delta, resizeOffset); } var _applyRotateStop = function(rotateDegree, currRotation, to, stop) { var degreeDelta; var ratio; if(to) { degreeDelta = rotateDegree - currRotation; ratio = stop.instant ? 1 : (stop.end - stop.start) / (stop.len - stop.start); } else { degreeDelta = rotateDegree; ratio = stop.instant ? 1 : (stop.end - stop.start) / stop.len; } return degreeDelta * ratio; } var _initRotateLayer = function(elementId, rotateInfo, rotateDegree, options, stop) { var layerDegree = $jobj(elementId).data('layerDegree'); if (layerDegree === undefined) layerDegree = 0; else layerDegree = parseFloat(layerDegree); var to = rotateInfo.rotateType == 'location'; var newDegree = to ? rotateDegree : layerDegree + rotateDegree; var degreeDelta = newDegree - layerDegree; var ratio = stop.instant ? 1 : (stop.end - stop.start) / (stop.len - stop.start); degreeDelta *= ratio; $jobj(elementId).data('layerDegree', newDegree); $ax.event.raiseSyntheticEvent(elementId, \"onRotate\"); return degreeDelta; } _actionHandlers.setWidgetSize = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.objectsToResize.length; i++) { var resizeInfo = action.objectsToResize[i].sizeInfo; var objPath = action.objectsToResize[i].objectPath; if(objPath == 'thisItem') { var thisId = eventInfo.srcElement; var repeaterId = $ax.getParentRepeaterFromElementId(thisId); var itemId = $ax.repeater.getItemIdFromElementId(thisId); var currSize = $ax.repeater.getItemSize(repeaterId, itemId); var newSize = _getSizeFromInfo(resizeInfo, eventInfo, currSize.width, currSize.height); $ax.repeater.setItemSize(repeaterId, itemId, newSize.width, newSize.height); continue; } var elementIds = $ax.getElementIdsFromPath(objPath, eventInfo); for(var j = 0; j < elementIds.length; j++) { var elementId = elementIds[j]; _queueResizeMove(elementId, queueTypes.resize, eventInfo, resizeInfo); //_addResize(elementId, resizeInfo); } } _dispatchAction(eventInfo, actions, index + 1); }; // Move info undefined unless this move/resize actions are being merged var _addResize = function(elementId, eventInfo, resizeInfo, options, moveInfo, rotateInfo) { var axObject = $obj(elementId); resizeInfo = $ax.deepCopy(resizeInfo); resizeInfo.easing = options.easing; resizeInfo.duration = options.duration; var eventInfoCopy = $ax.eventCopy(eventInfo); eventInfoCopy.targetElement = elementId; var moves = moveInfo || resizeInfo.anchor != \"top left\" || ($ax.public.fn.IsDynamicPanel(axObject.type) && ((axObject.fixedHorizontal && axObject.fixedHorizontal == 'center') || (axObject.fixedVertical && axObject.fixedVertical == 'middle'))) || (rotateInfo && (rotateInfo.offsetX || rotateInfo.offsetY)); if(moveInfo) { var moveOptions = { dragInfo: eventInfoCopy.dragInfo, duration: options.duration, easing: options.easing, boundaryExpr: moveInfo.options.boundaryExpr, boundaryStos: moveInfo.options.boundaryStos }; } var idToResizeMoveState = _getIdToResizeMoveState(eventInfoCopy); var animations = []; if($ax.public.fn.IsLayer(axObject.type)) { moves = true; // Assume widgets will move will layer, even though not all widgets may move var childrenIds = $ax.public.fn.getLayerChildrenDeep(elementId, true, true); if(childrenIds.length === 0) return; // Need to wait to calculate new size, until time to animate, but animates are in separate queues // best option seems to be to calculate in a \"animate\" for the layer itself and all children will use that. // May just have to be redundant if this doesn't work well. var boundingRect, widthChangedPercent, heightChangedPercent, unchanged, deltaLoc, degreeDelta, resizeOffset; animations.push({ id: elementId, type: queueTypes.resize, func: function () { $ax.visibility.pushContainer(elementId, false); boundingRect = $ax.public.fn.getWidgetBoundingRect(elementId); var size = _getSizeFromInfo(resizeInfo, eventInfoCopy, boundingRect.width, boundingRect.height, elementId); deltaLoc = { x: 0, y: 0 }; var stop = options.stop; var ratio = stop.instant ? 1 : (stop.end - stop.start) / (stop.len - stop.start); widthChangedPercent = Math.round(size.width - boundingRect.width) / boundingRect.width * ratio; heightChangedPercent = Math.round(size.height - boundingRect.height) / boundingRect.height * ratio; resizeOffset = _applyAnchorToResizeOffset(widthChangedPercent * boundingRect.width, heightChangedPercent * boundingRect.height, resizeInfo.anchor); if(stop.instant || stop.end == stop.len) idToResizeMoveState[elementId].resizeResult = undefined; unchanged = widthChangedPercent === 0 && heightChangedPercent === 0; $ax.event.raiseSyntheticEvent(elementId, 'onResize'); _fireAnimationFromQueue(elementId, queueTypes.resize); } }); if(moveInfo) animations.push({ id: elementId, type: queueTypes.move, func: function() { deltaLoc = _getMoveLoc(elementId, moveInfo, eventInfoCopy, options.moveStop, idToResizeMoveState[elementId], moveOptions, boundingRect); $ax.visibility.pushContainer(elementId, false); _fireAnimationFromQueue(elementId, queueTypes.move); $ax.event.raiseSyntheticEvent(elementId, 'onMove'); } }); if (rotateInfo) animations.push({ id: elementId, type: queueTypes.rotate, func: function () { resizeOffset = _applyAnchorToResizeOffset(widthChangedPercent * boundingRect.width, heightChangedPercent * boundingRect.height, resizeInfo.anchor); var rotateDegree = parseFloat($ax.expr.evaluateExpr(rotateInfo.degree, eventInfoCopy)); degreeDelta = _initRotateLayer(elementId, rotateInfo, rotateDegree, options, options.rotateStop); _fireAnimationFromQueue(elementId, queueTypes.rotate); $ax.event.raiseSyntheticEvent(elementId, 'onRotate'); } }); var completeCount = childrenIds.length*2; // Because there is a resize and move complete, it needs to be doubled for(var idIndex = 0; idIndex < childrenIds.length; idIndex++) { // Need to use scoping trick here to make sure childId doesn't change on next loop (function(childId) { //use ax obj to get width and height, jquery css give us the value without border var isLayer = $ax.public.fn.IsLayer($obj(childId).type); var rotate = $.inArray($obj(childId).type, widgetRotationFilter) != -1; animations.push({ id: childId, type: queueTypes.resize, func: function() { //$ax.event.raiseSyntheticEvent(childId, 'onResize'); if(isLayer) { completeCount -= 2; _fireAnimationFromQueue(childId, queueTypes.resize); $ax.event.raiseSyntheticEvent(childId, 'onResize'); } else { var currDeltaLoc = { x: deltaLoc.x, y: deltaLoc.y }; var resizeDeltaMove = { x: 0, y: 0 }; var css = _getCssForResizingLayerChild(childId, resizeInfo.anchor, boundingRect, widthChangedPercent, heightChangedPercent, resizeDeltaMove); var onComplete = function() { if(--completeCount == 0) $ax.visibility.popContainer(elementId, false); }; $ax('#' + childId).resize(css, resizeInfo, true, moves, onComplete); if(rotateInfo) { var offset = { x: Number($ax.expr.evaluateExpr(rotateInfo.offsetX, eventInfoCopy)), y: Number($ax.expr.evaluateExpr(rotateInfo.offsetY, eventInfo)) }; _updateOffset(offset, resizeInfo.anchor, boundingRect); var centerPoint = { x: boundingRect.centerPoint.x + offset.x, y: boundingRect.centerPoint.y + offset.y }; $ax('#' + childId).circularMoveAndRotate(degreeDelta, options, centerPoint.x, centerPoint.y, rotate, currDeltaLoc, resizeOffset, resizeDeltaMove, onComplete); } else { currDeltaLoc.x += resizeDeltaMove.x; currDeltaLoc.y += resizeDeltaMove.y; _moveSingleWidget(childId, currDeltaLoc, options, onComplete); } } } }); if(!isLayer) animations.push({ id: childId, type: queueTypes.move, func: function () {} }); if(!isLayer && rotateInfo) animations.push({ id: childId, type: queueTypes.rotate, func: function () {} }); })(childrenIds[idIndex]); } } else { // Not func, obj with func animations.push({ id: elementId, type: queueTypes.resize, func: function() { //textarea can be resized manully by the user, but doesn't update div size yet, so doing this for now. //alternatively axquery get for size can account for this var sizeId = $ax.public.fn.IsTextArea(axObject.type) ? $jobj(elementId).children('textarea').attr('id') : elementId; var oldSize = $ax('#' + sizeId).size(); var oldWidth = oldSize.width; var oldHeight = oldSize.height; var stop = options.stop; var ratio = stop.instant ? 1 : (stop.end - stop.start) / (stop.len - stop.start); var size = _getSizeFromInfo(resizeInfo, eventInfoCopy, oldWidth, oldHeight, elementId); var newWidth = size.width; var newHeight = size.height; var deltaWidth = Math.round(newWidth - oldWidth) * ratio; var deltaHeight = Math.round(newHeight - oldHeight) * ratio; newWidth = oldWidth + deltaWidth; newHeight = oldHeight + deltaHeight; var delta = { x: 0, y: 0 }; if(moveInfo) { delta = _getMoveLoc(elementId, moveInfo, eventInfoCopy, options.moveStop, idToResizeMoveState[elementId], moveOptions); if (delta.moveTo) { delta.x -= $ax.getNumFromPx($jobj(elementId).css('left')); delta.y -= $ax.getNumFromPx($jobj(elementId).css('top')); } } var rotateHandlesMove = false; var offset = { x: 0, y: 0 }; if(rotateInfo) { offset.x = Number($ax.expr.evaluateExpr(rotateInfo.offsetX, eventInfoCopy)); offset.y = Number($ax.expr.evaluateExpr(rotateInfo.offsetY, eventInfoCopy)); _updateOffset(offset, rotateInfo.anchor, $axure.fn.getWidgetBoundingRect(elementId)); rotateHandlesMove = Boolean(rotateInfo && (offset.x || offset.y || rotateInfo.anchor != 'center')); $ax.event.raiseSyntheticEvent(elementId, 'onRotate'); } var css = null; var rootLayer = null; if(deltaHeight != 0 || deltaWidth != 0) { rootLayer = $ax.move.getRootLayer(elementId); if(rootLayer) $ax.visibility.pushContainer(rootLayer, false); css = _getCssForResizingWidget(elementId, eventInfoCopy, resizeInfo.anchor, newWidth, newHeight, oldWidth, oldHeight, delta, options.stop, !rotateHandlesMove); idToResizeMoveState[elementId].resizeResult = undefined; } if(rotateInfo) { var rotateDegree = parseFloat($ax.expr.evaluateExpr(rotateInfo.degree, eventInfoCopy)); if(rotateHandlesMove) { var resizeOffset = _applyAnchorToResizeOffset(deltaWidth, deltaHeight, rotateInfo.anchor); _rotateSingleOffset(elementId, rotateDegree, rotateInfo.rotateType == 'location', delta, offset, options, options.rotateStop, resizeOffset); } else { // Not handling move so pass in nop delta _rotateSingle(elementId, rotateDegree, rotateInfo.rotateType == 'location', { x: 0, y: 0 }, options, options.rotateStop); if (moves) _fireAnimationFromQueue(elementId, queueTypes.move); } } else if(!css && moves) _moveSingleWidget(elementId, delta, options); // Have to do it down here to make sure move info is registered if(moveInfo) $ax.event.raiseSyntheticEvent(elementId, 'onMove'); //$ax.event.raiseSyntheticEvent(elementId, 'onResize'); if (css) { $ax('#' + elementId).resize(css, resizeInfo, true, moves, function () { if(rootLayer) $ax.visibility.popContainer(rootLayer, false); }); } else { _fireAnimationFromQueue(elementId, queueTypes.resize); $ax.event.raiseSyntheticEvent(elementId, 'onResize'); } } }); // Nop move (move handled by resize) if(rotateInfo) animations.push({ id: elementId, type: queueTypes.rotate, func: function () { } }); if(moves) animations.push({ id: elementId, type: queueTypes.move, func: function () { } }); } _addAnimations(animations); }; var _applyAnchorToResizeOffset = function (deltaWidth, deltaHeight, anchor) { var offset = {}; if (anchor.indexOf('left') != -1) offset.x = -deltaWidth / 2; else if (anchor.indexOf('right') != -1) offset.x = deltaWidth / 2; if (anchor.indexOf('top') != -1) offset.y = -deltaHeight / 2; else if (anchor.indexOf('bottom') != -1) offset.y = deltaHeight / 2; return offset; } //var _getOldAndNewSize = function (resizeInfo, eventInfo, targetElement) { // var axObject = $obj(targetElement); // var oldWidth, oldHeight; // //textarea can be resized manully by the user, use the textarea child to get the current size // //because this new size may not be reflected on its parents yet // if ($ax.public.fn.IsTextArea(axObject.type)) { // var jObject = $jobj(elementId); // var textObj = $ax('#' + jObject.children('textarea').attr('id')); // //maybe we shouldn't use ax obj to get width and height here anymore... // oldWidth = textObj.width(); // oldHeight = textObj.height(); // } else { // oldWidth = $ax('#' + elementId).width(); // oldHeight = $ax('#' + elementId).height(); // } // var size = _getSizeFromInfo(resizeInfo, eventInfo, oldHeight, oldWidth, elementId); // return { oldWidth: oldWidth, oldHeight: oldHeight, newWidth: size.width, newHeight: size.height, change: oldWidth != size.width || oldHeight != size.height }; //} var _getSizeFromInfo = function(resizeInfo, eventInfo, oldWidth, oldHeight, targetElement) { var oldTarget = eventInfo.targetElement; eventInfo.targetElement = targetElement; var state = _getIdToResizeMoveState(eventInfo)[targetElement]; if(state && state.resizeResult) return state.resizeResult; var width = $ax.expr.evaluateExpr(resizeInfo.width, eventInfo); var height = $ax.expr.evaluateExpr(resizeInfo.height, eventInfo); eventInfo.targetElement = oldTarget; // If either one is not a number, use the old value width = width != \"\" ? Number(width) : oldWidth; height = height != \"\" ? Number(height) : oldHeight; width = isNaN(width) ? oldWidth : width; height = isNaN(height) ? oldHeight : height; // can't be negative var result = { width: Math.max(width, 0), height: Math.max(height, 0) }; if(state) state.resizeResult = result; return result; } //var _queueResize = function (elementId, css, resizeInfo) { // var resizeFunc = function() { // $ax('#' + elementId).resize(css, resizeInfo, true); // //$ax.public.fn.resize(elementId, css, resizeInfo, true); // }; // var obj = $obj(elementId); // var moves = resizeInfo.anchor != \"top left\" || ($ax.public.fn.IsDynamicPanel(obj.type) && ((obj.fixedHorizontal && obj.fixedHorizontal == 'center') || (obj.fixedVertical && obj.fixedVertical == 'middle'))) // if(!moves) { // _addAnimation(elementId, queueTypes.resize, resizeFunc); // } else { // var animations = []; // animations[0] = { id: elementId, type: queueTypes.resize, func: resizeFunc }; // animations[1] = { id: elementId, type: queueTypes.move, func: function() {}}; // Nop func - resize handles move and firing from queue // _addAnimations(animations); // } //}; //should clean this function and var _getCssForResizingWidget = function (elementId, eventInfo, anchor, newWidth, newHeight, oldWidth, oldHeight, delta, stop, handleMove) { var ratio = stop.instant ? 1 : (stop.end - stop.start) / (stop.len - stop.start); var deltaWidth = (newWidth - oldWidth) * ratio; var deltaHeight = (newHeight - oldHeight) * ratio; if(stop.instant || stop.end == stop.len) { var idToResizeMoveState = _getIdToResizeMoveState(eventInfo); if(idToResizeMoveState[elementId]) idToResizeMoveState[elementId].resizeResult = undefined; } var css = {}; css.height = oldHeight + deltaHeight; var obj = $obj(elementId); //if it's 100% width, don't change its width if($ax.dynamicPanelManager.isPercentWidthPanel(obj)) var is100Dp = true; else css.width = oldWidth + deltaWidth; var jobj = $jobj(elementId); //if this is pinned dp, we will mantain the pin, no matter how you resize it; so no need changes left or top //NOTE: currently only pinned DP has position == fixed if(jobj.css('position') == 'fixed') { if(obj.fixedHorizontal && obj.fixedHorizontal == 'center') css['margin-left'] = '+=' + delta.x; if(obj.fixedVertical && obj.fixedVertical == 'middle') css['margin-top'] = '+=' + delta.y; return css; } // If it is pinned, but temporarily not fixed because it is wrappen in a container, then just make sure to anchor it correctly if(obj.fixedVertical) { if(obj.fixedVertical == 'middle') anchor = obj.fixedHorizontal; else anchor = obj.fixedVertical + (obj.fixedHorizontal == 'center' ? '' : ' ' + obj.fixedHorizontal); } //use position relative to parents //var position = obj.generateCompound ? $ax.public.fn.getWidgetBoundingRect(elementId) : $ax.public.fn.getPositionRelativeToParent(elementId); var locationShift; switch(anchor) { case \"top left\": locationShift = { x: 0, y: 0 }; break; case \"top\": locationShift = { x: -deltaWidth / 2.0, y: 0.0 }; break; case \"top right\": locationShift = { x: -deltaWidth, y: 0.0 }; break; case \"left\": locationShift = { x: 0.0, y: -deltaHeight / 2.0 }; break; case \"center\": locationShift = { x: -deltaWidth / 2.0, y: -deltaHeight / 2.0 }; break; case \"right\": locationShift = { x: -deltaWidth, y: -deltaHeight / 2.0 }; break; case \"bottom left\": locationShift = { x: 0.0, y: -deltaHeight }; break; case \"bottom\": locationShift = { x: -deltaWidth/2.0, y: -deltaHeight }; break; case \"bottom right\": locationShift = { x: -deltaWidth, y: -deltaHeight }; break; } if(handleMove) { if(jobj.css('position') === 'absolute') { css.left = $ax.getNumFromPx(jobj.css('left')) + locationShift.x + delta.x; css.top = $ax.getNumFromPx(jobj.css('top')) + locationShift.y + delta.y; } else { var axQuery = $ax('#' + elementId); css.left = axQuery.left(true) + locationShift.x + delta.x; css.top = axQuery.top(true) + locationShift.y + delta.y; } } else { delta.x += locationShift.x; delta.y += locationShift.y; } return css; }; var _getCssForResizingLayerChild = function (elementId, anchor, layerBoundingRect, widthChangedPercent, heightChangedPercent, deltaLoc) { var boundingRect = $ax.public.fn.getWidgetBoundingRect(elementId); var childCenterPoint = boundingRect.centerPoint; var currentSize = $ax('#' + elementId).size(); var newWidth = currentSize.width + currentSize.width * widthChangedPercent; var newHeight = currentSize.height + currentSize.height * heightChangedPercent; var css = {}; css.height = newHeight; var obj = $obj(elementId); //if it's 100% width, don't change its width and left var changeLeft = true; if($ax.dynamicPanelManager.isPercentWidthPanel(obj)) changeLeft = false; else css.width = newWidth; var jobj = $jobj(elementId); //if this is pinned dp, we will mantain the pin, no matter how you resize it; so no need changes left or top //NOTE: currently only pinned DP has position == fixed if(jobj.css('position') == 'fixed') return css; //use bounding rect position relative to parents to calculate delta var axObj = $ax('#' + elementId); // This will be absolute world coordinates, but we want body coordinates. var currentLeft = axObj.locRelativeIgnoreLayer(false); var currentTop = axObj.locRelativeIgnoreLayer(true); var resizable = $ax.public.fn.IsResizable(obj.type); if(anchor.indexOf(\"top\") > -1) { var topDelta = (currentTop - layerBoundingRect.top) * heightChangedPercent; if(!resizable && Math.round(topDelta)) topDelta += currentSize.height * heightChangedPercent; } else if(anchor.indexOf(\"bottom\") > -1) { if(resizable) topDelta = (currentTop - layerBoundingRect.bottom) * heightChangedPercent; else { var bottomDelta = Math.round(currentTop + currentSize.height - layerBoundingRect.bottom) * heightChangedPercent; if(bottomDelta) topDelta = bottomDelta - currentSize.height * heightChangedPercent; else topDelta = 0; } } else { //center vertical if(resizable) topDelta = (childCenterPoint.y - layerBoundingRect.centerPoint.y)*heightChangedPercent - currentSize.height*heightChangedPercent/2; else { var centerTopChange = Math.round(childCenterPoint.y - layerBoundingRect.centerPoint.y)*heightChangedPercent; if(centerTopChange > 0) topDelta = centerTopChange + Math.abs(currentSize.height * heightChangedPercent / 2); else if(centerTopChange < 0) topDelta = centerTopChange - Math.abs(currentSize.height * heightChangedPercent / 2); else topDelta = 0; } } if(changeLeft) { if(anchor.indexOf(\"left\") > -1) { var leftDelta = (currentLeft - layerBoundingRect.left) * widthChangedPercent; if(!resizable && Math.round(leftDelta)) leftDelta += currentSize.width * widthChangedPercent; } else if(anchor.indexOf(\"right\") > -1) { if(resizable) leftDelta = (currentLeft - layerBoundingRect.right) * widthChangedPercent; else { var rightDelta = Math.round(currentLeft + currentSize.width - layerBoundingRect.right) * widthChangedPercent; if(rightDelta) leftDelta = rightDelta - currentSize.width * widthChangedPercent; else leftDelta = 0; } } else { //center horizontal if(resizable) leftDelta = (childCenterPoint.x - layerBoundingRect.centerPoint.x)*widthChangedPercent - currentSize.width*widthChangedPercent/2; else { var centerLeftChange = Math.round(childCenterPoint.x - layerBoundingRect.centerPoint.x) * widthChangedPercent; if(centerLeftChange > 0) leftDelta = centerLeftChange + Math.abs(currentSize.width * widthChangedPercent / 2); else if(centerLeftChange < 0) leftDelta = centerLeftChange - Math.abs(currentSize.width * widthChangedPercent / 2); else leftDelta = 0; } } } if(topDelta) deltaLoc.y += topDelta; if(leftDelta && changeLeft) deltaLoc.x += leftDelta; return css; }; _actionHandlers.setPanelOrder = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.panelPaths.length; i++) { var func = action.panelPaths[i].setOrderInfo.bringToFront ? 'bringToFront' : 'sendToBack'; var elementIds = $ax.getElementIdsFromPath(action.panelPaths[i].panelPath, eventInfo); for(var j = 0; j < elementIds.length; j++) $ax('#' + elementIds[j])[func](); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.modifyDataSetEditItems = function(eventInfo, actions, index) { var action = actions[index]; var add = action.repeatersToAddTo; var repeaters = add || action.repeatersToRemoveFrom; var itemId; for(var i = 0; i < repeaters.length; i++) { var data = repeaters[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(data.path, eventInfo)[0]; if(!id) continue; if(data.addType == 'this') { var scriptId = $ax.repeater.getScriptIdFromElementId(eventInfo.srcElement); itemId = $ax.repeater.getItemIdFromElementId(eventInfo.srcElement); var repeaterId = $ax.getParentRepeaterFromScriptId(scriptId); if(add) $ax.repeater.addEditItems(repeaterId, [itemId]); else $ax.repeater.removeEditItems(repeaterId, [itemId]); } else if(data.addType == 'all') { var allItems = $ax.repeater.getAllItemIds(id); if(add) $ax.repeater.addEditItems(id, allItems); else $ax.repeater.removeEditItems(id, allItems); } else { var oldTarget = eventInfo.targetElement; var itemIds = $ax.repeater.getAllItemIds(id); var itemIdsToAdd = []; for(var j = 0; j < itemIds.length; j++) { itemId = itemIds[j]; eventInfo.targetElement = $ax.repeater.createElementId(id, itemId); if($ax.expr.evaluateExpr(data.query, eventInfo) == \"true\") { itemIdsToAdd[itemIdsToAdd.length] = String(itemId); } eventInfo.targetElement = oldTarget; } if(add) $ax.repeater.addEditItems(id, itemIdsToAdd); else $ax.repeater.removeEditItems(id, itemIdsToAdd); } } _dispatchAction(eventInfo, actions, index + 1); }; _action.repeaterInfoNames = { addItemsToDataSet: 'dataSetsToAddTo', deleteItemsFromDataSet: 'dataSetItemsToRemove', updateItemsInDataSet: 'dataSetsToUpdate', addFilterToRepeater: 'repeatersToAddFilter', removeFilterFromRepeater: 'repeatersToRemoveFilter', addSortToRepeater: 'repeaterToAddSort', removeSortFromRepeater: 'repeaterToRemoveSort', setRepeaterToPage: 'repeatersToSetPage', setItemsPerRepeaterPage: 'repeatersToSetItemCount' }; _actionHandlers.addItemsToDataSet = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.dataSetsToAddTo.length; i++) { var datasetInfo = action.dataSetsToAddTo[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(datasetInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; var dataset = datasetInfo.data; for(var j = 0; j < dataset.length; j++) $ax.repeater.addItem(id, $ax.deepCopy(dataset[j]), eventInfo); if(dataset.length) _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.deleteItemsFromDataSet = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.dataSetItemsToRemove.length; i++) { // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var deleteInfo = action.dataSetItemsToRemove[i]; var id = $ax.getElementIdsFromPath(deleteInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; $ax.repeater.deleteItems(id, eventInfo, deleteInfo.type, deleteInfo.rule); _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.updateItemsInDataSet = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.dataSetsToUpdate.length; i++) { var dataSet = action.dataSetsToUpdate[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(dataSet.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; $ax.repeater.updateEditItems(id, dataSet.props, eventInfo, dataSet.type, dataSet.rule); _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.setRepeaterToDataSet = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.repeatersToSet.length; i++) { var setRepeaterInfo = action.repeatersToSet[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(setRepeaterInfo.path, eventInfo)[0]; if(!id) continue; $ax.repeater.setDataSet(id, setRepeaterInfo.localDataSetId); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.addFilterToRepeater = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.repeatersToAddFilter.length; i++) { var addFilterInfo = action.repeatersToAddFilter[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(addFilterInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; $ax.repeater.addFilter(id, addFilterInfo.removeOtherFilters, addFilterInfo.label, addFilterInfo.filter, eventInfo.srcElement); _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.removeFilterFromRepeater = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.repeatersToRemoveFilter.length; i++) { var removeFilterInfo = action.repeatersToRemoveFilter[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(removeFilterInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; if(removeFilterInfo.removeAll) $ax.repeater.removeFilter(id); else if(removeFilterInfo.filterName != '') { $ax.repeater.removeFilter(id, removeFilterInfo.filterName); } _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.addSortToRepeater = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.repeatersToAddSort.length; i++) { var addSortInfo = action.repeatersToAddSort[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(addSortInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; $ax.repeater.addSort(id, addSortInfo.label, addSortInfo.columnName, addSortInfo.ascending, addSortInfo.toggle, addSortInfo.sortType); _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.removeSortFromRepeater = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.repeatersToRemoveSort.length; i++) { var removeSortInfo = action.repeatersToRemoveSort[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(removeSortInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; if(removeSortInfo.removeAll) $ax.repeater.removeSort(id); else if(removeSortInfo.sortName != '') $ax.repeater.removeSort(id, removeSortInfo.sortName); _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.setRepeaterToPage = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.repeatersToSetPage.length; i++) { var setPageInfo = action.repeatersToSetPage[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(setPageInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; var oldTarget = eventInfo.targetElement; eventInfo.targetElement = id; $ax.repeater.setRepeaterToPage(id, setPageInfo.pageType, setPageInfo.pageValue, eventInfo); eventInfo.targetElement = oldTarget; _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.setItemsPerRepeaterPage = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.repeatersToSetItemCount.length; i++) { var setItemCountInfo = action.repeatersToSetItemCount[i]; // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(setItemCountInfo.path, eventInfo)[0]; if(!id || _ignoreAction(id)) continue; if(setItemCountInfo.noLimit) $ax.repeater.setNoItemLimit(id); else $ax.repeater.setItemLimit(id, setItemCountInfo.itemCountValue, eventInfo); _addRefresh(id); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.refreshRepeater = function(eventInfo, actions, index) { // We use this as a psudo action now. var action = actions[index]; for (var i = 0; i < action.repeatersToRefresh.length; i++) { // Grab the first one because repeaters must have only element id, as they cannot be inside repeaters // or none if unplaced var id = $ax.getElementIdsFromPath(action.repeatersToRefresh[i], eventInfo)[0]; if(id) _tryRefreshRepeater(id, eventInfo); } _dispatchAction(eventInfo, actions, index + 1); }; var _tryRefreshRepeater = function(id, eventInfo) { var idIndex = _repeatersToRefresh.indexOf(id); if(idIndex == -1) return; $ax.splice(_repeatersToRefresh, idIndex, 1); $ax.repeater.refreshRepeater(id, eventInfo); }; _action.tryRefreshRepeaters = function(ids, eventInfo) { for(var i = 0; i < ids.length; i++) _tryRefreshRepeater(ids[i], eventInfo); }; _actionHandlers.scrollToWidget = function(eventInfo, actions, index) { var action = actions[index]; var elementIds = $ax.getElementIdsFromPath(action.objectPath, eventInfo); if(elementIds.length > 0) $ax('#' + elementIds[0]).scroll(action.options); _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.enableDisableWidgets = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.pathToInfo.length; i++) { var elementIds = $ax.getElementIdsFromPath(action.pathToInfo[i].objectPath, eventInfo); var enable = action.pathToInfo[i].enableDisableInfo.enable; for(var j = 0; j < elementIds.length; j++) $ax('#' + elementIds[j]).enabled(enable); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.setImage = function(eventInfo, actions, index) { var oldTarget = eventInfo.targetElement; var action = actions[index]; var view = $ax.adaptive.currentViewId; eventInfo.image = true; for(var i = 0; i < action.imagesToSet.length; i++) { var imgInfo = action.imagesToSet[i]; imgInfo = view ? imgInfo.adaptive[view] : imgInfo.base; var elementIds = $ax.getElementIdsFromPath(action.imagesToSet[i].objectPath, eventInfo); for(var j = 0; j < elementIds.length; j++) { var elementId = elementIds[j]; eventInfo.targetElement = elementId; var evaluatedImgs = _evaluateImages(imgInfo, eventInfo); var img = evaluatedImgs.normal; if($ax.style.IsWidgetDisabled(elementId)) { if(imgInfo.disabled) img = evaluatedImgs.disabled; } else if($ax.style.IsWidgetSelected(elementId)) { if(imgInfo.selected) img = evaluatedImgs.selected; } else if($ax.event.mouseDownObjectId == elementId && imgInfo.mouseDown) img = evaluatedImgs.mouseDown; else if($ax.event.mouseOverIds.indexOf(elementId) != -1 && imgInfo.mouseOver) { img = evaluatedImgs.mouseOver; //Update mouseOverObjectId var currIndex = $ax.event.mouseOverIds.indexOf($ax.event.mouseOverObjectId); var imgIndex = $ax.event.mouseOverIds.indexOf(elementId); if(currIndex < imgIndex) $ax.event.mouseOverObjectId = elementId; } else if(imgInfo.mouseOver && elementId == eventInfo.srcElement) { img = evaluatedImgs.mouseOver; } // $('#' + $ax.repeater.applySuffixToElementId(elementId, '_img')).attr('src', img); $jobj($ax.GetImageIdFromShape(elementId)).attr('src', img); //Set up overrides $ax.style.mapElementIdToImageOverrides(elementId, evaluatedImgs); $ax.style.updateElementIdImageStyle(elementId); if(evaluatedImgs.mouseOver || evaluatedImgs.mouseDown) $ax.event.updateIxStyleEvents(elementId); } } eventInfo.targetElement = oldTarget; eventInfo.image = false; _dispatchAction(eventInfo, actions, index + 1); }; var _evaluateImages = function(imgInfo, eventInfo) { var retVal = {}; for(var state in imgInfo) { if(!imgInfo.hasOwnProperty(state)) continue; var img = imgInfo[state][$ax.adaptive.getSketchKey()] || $ax.expr.evaluateExpr(imgInfo[state].literal, eventInfo); if(!img) img = $axure.utils.getTransparentGifPath(); retVal[state] = img; } return retVal; }; $ax.clearRepeaterImageOverrides = function(repeaterId) { var childIds = $ax.getChildElementIdsForRepeater(repeaterId); for(var i = childIds; i < childIds.length; i++) $ax.style.deleteElementIdToImageOverride(childIds[i]); }; _actionHandlers.setFocusOnWidget = function(eventInfo, actions, index) { var action = actions[index]; if(action.objectPaths.length > 0) { var elementIds = $ax.getElementIdsFromPath(action.objectPaths[0], eventInfo); if(elementIds.length > 0) { $ax('#' + elementIds[0]).focus(); //if select text and not in placeholder mode, then select all text if(action.selectText && !$ax.placeholderManager.isActive(elementIds[0])) { var elementChildren = document.getElementById(elementIds[0]).children; //find the input or textarea element for(var i = 0; i < elementChildren.length; i++) { if (elementChildren[i].id.indexOf('_input') == -1) continue; var elementTagName = elementChildren[i].tagName; if(elementTagName && (elementTagName.toLowerCase() == \"input\" || elementTagName.toLowerCase() == \"textarea\")) { elementChildren[i].select(); } } } } } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.expandCollapseTree = function(eventInfo, actions, index) { var action = actions[index]; for(var i = 0; i < action.pathToInfo.length; i++) { var pair = action.pathToInfo[i]; var elementIds = $ax.getElementIdsFromPath(pair.treeNodePath, eventInfo); for(var j = 0; j < elementIds.length; j++) $ax('#' + elementIds[j]).expanded(pair.expandCollapseInfo.expand); } _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.other = function(eventInfo, actions, index) { var action = actions[index]; $ax.navigate({ url: $axure.utils.getOtherPath() + \"#other=\" + encodeURI(action.otherDescription), target: \"popup\", includeVariables: false, popupOptions: action.popup }); _dispatchAction(eventInfo, actions, index + 1); }; _actionHandlers.fireEvents = function(eventInfo, actions, index) { var action = actions[index]; //look for the nearest element id var objId = eventInfo.srcElement; var thisWidget = eventInfo.thiswidget; var obj = $ax.getObjectFromElementId(objId); var rdoId = obj ? $ax.getRdoParentFromElementId(objId) : \"\"; var rdo = $ax.getObjectFromElementId(rdoId); var page = rdo ? $ax.pageData.masters[rdo.masterId] : $ax.pageData.page; // Check if rdo should be this var oldIsMasterEvent = eventInfo.isMasterEvent; if (obj && $ax.public.fn.IsReferenceDiagramObject(obj.type) && eventInfo.isMasterEvent) { rdoId = objId; rdo = obj; page = $ax.pageData.masters[rdo.masterId]; } for(var i = 0; i < action.firedEvents.length; i++) { var firedEvent = action.firedEvents[i]; var isPage = firedEvent.objectPath.length == 0; var targetObjIds = isPage ? [rdoId] : $ax.getElementIdsFromPath(firedEvent.objectPath, eventInfo); for (var j = 0; j < targetObjIds.length; j++) { var targetObjId = targetObjIds[j]; var targetObj = isPage ? rdo : $ax.getObjectFromElementId(targetObjId); eventInfo.srcElement = targetObjId || ''; eventInfo.thiswidget = $ax.getWidgetInfo(eventInfo.srcElement); eventInfo.isMasterEvent = false; var raisedEvents = firedEvent.raisedEventIds; if(raisedEvents) { for(var k = 0; k < raisedEvents.length; k++) { var event = targetObj.interactionMap && targetObj.interactionMap.raised && targetObj.interactionMap.raised[raisedEvents[k]]; if(event) $ax.event.handleEvent(targetObjId, eventInfo, event, false, true); } } if(isPage) { eventInfo.isMasterEvent = true; eventInfo.label = $ax.pageData.page.name; eventInfo.friendlyType = 'Page'; } var firedTarget = isPage ? page : targetObj; var firedEventNames = firedEvent.firedEventNames; if(firedEventNames) { for(k = 0; k < firedEventNames.length; k++) { event = firedTarget.interactionMap && firedTarget.interactionMap[firedEventNames[k]]; if(event) $ax.event.handleEvent(isPage ? '' : targetObjId, eventInfo, event, false, true); } } if(isPage) eventInfo.isMasterEvent = oldIsMasterEvent; } eventInfo.srcElement = objId; eventInfo.thiswidget = thisWidget; eventInfo.isMasterEvent = oldIsMasterEvent; } _dispatchAction(eventInfo, actions, index + 1); }; }); //***** expr.js *****// // ******* Expr MANAGER ******** // $axure.internal(function($ax) { var _expr = $ax.expr = {}; var _binOpHandlers = { '&&': function(left, right) { return _binOpOverride(left, right, function(left) { return $ax.getBool(left) && $ax.getBool(right()); }); }, '||': function(left, right) { return _binOpOverride(left, right, function(left) { return $ax.getBool(left) || $ax.getBool(right()); }); }, '==': function(left, right) { return isEqual(left, right, true); }, '!=': function(left, right) { return !isEqual(left, right, true); }, '>': function(left, right) { return _binOpNum(left, right, function(left, right) { return left > right; }); }, '=': function(left, right) { return _binOpNum(left, right, function(left, right) { return left >= right; }); }, '"}],"posts":[{"title":"聊聊react fiber架构","slug":"聊聊react fiber架构","date":"2021-05-01T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2021/05/02/聊聊react fiber架构/","permalink":"https://justsso1.github.io/2021/05/02/%E8%81%8A%E8%81%8Areact%20fiber%E6%9E%B6%E6%9E%84/","excerpt":"","text":"本篇文章的大纲也就是写作的思路如下： react fiber架构是什么？ react fiber出现的时间节点 为什么要有fiber架构，解决了什么问题？ react fiber架构是怎么做的？实现原理 react fiber是一种表示react节点的数据结构，现在我们所说的react fiber通常是指一种架构，react在16版本以后采用fiber架构 react fiber是在v16出现的，重写了v15中的底层，并且对外输出的api保持不变。 那么v15有什么问题呢，才会被推翻，被fiber架构取代。 v15中的render渲染是栈调和的，基于栈和深度递归，一直递归到最底层才会返回，如果执行的时间超过16ms(浏览器1s60帧)，就会出现卡顿现象。所以必须要解决这个问题。我们希望react调和是怎样的呢，我们希望它可以暂停，在当前可用时间小于一帧的情况下，暂停，然后还能继续恢复。然后还有在有更高优先级的时候，我们希望它可以先去处理更高优先级，处理完了之后再来接着处理这个问题。基于我们想要实现的效果，react采用了更先进的理念，纤程（比线程更小的单位），自己实现纤程，做到可以暂停，可以继续的架构，这底层的结构就叫fiber 那么fiber是怎么做的呢，可以实现可中断、可继续。fiber分为两部分 render和commit阶段，render阶段是可以停下来，再接着执行的，所以可能会被执行多次，而commit会和底层的dom操作有关，是不能被停下来的。 随着fiber架构思想的出现，fiber还带来”周边“的变化，那就是生命周期的变化，直接说是 react 15中的compomentWillDidMount componentWillUpdate componentWillRecivedProps 因为这三个生命周期是在render阶段，又可能会被重复执行，而开发者又有时会滥用，把一些副作用的代码写在这三个生命周期中。所以react团队去掉了这三个生命周期，加入了getDerivedStateFromProps getSnapshotBeforUpdate 这两个静态方法，在静态方法中是拿不到this的 react hooks的设计动机与工作模式 hooks是只能在function组件中使用，到现在react 团队都是在推崇使用function组件的。那么为什么是function 组件了呢？因为function组件更加符合react的理念，那就是 UI &#x3D; f(data)，在function 中渲染可以读取到data。函数组件会捕获render内部的状态，这是和class组件最大的不同。 Hooks本质:一套能够使函数组件更强大、更灵活的”钩子“ 函数组件比起类组件”少”了很多东西，比如生命周期、对state的管理。React-Hooks的出现，就是为了帮助函数组件补齐这些（相对于类组件来说，但生命周期这些也不是必须，只是完成一件事情的步骤代号而已）","categories":[],"tags":[]},{"title":"【转载】JavaScript模块简史","slug":"【转载】JavaScript模块简史","date":"2020-08-08T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2020/08/09/【转载】JavaScript模块简史/","permalink":"https://justsso1.github.io/2020/08/09/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91JavaScript%E6%A8%A1%E5%9D%97%E7%AE%80%E5%8F%B2/","excerpt":"","text":"你是否是 JavaScript 新手？并且对模块，模块加载器和模块打包器感到困惑吗？或者你已经编写了一段时间的 JavaScript ，但是没法掌握模块的一些术语？你是否听过 CommonJS、AMD、Browserify、SystemJS、Webpack、JSPM 等等术语，但是不理解我们为什么需要它们？ 我会试着解释他们是什么，他们试图解决什么问题，以及他们如何解决这个问题。 示例应用程序 (该图为应用程序运行界面) 在这篇文章中，我将使用一个简单的 web 应用程序来演示模块的概念。应用程序在浏览器中显示数组的和。该应用程序由4个函数和一个 index.html文件组成。(该图为函数的依赖示意图) main 函数计算数组中数字的和，然后把答案显示在 span#answer 中。sum 函数依赖于两个函数：add 和 reduce。add 函数做它名字所做的操作；把两个数相加。reduce 函数遍历数组，并且调用 iteratee 回调函数。 花点时间理解下面的代码。我将会重复多次使用相同的函数。 HTML 代码: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS Modules&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; The Answer is &lt;span id=&quot;answer&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 代码: 1234// 1-main.js var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values)document.getElementById(&quot;answer&quot;).innerHTML = answer; JavaScript 代码: 1234// 2-sum.js function sum(arr)&#123; return reduce(arr, add);&#125; JavaScript 代码: 12345// 3-add.js function add(a, b) &#123; return a + b;&#125; JavaScript 代码: 12345678910// 4-reduce.js function reduce(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; for(index += 1; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo;&#125; 我们来看看如何把这些代码片段整合在一起，来构建一个应用程序。 使用内嵌脚本内嵌脚本就是在 标记之间添加 JavaScript 代码。这是我开始学 JavaScript 时的做法。我相信大多数 JavaScript 开发者在其生命中至少做过一次这样的事情。 这是一个很好的入门办法。没有外部文件或依赖关系需要担心。但是这也导致了不可维护的代码，因为： 缺乏代码可重用性：如果需要添加另一个页面，需要从这个页面中获得一些函数，我们就不得不复制粘贴代码。缺乏依赖解析：你必须保证 main 函数之前已经添加了 add、reduce 和 sum 函数。全局命名空间污染：所有的函数和变量将都将驻留在全局作用域中。 HTML 代码: 123456789101112131415161718192021222324252627282930313233343536&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS Modules&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; The Answer is &lt;span id=&quot;answer&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;script type=&quot;text/javascript&quot;&gt; function add(a, b) &#123; return a + b; &#125; function reduce(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; for(index += 1; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo; &#125; function sum(arr)&#123; return reduce(arr, add); &#125; /* Main Function */ var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ]; var answer = sum(values) document.getElementById(&quot;answer&quot;).innerHTML = answer; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Script 标签引入 JavaScript 文件这是从嵌入脚本的一个自然过渡。现在我们将大段的 JavaScript 分成更小的代码片段，并用 标签加载它们。 通过将文件分成多个 JavaScript 文件，我们可以重用这些代码。我们不再需要在不同的 html 页面之间复制和粘贴代码。我们只需要将该文件用 script 标签加载就可以了。尽管这是更好的方法，但仍然有以下问题： 缺乏依赖解析：文件的顺序很重要。你必须保证在加载 main.js 文件之前已经\b加载了 add.js、reduce.js 和 sum.js 文件。 全局命令空间污染：所有的函数和变量依然在全局作用域中。 HTML 代码: 12345678910111213141516171819&lt;!-- 0-index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS Modules&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; The Answer is &lt;span id=&quot;answer&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./add.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./reduce.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./sum.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 代码: 12//add.jsfunction add(a, b) &#123; return a + b;&#125; JavaScript 代码: 123456789101112//reduce.jsfunction reduce(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo;&#125; JavaScript 代码: 1234//sum.jsfunction sum(arr)&#123; return reduce(arr, add);&#125; JavaScript 代码: 1234// main.jsvar values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values)document.getElementById(&quot;answer&quot;).innerHTML = answer; 模块对象和 IIFE(模块模式)通过使用模块对象和 立即调用的函数表达式(IIFE) ，我们可以减少对全局作用域的污染。在这种方法中，我们只向全局作用域公开一个对象。该对象包含了我们在应用程序中需要的所有方法和值。在本例中，我们只向全局作用域公开了 myApp 对象。所有的函数都将被保存在 myApp 对象中。 JavaScript 代码: 12// 01-my-app.js var myApp = &#123;&#125;; JavaScript 代码: 123456// 02-add.js(function()&#123; myApp.add = function(a, b) &#123; return a + b; &#125; &#125;)(); JavaScript 代码: 1234567891011121314// 03-reduce.js (function()&#123; myApp.reduce = function(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo; &#125; &#125;)(); JavaScript 代码: 123456// 04-sum.js(function()&#123; myApp.sum = function(arr)&#123; return myApp.reduce(arr, myUtil.add); &#125; &#125;)(); JavaScript 代码: 123456// 05-main.js(function(app)&#123; var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ]; var answer = app.sum(values) document.getElementById(&quot;answer&quot;).innerHTML = answer;&#125;)(myApp); HTML 代码: 1234567891011121314151617181920&lt;!-- 06-index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS Modules&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; The Answer is &lt;span id=&quot;answer&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./my-app.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./add.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./reduce.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./sum.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 请注意，除了 my-app.js 之外，其它每个文件都被封装成了 IIFE 格式。 JavaScript 代码: 12// 立即调用的函数表达式(IIFE) 格式(function()&#123; /*... your code goes here ...*/ &#125;)(); 通过将每个文件封装到 IIFE 中，所有的本地变量都保留在函数作用域内。因此，函数中的所有变量都将保持在函数作用域内，而不会污染全局作用域。 我们通过将它们附加到myApp对象来公开添加、减少和sum函数。我们通过引用myApp对象来访问这些函数 我们通过将 add、reduce 和 sum 函数附加在 myApp 对象上，从而对外公开它们。我们通过引用 myApp 对象来访问这些函数： JavaScript 代码: 123myApp.add(1,2);myApp.sum([1,2,3,4]);myApp.reduce(add, value); 我们还可以通过 IIFE 的参数，传递 myApp 全局对象，就像 main.js 文件中所示一样。通过将该对象作为参数传递给 IIFE ，我们就可以为该对象选择一个较短的别名。而我们的代码会更简洁一些。 JavaScript 代码: 123(function(obj)&#123; // obj is new veryLongNameOfGlobalObject&#125;)(veryLongNameOfGloablObject); 与前面的例子相比，IIFE 是一个巨大的改进。大多数流行的 JavaScript 库，如 jQuery ，都使用这种模式。它公开了一个全局对象 $，所有的函数都在 $ 对象中。 然而，这并不能算是一个完美的解决方案。这种方法仍然面临与上一节相同的问题。 缺乏依赖解析：文件的顺序依然重要，myApp.js 必须出现在所有其它文件之前加载，main.js 必须处在所有其它库文件之后。 全局命令空间污染：现在全局变量的数量变成了 1，但是还不是 0 。 CommonJS2009年，有人讨论将 JavaScript 引入服务器端。因此 ServerJS 诞生了。随后，ServerJS 将其名称改为 CommonJS 。 CommonJS 不是一个 JavaScript 库。它是一个标准化组织。它就像 ECMA 或 W3C 一样。ECMA 定义了 JavaScript 的语言规范。W3C定义了 JavaScript web API ，比如 DOM 或 DOM 事件。 CommonJS 的目标是为 web 服务器、桌面和命令行应用程序定义一套通用的 API 。 CommonJS 还定义了模块 API 。因为在服务器应用程序中没有 HTML 页面和 标签，所以为模块提供一些清晰的 API 是很有意义的。模块需要被公开(export)以供其它模块使用，并且可以访问(import)。它的导出模块语法如下： JavaScript 代码: 1234// add.jsmodule.exports = function add(a, b)&#123; return a+b;&#125; 上述代码定义和输出了一个模块。代码保存在 add.js 文件中。 要使用或导入 add 模块，您需要 require 函数，使用文件名或模块名作为参数。下面的语法描述了如何将一个模块导入到代码中： JavaScript 代码: 1var add = require(&#x27;./add&#x27;); 如果您在 NodeJS 上编写了代码，那么这种语法可能看起来很熟悉。这是因为 NodeJS 实现了 CommonJS 风格的模块API。 异步模块定义(AMD)CommonJs 风格的模块定义的问题在于它是同步的。当你调用 var add=require('add'); 时，系统将暂停，直到模块 准备(ready) 完成。这意味着当所有的模块都加载时，这一行代码将冻结浏览器(注：意思为除了加载该文件，浏览器什么事情也不做)。因此，这可能不是为浏览器端应用程序定义模块的最佳方式。 为了把服务器端用的模块语法转换给浏览器使用，CommonJS 提出了几种模块格式，“Module/Transfer” 。其中之一，即 “Module/Transfer/C“，后来成为 异步模块定义(AMD) 。 AMD具有以下格式： JavaScript 代码: 123define([‘add’, ‘reduce’], function(add, reduce)&#123; return function()&#123;...&#125;;&#125;); define 函数(或关键字)将依赖项列表和回调函数作为参数。回调函数的参数与数组中的依赖是相同的顺序。这相当于导入模块。并且回调函数返回一个值，即是你导出的值。 CommonJS 和 AMD 解决了模块模式中剩下的两个问题：依赖解析 和 全局作用域污染 。我们只需要处理每个模块或每个文件的依赖关系就可以了。并且不再有全局作用域污染。 RequireJS在我们的浏览器应用程序中，AMD 可以把我们从 script 标签和全局污染中解救出来。那么，我们该如何使用它呢？这里 RequireJS 就可以帮助我们了。RequireJS 是一个 JavaScript 模块加载器(module loader) 。它可以根据需要异步加载模块。 尽管 RequireJS 的名字中含有 require，但是它的目标却并非要去支持 CommonJS 的 require 语法。使用 RequireJS，您可以编写 AMD 风格的模块。 在编写自己的应用程序之前，你将不得不从 RequireJS 网站 下载 require.js 文件。如下代码是用 RequireJS 编写的示例应用程序。 下面是 AMD 风格的应用程序示例HTML 代码: 12345678910111213141516&lt;!-- 0-index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS Modules&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; The Answer is &lt;span id=&quot;answer&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;script data-main=&quot;main&quot; src=&quot;require.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 代码: 123456// main.jsdefine([&#x27;sum&#x27;], function(sum)&#123; var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ]; var answer = sum(values) document.getElementById(&quot;answer&quot;).innerHTML = answer;&#125;) JavaScript 代码: 12345678// sum.jsdefine([&#x27;add&#x27;, &#x27;reduce&#x27;], function(add, reduce)&#123; var sum = function(arr)&#123; return reduce(arr, add); &#125;; return sum;&#125;) JavaScript 代码: 12345678// add.jsdefine([], function()&#123; var add = function(a, b)&#123; return a + b; &#125;; return add;&#125;); JavaScript 代码: 12345678910111213141516// reduce.jsdefine([], function()&#123; var reduce = function(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo; &#125; return reduce;&#125;) 注意在 index.html 中只有一个 script 标签。HTML 代码: 1&lt;script data-main=”main” src=”require.js”&gt;&lt;/script&gt; 这个标签加载 require.js 库到页面，data-main 属性告诉 RequieJS 应用程序的入口点在哪里。默认情况下，它假定所有文件都有 .js 文件扩展名，所以省略 .js 文件扩展名是可以的。在 RequireJS 加载了 main.js 文件之后，就会加载该文件的依赖，以及依赖的依赖，等等。浏览器的开发者工具会显示所有文件以如下顺序加载(如图)： 浏览器加载 index.html，而 index.html 又加载 require.js 。剩下的文件及其依赖都是由 require.js 负责加载。 RequireJS 和 AMD 解决了我们以前所遇到的所有问题。然而，它也带来了一些不那么严重的问题。 AMD 的语法过于冗余。因为所有东西都封装在 define 函数中，所以我们的代码有一些额外的缩进。对于一个小文件来说，这不是什么大问题，但是对于一个大型的代码库来说，这可能是一种精神上的负担。 数组中的依赖列表必须与函数的参数列表匹配。如果存在许多依赖项，则很难维护依赖项的顺序。如果您的模块中有几十个依赖项，并且如果你不得不在中间删除某个依赖，那么就很难找到匹配的模块和参数。 在当前浏览器下（HTTP 1.1），加载很多小文件会降低性能。 Browserify由于上述这些原因，有些人想要使用 CommonJS 语法来替换。但 CommonJS 语法是用于服务端，并且是同步的，对吗？这时 Browserify 就来解救我们了！通过 Browserify ，你可以在浏览器应用程序中使用 CommonJS 模块。Browserify 是一个 模块打包器(module bundler) 。Browserify 遍历代码的依赖树，并将依赖树中的所有模块打包成一个文件。 不同于 RequireJS ，但是 Browserify 是一个命令行工具，需要 NodeJS 和 NPM 来安装它。如果系统中安装了 NodeJS ，就可以用如下命令来安装 Browserify： CommandLine 代码: 1npm install -g browserify 让我们看一下我们用 CommonJS 语法编写的示例应用程序。 HTML 代码: 12345678910111213141516&lt;!-- 0-index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS Modules&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; The Answer is &lt;span id=&quot;answer&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 代码: 123456//main.jsvar sum = require(&#x27;./sum&#x27;);var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values) document.getElementById(&quot;answer&quot;).innerHTML = answer; JavaScript 代码: 1234567//sum.jsvar reduce = require(&#x27;./reduce&#x27;);var add = require(&#x27;./add&#x27;); module.exports = function(arr)&#123; return reduce(arr, add);&#125;; JavaScript 代码: 12345Javascript//add.jsmodule.exports = function add(a,b)&#123; return a + b;&#125;; JavaScript 代码: 123456789101112//reduce.jsmodule.exports = function reduce(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo;&#125;; 你可能已经注意到，在 index.html 文件中，script 标记加载了 bundle.js，但是 bundle.js 文件在哪里？一旦我们执行了如下命令，Browserify 就会为我们生成这个文件： CommandLine 代码: 1$ browserify main.js -o bundle.js Browserify 解析 main.js 中的 require() 函数调用，并遍历项目中的依赖树。然后将依赖树打包到一个文件中。 Browserify 生成如下 bundle.js 文件的代码： JavaScript 代码: 12345678910111213141516171819202122232425262728293031323334function e(t,n,r)&#123;function s(o,u)&#123;if(!n[o])&#123;if(!t[o])&#123;var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#x27;&quot;+o+&quot;&#x27;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f&#125;var l=n[o]=&#123;exports:&#123;&#125;&#125;;t[o][0].call(l.exports,function(e)&#123;var n=t[o][1][e];return s(n?n:e)&#125;,l,l.exports,e,t,n,r)&#125;return n[o].exports&#125;var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s&#125;)(&#123;1:[function(require,module,exports)&#123;module.exports = function add(a,b)&#123; return a + b;&#125;; &#125;,&#123;&#125;],2:[function(require,module,exports)&#123;var sum = require(&#x27;./sum&#x27;);var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values) document.getElementById(&quot;answer&quot;).innerHTML = answer; &#125;,&#123;&quot;./sum&quot;:4&#125;],3:[function(require,module,exports)&#123;module.exports = function reduce(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo;&#125;; &#125;,&#123;&#125;],4:[function(require,module,exports)&#123;var reduce = require(&#x27;./reduce&#x27;);var add = require(&#x27;./add&#x27;); module.exports = function(arr)&#123; return reduce(arr, add);&#125;; &#125;,&#123;&quot;./add&quot;:1,&quot;./reduce&quot;:3&#125;]&#125;,&#123;&#125;,[2]); 您不需要逐行地理解这个打包文件。但值得注意的是，所有熟悉的代码、main.js 文件和所有依赖项都包含在这个文件中。 UMD – 只是为了让你更困惑现在我们已经学习了 全局对象(Global Object)，CommonJS 和 AMD 风格的模块。也有一些库可以帮助我们直接使用 CommonJS 或者 AMD 。但是，如果您正在编写一个模块，并部署到互联网上，该怎么办呢？你需要编写哪种模块风格呢？ 编写三种不同的模块类型，即 全局模块对象 、CommonJS 和 AMD 。但是你必须维护三个不同的文件。用户将不得不识别他们正在下载的模块的类型。 通用模块定义(Universal Module Definition) ，即我们通常说的 UMD ，就是用来解决这个特殊问题的。本质上，UMD 是一套用来识别当前环境支持的模块风格的 if/else 语句。 JavaScript 代码: 123456789101112131415161718192021// UMD 风格编写的 sum 模块//sum.umd.js(function (root, factory) &#123; if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) &#123; // AMD define([&#x27;add&#x27;, &#x27;reduce&#x27;], factory); &#125; else if (typeof exports === &#x27;object&#x27;) &#123; // Node, CommonJS-like module.exports = factory(require(&#x27;add&#x27;), require(&#x27;reduce&#x27;)); &#125; else &#123; // Browser globals (root is window) root.sum = factory(root.add, root.reduce); &#125;&#125;(this, function (add, reduce) &#123; // private methods // exposed public methods return function(arr) &#123; return reduce(arr, add); &#125;&#125;)); ES6 模块语法 注：了解更多关于 ES6 模块的信息，建议阅读 ECMAScript 6 Modules(模块)系统及语法详解。 JavaScript 全局模块对象、CommonJS、AMD 和 UMD，我们有太多的选项了。现在或许你会问，下一个项目我该用哪一个呢？答案是一个都不用。 JavaScript 语言中并没有内置模块系统。这就是为什么我们有这么多不同的导入和导出模块的原因。但这种情况最近发生了变化。 ES6 语言规范中，模块是 JavaScript 的一部分。所以这个问题的答案是，如果你想让你的项目想\b兼容未来，你需要使用 ES6 模块语法。 ES6 用 import 和 export 关键字来导入和导出模块。如下是用 ES6 模块语法编写的示例应用程序。 JavaScript 代码: 1234567// main.jsimport sum from &quot;./sum&quot;;var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values);document.getElementById(&quot;answer&quot;).innerHTML = answer; JavaScript 代码: 1234567// sum.jsimport add from &#x27;./add&#x27;;import reduce from &#x27;./reduce&#x27;;export default function sum(arr)&#123; return reduce(arr, add);&#125; JavaScript 代码: 1234// add.jsexport default function add(a,b)&#123; return a + b;&#125; JavaScript 代码: 123456789//reduce.jsexport default function reduce(arr, iteratee) &#123; let index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]); &#125; return memo;&#125; 有很多关于 ES6 模块的流行语：ES6 模块语法是简洁的。ES6 模块将统治 JavaScript 世界。它是未来。但不幸的是，有一个问题。浏览器还没有为这种新语法做好准备。在撰写文章的时候，只有 Chrome 浏览器支持 import 语句。即使大多数浏览器支持 import 和 export ，如果您的应用程序必须支持较老的浏览器，那么您可能会遇到问题。 幸运的是，现在已经有很多工具可以用了，这些工具让我们现在就可以用 ES6 模块语法。 WebpackWebpack 是一个 模块打包器(module bundler) 。就像 Browserify 一样，它会遍历依赖树，然后将其打包到一到多个文件。那么问题来了，如果它和 Browserify 一样，为什么我们需要另一个模块打包器呢？Webpack 可以处理 CommonJS 、 AMD 和 ES6 模块。并且 Webpack 还有更多的灵活性和一些很酷的功能特性，比如： 代码分离：当您有多个应用程序共享相同的模块时。Webpack 可以将您的代码打包到两个或更多的文件中。例如，如果您有两个应用程序 app1 和 app2 ，并且都共享许多模块。 使用 Browserify ，你会有 app1.js 和 app2.js 。并且都包含所有依赖关系模块。但是使用 Webpack ，您可以创建 app1.js ，app2.js 和 shared-lib.js。是的，您必须从 html 页面加载 2 个文件。但是使用哈希文件名，浏览器缓存和 CDN ，可以减少初始加载时间。 加载器：用自定义加载器，可以加载任何文件到源文件中。用 require() 语法，不仅仅可以加载 JavaScript 文件，还可以加载 CSS、CoffeeScript、Sass、Less、HTML模板、图像，等等。 插件：Webpack 插件可以在打包写入到打包文件之前对其进行操作。有很多社区创建的插件。例如，给打包代码添加注释，添加 Source map，将打包文件分离成块等等。 WebpackDevServer 是一个开发服务器，它可以在源代码改变被检测到时自动打包源代码，并刷新浏览器。它通过提供代码的即时反馈，从而加快开发过程。 让我们来看看我们如何用 Webpack 来构建示例应用程序。Webpack 需要一点引导和配置。 因为 Webpack 是 JavaScript 命令行工具，所以需要先安装上 NodeJS 和 NPM 。装好 NPM 后，执行如下命令初始化项目： CommandLine 代码: 123$ mkdir project; cd project$ npm init -y$ npm install -D webpack webpack-dev-server 您需要一个 webpack 的配置文件。你的配置中至少需要 entry 和 output 两个字段。在 webpack.config.js 中保存以下内容。 JavaScript 代码: 1234567// webpack.config.js webpack 的配置文件module.exports = &#123; entry: ‘./app/main.js’, output: &#123; filename: ‘bundle.js’ &#125;&#125; 打开 package.json 文件，在 script 字段后添加如下行： JavaScript 代码: 1234&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server -progress -colors&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在在 project/app 目录下添加所有 JavaScript 模块，在 project 目录下添加 index.html。 HTML 代码: 123456789101112131415&lt;!-- 0-index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS Modules&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; The Answer is &lt;span id=&quot;answer&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 代码: 123456789101112131415161718// 03-package.json 特别注意，这行注释不要复制，\b否则\bjson文件会报错&#123; &quot;name&quot;: &quot;jsmodules&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --progress --colors&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^1.12.14&quot;, &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot; &#125;&#125; JavaScript 代码: 1234// app/add.jsmodule.exports = function add(a,b)&#123; return a + b;&#125;; JavaScript 代码: 123456789101112// app/reduce.jsmodule.exports = function reduce(arr, iteratee) &#123; var index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]) &#125; return memo;&#125;; JavaScript 代码: 12345678// app/sum.jsdefine([&#x27;./reduce&#x27;, &#x27;./add&#x27;], function(reduce, add)&#123; sum = function(arr)&#123; return reduce(arr, add); &#125; return sum;&#125;); JavaScript 代码: 123456// app/main.jsvar sum = require(&#x27;./sum&#x27;);var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values) document.getElementById(&quot;answer&quot;).innerHTML = answer; 注意 add.js 和 reduce.js 是用 CommonJS 风格写的，而 sum.js 是用 AMD 风格写的。 Webpack 默认是可以处理 CommonJS 和 AMD。如果你用的是 ES6 模块，那就需要安装和配置 babel loader。 一旦你准备好所有的文件，你可以运行你的应用程序。 CommandLine 代码: 1$ npm start 打开浏览器，把 URL 指向 http://localhost:8080/webpack-dev-server/，如图： 此时，你可以打开你喜欢的编辑器编辑代码。保存文件时，浏览器会自动刷新以显示修改后的结果。 这里你可能会注意到一件事情，就是找不到 dist/bundle.js 文件。这是因为 Webpack Dev Server 会创建打包文件，但是不会写入到文件系统中，而是放在内存中。 如果要部署，就得创建打包文件。可以通过键入如下命令创建 bundle.js 文件： CommandLine 代码: 1$ npm run build 如果有兴趣学习更多的 Webpack 知识，请参考 Webpack 文档页 。 Rollup (2015 年 5 月) 注：Rollup 普及了 JavaScript 圈内一个重要的特性：Tree shaking，即是指消除JavaScript上下文中无用代码，或更精确地说，只保留有用的代码。它依赖于ES6模块 import / export 模块系统的静态结构(static structure)来检测哪一个模块没有被使用，因为，import 和 export 不会在运行时改变。说的再直白一点就是 Tree shaking 从模块包中排除未使用的 exports 项。 webpack 2 内置引入的 Tree-shaking 代码优化技术。 详情阅读 webpack 2 中的 Tree Shaking 将一个大的 JavaScript 库包含进来，只是为了用它几个函数，你是否有这样的经历？Rollup 是另一个 JavaScript ES6 模块打包器。与 Browserify 和 Webpak 不同，rollup 只包含在项目中用到的代码。如果有大模块，带有很多函数，但是你只是用到少数几个，rollup 只会将需要的函数包含到打包文件中，从而显著减少打包文件大小。 Rollup 可以被用作为命令行工具。如果有 NodeJS 和 NPM，那么就可以用如下命令安装 rollup： CommandLine 代码: 1$ npm install -g rollup Rollup 可以与任何类型的模块风格一起工作。但是，推荐使用 ES6 模块风格，这样就可以利用 tree-shaking 功能。如下是用 ES6 编写的示例应用程序代码： JavaScript 代码: 12345// 01-add.js let add = (a,b) =&gt; a + b;let sub = (a,b) =&gt; a - b; export &#123; add, sub &#125;; JavaScript 代码: 123456789101112// reduce.jsexport default (arr, iteratee) =&gt; &#123; let index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]); &#125; return memo;&#125; JavaScript 代码: 12345// sum.jsimport &#123; add &#125; from &#x27;./add&#x27;;import reduce from &#x27;./reduce&#x27;; export default (arr) =&gt; reduce(arr, add); JavaScript 代码: 1234567// main.jsimport sum from &quot;./sum&quot;; var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values); document.getElementById(&quot;answer&quot;).innerHTML = answer; 注意，在 add 模块中，我引入了另一个函数 sub()。但是该函数在应用程序中并没有用到。 现在我们用 rollup 将这些代码打包： CommandLine 代码: 1$ rollup main.js -o bundle.js 这会生成像如下的 bundle.js 文件：JavaScript 代码: 123456789101112131415161718192021// bundle.jslet add = (a,b) =&gt; a + b; var reduce = (arr, iteratee) =&gt; &#123; let index = 0, length = arr.length, memo = arr[index]; index += 1; for(; index &lt; length; index += 1)&#123; memo = iteratee(memo, arr[index]); &#125; return memo;&#125; var sum = (arr) =&gt; reduce(arr, add); var values = [ 1, 2, 4, 5, 6, 7, 8, 9 ];var answer = sum(values); document.getElementById(&quot;answer&quot;).innerHTML = answer; 这里我们可以看到 sub() 函数并没有包含在这个打包文件中。 SystemJSSystemJS 是一个通用的模块加载器，它能在浏览器或者 NodeJS 上动态加载模块，并且支持 CommonJS、AMD、全局模块对象和 ES6 模块。通过使用插件，它不仅可以加载 JavaScript，还可以加载 CoffeeScript 和 TypeScript。 SystemJS 的另一个优点是，它建立在 ES6 模块加载器之上，所以它的语法和 API 在将来很可能是语言的一部分，这会让我们的代码更不会过时。要异步输入一个模块，可以用如下语法： JavaScript 代码: 1System.import(‘module-name’); 然后我们可以用配置 API 来配置 SystemJS 的行为： JavaScript 代码: 1234System.config(&#123; transplier: ‘babel’, baseURL: ‘/app’&#125;); 上面的配置会让 SystemJS 使用 babel 作为 ES6 模块的编译器，并且从 /app 目录加载模块。 随着现代 JavaScript 应用程序变得越来越大，越来越复杂，开发工作流也是如此。所以我们不仅仅模块加载器，还得去寻找开发服务器、生产的模块打包器以及第三方模块的包管理器。 JSPMJSPM 是 JavaScript 开发工具的瑞士军刀，它是既是包管理器，又是模块加载器，又是模块打包器。 现代 JavaScript 开发很少只是需要自己的模块，绝大部分时候，我们还需要第三方模块。使用 JSPM，我们可以使用如下的命令，从 NPM 或者 Github 安装第三方模块： CommandLine 代码: 1jspm install npm:package-name or github:package/name 上述命令会从 npm 或者 github 下载包，并将包安装到 jspm_packages 目录。 在开发模式下，我们可以使用 jspm-server 。像 Webpack Dev Server 一样，它会检测代码改变，重新加载浏览器来显示改变。与 Webpack Dev Server 不同的是，jspm-server 用的是 SystemJS 模块加载器。所以，每次它检测了文件的改变时，不会将所有文件读取来打包，而是只加载页面所需要的模块。 在部署时，肯定要打包代码。JSPM 带有打包器，可以用如下命令对代码打包： CommandLine 代码: 1jspm bundle main.js bundle.js 在幕后，JSPM 用 rollup 作为它的打包器。 总结我希望本文给了足够的信息来理解 JavaScript 模块的词汇。现在你也许会问，下一个项目我应该用什么呢？不幸的是，我回答不了这个问题。现在你有能力开始自己的探索。希望本文能让你更容易理解我提到的有关工具的文档和文章。 本文所有的代码示例都可以在 这个 Github 仓库 中找到。如有任何疑问，请在下面留言。 原文链接：https://medium.com/@sungyeol.choi/javascript-module-module-loader-module-bundler-es6-module-confused-yet-6343510e7bde","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://justsso1.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"由浅入深讲解数组的reduce用法","slug":"由浅入深讲解数组的reduce用法","date":"2020-07-12T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/07/13/由浅入深讲解数组的reduce用法/","permalink":"https://justsso1.github.io/2020/07/13/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%AE%B2%E8%A7%A3%E6%95%B0%E7%BB%84%E7%9A%84reduce%E7%94%A8%E6%B3%95/","excerpt":"","text":"数组中的reduce犹如一只魔法棒，通过它可以做一些黑科技一样的事情。本文从api讲解到一般用法再到高级用法，由浅入深的讲一讲数组中的reduce。MDN链接 Array.prototype.reducereduce的api是这样的， reduce(callback(accumulator, currentValue[, index, array])[,initialValue]) Callback accumulator 积累的值 currentValue 当前值 -index 当前下标 array 当前数组 initialValue 初始值 reduce接受两个参数，回调函数和初识值，初始值是可选的。回调函数接受4个参数：积累值、当前值、当前下标、当前数组。如果reduce的参数只有一个，那么积累值一开始是数组中第一个值，如果reduce的参数有两个，那么积累值一开始是出入的initialValue初始值。然后在每一次迭代时，返回的值作为下一次迭代的accumulator 积累值。 重要说明：如果未设置initialValue，那么reduce将使用您的第一个数组值作为第一次迭代的accumulator，从第二个数组元素上开始循环，从index&#x3D;1开始（如果有的话） 以下是reduce的几种实际应用。 将数组转化为对象 将下面的数组转成以id为key的对象。 1234567891011121314151617181920212223242526272829303132333435const userList = [ &#123; id: 1, username: &#x27;john&#x27;, sex: 1, email: &#x27;john@163.com&#x27; &#125;, &#123; id: 2, username: &#x27;jerry&#x27;, sex: 1, email: &#x27;jerry@163.com&#x27; &#125;, &#123; id: 3, username: &#x27;nancy&#x27;, sex: 0, email: &#x27;&#x27; &#125;];let objUserList = userList.reduce(keyByUserNameReducer, &#123;&#125;)function keyByUserNameReducer(acculumator, currentValue, currentIndex, array) &#123; return &#123;...acculumator, [currentValue.id]: currentValue&#125;&#125;console.log(objUserList)// &#123;// &#x27;1&#x27;: &#123; id: 1, username: &#x27;john&#x27;, sex: 1, email: &#x27;john@163.com&#x27; &#125;,// &#x27;2&#x27;: &#123; id: 2, username: &#x27;jerry&#x27;, sex: 1, email: &#x27;jerry@163.com&#x27; &#125;,// &#x27;3&#x27;: &#123; id: 3, username: &#x27;nancy&#x27;, sex: 0, email: &#x27;&#x27; &#125;// &#125; 将小数组展开成大数组将下面数组按照逗号分割. 1234567891011121314151617181920212223242526272829303132const fileLines = [ &#x27;Inspector Algar,Inspector Bardle,Mr. Barker,Inspector Barton&#x27;, &#x27;Inspector Baynes,Inspector Bradstreet,Inspector Sam Brown&#x27;, &#x27;Monsieur Dubugue,Birdy Edwards,Inspector Forbes,Inspector Forrester&#x27;, &#x27;Inspector Gregory,Inspector Tobias Gregson,Inspector Hill&#x27;, &#x27;Inspector Stanley Hopkins,Inspector Athelney Jones&#x27;];let commaArray = fileLines.reduce(function (acculumator, currentValue, currentIndex, array) &#123; return acculumator.concat(currentValue.split(/,/g))&#125;, [])console.log(commaArray)/*[ &#x27;Inspector Algar&#x27;, &#x27;Inspector Bardle&#x27;, &#x27;Mr. Barker&#x27;, &#x27;Inspector Barton&#x27;, &#x27;Inspector Baynes&#x27;, &#x27;Inspector Bradstreet&#x27;, &#x27;Inspector Sam Brown&#x27;, &#x27;Monsieur Dubugue&#x27;, &#x27;Birdy Edwards&#x27;, &#x27;Inspector Forbes&#x27;, &#x27;Inspector Forrester&#x27;, &#x27;Inspector Gregory&#x27;, &#x27;Inspector Tobias Gregson&#x27;, &#x27;Inspector Hill&#x27;, &#x27;Inspector Stanley Hopkins&#x27;, &#x27;Inspector Athelney Jones&#x27; ]*/ 用reduce实现flatMap 1234567891011121314// 数组的flatMap// flatMap的底层的操作：先使用map操作，然后对得到的数组仅展开一层再得到一个数组const arr = [&quot;今天天气不错&quot;, &quot;&quot;, &quot;早上好&quot;];let flatMapArr = arr.flatMap((item, index) =&gt; &#123; return item.split(&quot;&quot;)&#125;)console.log(flatMapArr) // [&#x27;今&#x27;, &#x27;天&#x27;, &#x27;天&#x27;,&#x27;气&#x27;, &#x27;不&#x27;, &#x27;错&#x27;,&#x27;早&#x27;, &#x27;上&#x27;, &#x27;好&#x27;]// 使用数组的reduce实现数组的flatMaplet reduceFlatMap = arr.reduce(function (acculumator, currentValue, currentIndex, array) &#123; return [...acculumator, ...currentValue.split(&#x27;&#x27;)]&#125;, [])console.log(reduceFlatMap) // [&#x27;今&#x27;, &#x27;天&#x27;, &#x27;天&#x27;,&#x27;气&#x27;, &#x27;不&#x27;, &#x27;错&#x27;,&#x27;早&#x27;, &#x27;上&#x27;, &#x27;好&#x27;] 按顺序执行异步函数 根据userList数组的name属性去依次请求数据。 123456789101112131415161718let asyncReducer = userList.reduce(async function (acculumator, currentValue, currentIndex, array) &#123; const obj = await acculumator.then() let re = await new Promise((resolve, reject) =&gt; &#123; // 用 setTimeout 模拟请求数组 setTimeout(() =&gt; &#123; resolve(`to=&gt;$&#123;currentValue.username&#125;`) &#125;, 1000) &#125;) return &#123;...obj, [currentValue.username]: re&#125;&#125;, Promise.resolve(&#123;&#125;))asyncReducer.then(res =&gt; &#123; console.log(res)&#125;)// 3s之后打印：// &#123; john: &#x27;to=&gt;john&#x27;, jerry: &#x27;to=&gt;jerry&#x27;, nancy: &#x27;to=&gt;nancy&#x27; &#125; 总结： 记住在处理对象数组时要指定一个initialValue 数字数组使用reduce代码干净，请尽量不要把reduce函数过于复杂 不要忘记在回调函数中返回，否则最后得到的值将可能出现错误 回调函数的第三个参数index访问迭代次数 reduce处理时会跳过数组空值","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"https://justsso1.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"浏览器中的安全","slug":"浏览器-安全","date":"2020-06-16T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/06/17/浏览器-安全/","permalink":"https://justsso1.github.io/2020/06/17/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%AE%89%E5%85%A8/","excerpt":"","text":"浏览器中的安全浏览器中的安全分为三大块。Web网页安全，浏览器网络 安全和浏览系统安全。 安全策略：同源策略（Same-Origin policy）。如果两个url，协议相同、域名相同、端口相同，那么这两个url是同源的。浏览器认为两个相同的源之间是可以互相访问资源和操作dom的。两个不同的源之间想要访问资源或操作dom，那么会有一套安全机制制约，我们把这叫做同源策略。 同源策略会隔离不同源的DOM、，页面数据安全和网络通信，进而实现web页面的安全性。 页面中可以引用第三方资源，不过这也暴露了很多诸多XSS的安全问题，比如页面加载了一个恶意脚本，该脚本会窃取用户的cookie信息。为了解决XSS攻击，浏览器中增加了CSP（内容安全策略），CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器能够执行哪些内联JavaScript代码。 使用XMLHttpRequest和Fetch都是无法直接进行跨域请求的，因此浏览器在这种严格模式之上引入了CORS（跨域资源共享），让其可以安全的跨域。 两个不同的源的DOM是不能互相操作的，因此浏览器中出现了跨文档消息机制，让其可以比较安全的通信。 跨站脚本攻击(XSS)XSS(Cross Site Scripting)跨站脚本攻击，主要是网站加载了一些恶意脚本。恶意脚本会做以下恶事，窃取用户的cookie信息，监听用户行为，比如获取用户的输入信息；在页面生成广告。 恶意脚本是怎么被注入的: 存储型XSS 黑客将恶意脚本存储到正常服务器中，当用户请求到包含有恶意脚本的网页时，用户的浏览器就会执行恶意脚本，恶意脚本窃取用户cookie发送到黑客服务器 以喜马拉雅为例，黑客将一张专辑的名字命名为&lt;script src=&quot;aaa.com/b.js&quot;&gt;&lt;/script&gt;，服务器将这个名字存储到数据库了，然后普通用户看这个专辑时，浏览器就会请求恶意脚本，恶意脚本会读取用户的cookie，这样用户cookie被盗用，黑客可以冒用用户登录做一些恶事了。 反射型XSS 恶意脚本属于用户发送给服务器端请求的一部分，然后服务器端再将恶意脚本返回给浏览器端，当恶意JavaScript脚本在用户页面中被执行时，黑客就可以利用该恶意脚本做一些事情。比如一个不明链接，该链接的query中包含&lt;script&gt;alert(&quot;你被攻击了&quot;)&lt;/script&gt;，那么当用户不小心点了这个链接，发送到服务器，服务器收到请求后，又将恶意代码发送给了浏览器端，这样浏览器端就读取并执行了&lt;script&gt;alert(&quot;你被攻击了&quot;)&lt;/script&gt; 基于DOM的XSS 基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。 存储型XSS和反射性XSS是服务器的安全漏洞，基于DOM的XSS是浏览器的安全漏洞。不论哪种XSS，都是要先在浏览器中注入恶意脚本，然后通过恶意脚本再将用户信息发送到黑客服务器上。所以关键还是得浏览器端阻止恶意脚本的注入和恶意消息的发送。 基于XSS攻击，我们应该怎么防控呢？ 服务器对于输入脚本做过滤，转码 前端符合CSP规范 cookie 中有 HttpOnly属性，针对cookie 使用httponly，禁止JavaScript操作cookie。 说道CSP，要仔细聊聊具体要怎么做，才叫符合CSP规范呢？https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP CSRF攻击CSRF(Cross Site Request Forgerys)跨站请求伪造，关键的点有，目标服务器存在漏洞、用户登录过网站并有登录态、用户被诱导进入黑客网站并用用户的登录态发送了伪造请求 CSSRF攻击，主要是利用用户登录，请求服务器的漏洞接口，所以我们的主力放在用户登录态和服务器上做以下几点来防范： 从用户登录态着手，用户的登录态和cookie有着紧密的联系，如果我们让第三方网站读取不到用户的登录态，也就构不成危害操作了。cookie的Samesite可以做到禁止某些cookie发送。 Samesite 选项通常有Strict Lax none 三个值 1. Strict最严格，禁止第三方Cookie 2. Lax 宽松，第三方站点的get方式可以携带cookie，通过 img、iframe 等标签加载的 UR禁止第三方cookie 3. 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。 服务器检查发起请求的网站来源，通过http头的referer和origin 检查请求来源网站是不是可靠的，进行过滤.Origin只有域名，referer有域名和具体地址 服务器增加CSRF token，浏览器向服务器发起请求，服务器将csrf token注入到浏览器端，如果浏览器发送的请求不包含csrf token的话，那么服务器将验证token不合法，会拒绝请求。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://justsso1.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://justsso1.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Chrome开发者工具","slug":"浏览器-Chrome开发者工具","date":"2020-06-03T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/06/04/浏览器-Chrome开发者工具/","permalink":"https://justsso1.github.io/2020/06/04/%E6%B5%8F%E8%A7%88%E5%99%A8-Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/","excerpt":"","text":"Chrome开发者工具：利用网络面板做性能分析 渲染流水线：CSS如何影响首次加载时的白屏时间 如何系统地优化页面？ 虚拟dom 当页面dom节点很多时，js操作真实的dom会触发重排重绘合成等一系列操作，很影响页面性能。所以需要虚拟dom来做真实dom的缓存层，当页面有变化时，会比较前后两颗虚拟dom，找出真正需要变化的点，然后更新它，然后再更新真实的dom,这样可以减少不必要的渲染，提高性能。 两个虚拟dom的比较过程，在react中更新的机制叫做filber reconciler。以前用的是reconciler算法，reconciler算法使用递归比较，当虚拟dom比较复杂时，会带来问题，比较函数会占据主线程过久，导致其他任务等待，造成页面卡顿。所以react团队更新了reconciler算法，叫做filber reconciler，类似于“协程”，执行一段时间会出让主线程，不会占用主线程过久。 虚拟dom更新使用的算法是diff算法。 mvc mvvm","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://justsso1.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"开发者工具","slug":"开发者工具","permalink":"https://justsso1.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"事件循环机制[Node.js]篇","slug":"深入理解js事件循环机制[Node.js篇]","date":"2020-05-31T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/06/01/深入理解js事件循环机制[Node.js篇]/","permalink":"https://justsso1.github.io/2020/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6[Node.js%E7%AF%87]/","excerpt":"","text":"在浏览器篇已经对事件循环机制和一些相关的概念作了详细介绍，但主要是针对浏览器端的研究，Node环境是否也一样呢？先看一个demo： 123456789101112131415setTimeout(()=&gt;&#123; console.log(&#x27;timer1&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;) &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log(&#x27;timer2&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise2&#x27;) &#125;)&#125;, 0) 肉眼编译运行一下，蒽，在浏览器的结果就是下面这个了，道理都懂，就不累述了。 1234timer1promise1timer2promise2 那么Node下执行看看，咦。。。奇怪，跟浏览器的运行结果并不一样~ 1234timer1timer2promise1promise2 例子说明，浏览器和 Node.js 的事件循环机制是有区别的，一起来看个究竟吧~ Node.js的事件处理Node.js采用V8作为js的解析引擎，而I&#x2F;O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现，核心源码参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); // timers阶段 uv__run_timers(loop); // I/O callbacks阶段 ran_pending = uv__run_pending(loop); // idle阶段 uv__run_idle(loop); // prepare阶段 uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); // poll阶段 uv__io_poll(loop, timeout); // check阶段 uv__run_check(loop); // close callbacks阶段 uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; 根据Node.js官方介绍，每次事件循环都包含了6个阶段，对应到 libuv 源码中的实现，如下图所示 timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调 I&#x2F;O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调 idle, prepare 阶段：仅node内部使用 poll 阶段：获取新的I&#x2F;O事件, 适当的条件下node将阻塞在这里 check 阶段：执行 setImmediate() 的回调 close callbacks 阶段：执行 socket 的 close 事件回调 我们重点看timers、poll、check这3个阶段就好，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。 timers 阶段timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。 1234567setTimeout(() =&gt; &#123; console.log(&#x27;timeout&#x27;)&#125;, 0)setImmediate(() =&gt; &#123; console.log(&#x27;immediate&#x27;)&#125;) 但是把它们放到一个I&#x2F;O回调里面，就一定是 setImmediate() 先执行，因为poll阶段后面就是check阶段。 poll 阶段poll 阶段主要有2个功能： 处理 poll 队列的事件 当有已超时的 timer，执行它的回调函数 even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况： 若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列 若没有预设的setImmediate()，event loop将阻塞在该阶段等待 注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。 check 阶段setImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 小结 event loop 的每个阶段都有一个任务队列 当 event loop 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段 当所有阶段被顺序执行一次后，称 event loop 完成了一个 tick 讲得好有道理，可是没有demo我还是理解不全啊，憋急，now！ 1234567891011const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;test.txt&#x27;, () =&gt; &#123; console.log(&#x27;readFile&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;timeout&#x27;) &#125;, 0) setImmediate(() =&gt; &#123; console.log(&#x27;immediate&#x27;) &#125;)&#125;) 执行结果应该都没有疑问了 123readFileimmediatetimeout Node.js 与浏览器的 Event Loop 差异回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。 而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。 demo回顾回顾文章最开始的demo，全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行； 首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2； 至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。 对比浏览器端的处理过程： process.nextTick() VS setImmediate() In essence, the names should be swapped. process.nextTick() fires more immediately than setImmediate() 来自官方文档有意思的一句话，从语义角度看，setImmediate() 应该比 process.nextTick() 先执行才对，而事实相反，命名是历史原因也很难再变。 process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I&#x2F;O starving（饥饿）的问题，比如下面例子的readFile已经完成，但它的回调一直无法执行： 1234567891011121314151617181920const fs = require(&#x27;fs&#x27;)const starttime = Date.now()let endtimefs.readFile(&#x27;text.txt&#x27;, () =&gt; &#123; endtime = Date.now() console.log(&#x27;finish reading time: &#x27;, endtime - starttime)&#125;)let index = 0function handler () &#123; if (index++ &gt;= 1000) return console.log(`nextTick $&#123;index&#125;`) process.nextTick(handler) // console.log(`setImmediate $&#123;index&#125;`) // setImmediate(handler)&#125;handler() process.nextTick()的运行结果： 123456nextTick 1nextTick 2......nextTick 999nextTick 1000finish reading time: 170 替换成setImmediate()，运行结果： 123456setImmediate 1setImmediate 2finish reading time: 80......setImmediate 999setImmediate 1000 这是因为嵌套调用的 setImmediate() 回调，被排到了下一次event loop才执行，所以不会出现阻塞。 总结 Node.js 的事件循环分为6个阶段 浏览器和Node 环境下， 1microtask 任务队列的执行时机不同 Node.js中，microtask 在事件循环的各个阶段之间执行 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行 递归的调用process.nextTick()会导致I&#x2F;O starving，官方推荐使用setImmediate() [参考资料] event-loop-timers-and-nexttick Node.js Event Loop 的理解 Timers，process.nextTick() libuv&#x2F;core.c nodejs&#x2F;next_tick.js 深入理解js事件循环机制（浏览器篇）","categories":[],"tags":[]},{"title":"【转载】深入理解js事件循环机制[浏览器篇]","slug":"深入理解js事件循环机制[浏览器篇]","date":"2020-05-30T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/05/31/深入理解js事件循环机制[浏览器篇]/","permalink":"https://justsso1.github.io/2020/05/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6[%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87]/","excerpt":"","text":"深入理解js事件循环机制[浏览器篇]事件循环是JavaScript语言在处理多任务时的一种机制，由于JavaScript是单线程，所以当有异步任务发生时，需要一种机制来协调任务触发，避免等待太久，就好比交通规则一样。JavaScript解析引擎结合所在的宿主环境（本文讲浏览器何NodeJS）产生了各自的事件循环机制。抛开环境谈运行，和抛开计量谈毒性一样，所以一定要区分清楚是在哪里运行，在浏览器还是NodeJS。浏览器中的事件循环由H5规范约定、由各浏览器厂商实现；而NodeJS中的事件循环由libuv自己实现的。 Event Loop在浏览器下和Node js环境下各有一套规则。 众所周知，javascript是单线程语言。单线程是什么？单线程是指js引擎中负责解析执行js代码的线程只有一个（主线程）即每次只能做一件事。那单线程是怎么做到异步的呢？ js的任务分为 同步 和 异步 两种，它们的处理方式也不同，同步任务是直接在主线程上排队执行，异步任务则会被放到任务队列中，若有多个任务（异步任务）则要在任务队列中排队等待，任务队列类似一个缓冲区，任务下一步会被移到调用栈（call stack），然后主线程执行调用栈的任务。 单线程是指js引擎中负责解析执行js代码的线程只有一个（主线程），即每次只能做一件事，而我们知道一个ajax请求，主线程在等待它响应的同时是会去做其它事的，浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求的方式是异步的。 总而言之，检查调用栈是否为空，以及确定把哪个task加入调用栈的这个过程就是事件循环，而js实现异步的核心就是事件循环。 事件循环机制是为了处理异步操作的行为，所以这里是的[任务队列]是存储异步操作完成之后的回调函数的地方。 按异步操作的完成先后插入队列。 因此setTime(fn, 0)就会及时插入队列，但不会立即执行。 调用栈和任务队列顾名思义，调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。 下图就是调用栈和任务队列的关系图 事件循环关于事件循环，HTML规范的介绍 There must be at least one event loop per user agent, and at most one event loop per unit of related similar-origin browsing contexts.An event loop has one or more task queues.Each task is defined as coming from a specific task source. 从规范理解，浏览器至少有一个事件循环，一个事件循环至少有一个任务队列（macrotask），每个外任务都有自己的分组，浏览器会为不同的任务组设置优先级。 macrotask &amp; microtask规范有提到两个概念，但没有详细介绍，查阅一些资料大概可总结如下： macrotask：包含执行整体的js代码，事件回调，XHR回调，定时器（setTimeout&#x2F;setInterval&#x2F;setImmediate），IO操作，UI render microtask：更新应用程序状态的任务，包括promise回调，MutationObserver，process.nextTick，Object.observe 其中setImmediate和process.nextTick是nodejs的实现，在nodejs篇会详细介绍。 事件处理过程关于macrotask和microtask的理解，光这样看会有些晦涩难懂，结合事件循坏的机制理解清晰很多，下面这张图可以说是介绍得非常清楚了。 总结起来，一次事件循环的步骤包括： 检查macrotask队列是否为空，非空则到2，为空则到3 执行macrotask中的一个任务 继续检查microtask队列是否为空，若有则到4，否则到5 取出microtask中的任务执行，执行完成返回到步骤3 执行视图更新 mactotask &amp; microtask的执行顺序 读完这么多干巴巴的概念介绍，还不如看一段代码感受下 12345678910111213console.log(&#x27;start&#x27;)setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;)&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;end&#x27;) 打印台输出的log顺序是什么？结合上述的步骤分析，系不系so easy~ 首先，全局代码（main()）压入调用栈执行，打印start； 接下来setTimeout压入macrotask队列，promise.then回调放入microtask队列，最后执行console.log(‘end’)，打印出end； 至此，调用栈中的代码被执行完成，回顾macrotask的定义，我们知道全局代码属于macrotask，macrotask执行完，那接下来就是执行microtask队列的任务了，执行promise回调打印promise1； promise回调函数默认返回undefined，promise状态变为fullfill触发接下来的then回调，继续压入microtask队列，event loop会把当前的microtask队列一直执行完，此时执行第二个promise.then回调打印出promise2； 这时microtask队列已经为空，从上面的流程图可以知道，接下来主线程会去做一些UI渲染工作（不一定会做），然后开始下一轮event loop，执行setTimeout的回调，打印出setTimeout； 这个过程会不断重复，也就是所谓的事件循环。 视图渲染的时机回顾上面的事件循环示意图，update rendering（视图渲染）发生在本轮事件循环的microtask队列被执行完之后，也就是说执行任务的耗时会影响视图渲染的时机。通常浏览器以每秒60帧（60fps）的速率刷新页面，据说这个帧率最适合人眼交互，大概16.7ms渲染一帧，所以如果要让用户觉得顺畅，单个macrotask及它相关的所有microtask最好能在16.7ms内完成。 但也不是每轮事件循环都会执行视图更新，浏览器有自己的优化策略，例如把几次的视图更新累积到一起重绘，重绘之前会通知requestAnimationFrame执行回调函数，也就是说requestAnimationFrame回调的执行时机是在一次或多次事件循环的UI render阶段。 以下代码可以验证 1234567891011121314151617setTimeout(function() &#123;console.log(&#x27;timer1&#x27;)&#125;, 0)requestAnimationFrame(function()&#123; console.log(&#x27;requestAnimationFrame&#x27;)&#125;)setTimeout(function() &#123;console.log(&#x27;timer2&#x27;)&#125;, 0)new Promise(function executor(resolve) &#123; console.log(&#x27;promise 1&#x27;) resolve() console.log(&#x27;promise 2&#x27;)&#125;).then(function() &#123; console.log(&#x27;promise then&#x27;)&#125;)console.log(&#x27;end&#x27;) 运行结果截图如下: 可以看到，结果1中requestAnimationFrame()是在一次事件循环后执行，而在结果2，它的执行则是在三次事件循环结束后。 总结 事件循环是js实现异步的核心 每轮事件循环分为3个步骤： a) 执行macrotask队列的一个任务b) 执行完当前microtask队列的所有任务c) UI render 浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定 [参考资料] event-loops sec-jobs-and-job-queues Promises&#x2F;A+ Tasks, microtasks, queues and schedules HTML系列：macrotask和microtask http://www.ruanyifeng.com/blog/2014/10/event-loop.html","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[{"name":"事件循环","slug":"事件循环","permalink":"https://justsso1.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"}]},{"title":"Koa2的中间件原理","slug":"Koa2中间件原理","date":"2020-05-28T16:00:00.000Z","updated":"2024-10-12T08:40:56.538Z","comments":true,"path":"2020/05/29/Koa2中间件原理/","permalink":"https://justsso1.github.io/2020/05/29/Koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/","excerpt":"","text":"koa2中间价的理论模型是洋葱模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556async function fn1(next) &#123; console.log(&#x27;fn1 &#x27;) next &amp;&amp; await next() console.log(&#x27;fn1 end&#x27;)&#125;async function fn2(next) &#123; console.log(&#x27;fn2&#x27;) next &amp;&amp; await next() console.log(&#x27;fn2 end&#x27;)&#125;async function fn3(next) &#123; console.log(&#x27;fn3&#x27;) next &amp;&amp; await next() console.log(&#x27;fn3 end&#x27;)&#125;let middleware = [fn1, fn2, fn3]//中间件的第二个参数都是next，且是一个函数，函数要返回要传递的函数，这样才不能在第二层传递时执行。 还有函数类型要是一个promise，才可以被await；所以使用了Promise.resolve()function compose2(middleware) &#123; return function () &#123; h(0) function h(index) &#123; let fn = middleware[index] if (!fn) &#123; return Promise.resolve() &#125; // return fn(function next() &#123; // return Promise.resolve(h(index + 1)) // &#125;) return Promise.resolve( fn(function next()&#123; return h(index+1) &#125;) ) &#125; &#125;&#125;let finalFn = compose2(middleware)finalFn()/*希望打印fn1fn2fn3fn3 endfn2 endfn1 end */","categories":[],"tags":[{"name":"koa2中间件","slug":"koa2中间件","permalink":"https://justsso1.github.io/tags/koa2%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"用npm script打造超溜的前端工作流2","slug":"用npm script打造超溜的前端工作流2","date":"2020-05-13T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/05/14/用npm script打造超溜的前端工作流2/","permalink":"https://justsso1.github.io/2020/05/14/%E7%94%A8npm%20script%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%812/","excerpt":"","text":"^版本号： 会匹配到主版本号（第一位数字）中最新的版本。例如： ^3.4.1 会匹配到3.x.x的最新版本，不会匹配到4.0.0~版本号：会匹配到第二位数字中最新的版本。例如： ～1.15.2会匹配到 1.15.x的最新版本，不会匹配到1.16.0","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://justsso1.github.io/tags/npm/"}]},{"title":"用npm script打造超溜的前端工作流1","slug":"用npm script 打造超溜的前端工作流1","date":"2020-05-12T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/05/13/用npm script 打造超溜的前端工作流1/","permalink":"https://justsso1.github.io/2020/05/13/%E7%94%A8npm%20script%20%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%811/","excerpt":"","text":"1.1 初识 npm script首先介绍创建 package.json 文件的科学方法，目标是掌握 npm init 命令。然后，通过在终端中运行自动生成的 test 命令，详细讲解 npm 脚本基本执行流程。 然后，动手给项目增加 eslint 命令，熟悉创建自定义命令的基本流程。 用 npm init 快速创建项目开始探索 npm script 之前，我们先聊聊这些 scripts 所依赖的文件 package.json，以它为基础的 npm 则是 node.js 社区蓬勃发展的顶梁柱。 npm 为我们提供了快速创建 package.json 文件的命令 npm init，执行该命令会问几个基本问题，如包名称、版本号、作者信息、入口文件、仓库地址、许可协议等，多数问题已经提供了默认值，你可以在问题后敲回车接受默认值： 12345678package name: (hello-npm-script)version: (0.1.0)description: hello npm scriptentry point: (index.js)test command:git repository:keywords: npm, scriptlicense: (MIT) 上面的例子指定了描述（description）和关键字（keywords）两个字段，基本问题问完之后 npm 会把 package.json 文件内容打出来供你确认： 123456789101112131415&#123; &quot;name&quot;: &quot;hello-npm-script&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;hello npm script&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ &quot;npm&quot;, &quot;script&quot; ], &quot;author&quot;: &quot;wangshijun &lt;wangshijun2010@gmail.com&gt; (https://github.com/wangshijun)&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 按回车确认就能把package.json 的内容写到文件系统，如果要修改 package.json，可以直接用编辑器编辑，或者再次运行 npm init，npm 默认不会覆盖修改里面已经存在的信息。 TIP#1: 嫌上面的初始化方式太啰嗦？你可以使用 npm init -f（意指 –force，或者使用 –yes）告诉 npm 直接跳过参数问答环节，快速生成 package.json。 初始化 package.json 时的字段默认值是可以自己配置的，细心的同学可能已经发现，我上面的默认版本号是 0.1.0，而 npm 默认的版本号是 0.0.1，可以用下面的命令去修改默认配置： 12345npm config set init.author.email &quot;wangshijun2010@gmail.com&quot;npm config set init.author.name &quot;wangshijun&quot;npm config set init.author.url &quot;http://github.com/wangshijun&quot;npm config set init.license &quot;MIT&quot;npm config set init.version &quot;0.1.0&quot; TIP#2: 将默认配置和 -f 参数结合使用，能让你用最短的时间创建 package.json，快去自己试试吧。 严肃的工程师都会使用 Git 对源代码进行版本管理，在 npm init 的基础上，你可以使用 git init 来初始化 git 仓库，不再展开。 纸上得来终觉浅，想掌握 npm script，请打开终端，执行下列命令： 1234cd ~mkdir hello-npm-script &amp;&amp; cd $_npm initnpm init -f 用 npm run 执行任意命令npm 是如何管理和执行各种 scripts 的呢？作为 npm 内置的核心功能之一，npm run 实际上是 npm run-script 命令的简写。当我们运行 npm run xxx 时，基本步骤如下： 从 package.json 文件中读取 scripts 对象里面的全部配置； 以传给 npm run 的第一个参数作为键，本例中为 xxx，在 scripts 对象里面获取对应的值作为接下来要执行的命令，如果没找到直接报错； 在系统默认的 shell 中执行上述命令，系统默认 shell 通常是 bash，windows 环境下可能略有不同，稍后再讲。 注意，上面这是简化的流程，更复杂的钩子机制后面章节单独介绍。 举例来说，如果 package.json 文件内容如下： 123456789&#123; &quot;name&quot;: &quot;hello-npm-script&quot;, &quot;devDependencies&quot;: &#123; &quot;eslint&quot;: &quot;latest&quot; &#125;, &quot;scripts&quot;: &#123; &quot;eslint&quot;: &quot;eslint **.js&quot; &#125;&#125; 如果不带任何参数执行 npm run，它会列出可执行的所有命令，比如下面这样： 123Available scripts in the myproject package: eslint eslint **.js 如果运行 npm run eslint，npm 会在 shell 中运行 eslint **.js。 有没有好奇过上面的 eslint 命令是从哪里来的？其实，npm 在执行指定 script 之前会把 node_modules&#x2F;.bin 加到环境变量 $PATH 的前面，这意味着任何内含可执行文件的 npm 依赖都可以在 npm script 中直接调用，换句话说，你不需要在 npm script 中加上可执行文件的完整路径，比如 .&#x2F;node_modules&#x2F;.bin&#x2F;eslint **.js。 创建自定义 npm script知道如何运行 npm script 之后，接下来我们在 hello-npm-script 项目中添加有实际用途的 eslint 脚本，eslint 是社区中接受度比较高的 javascript 风格检查工具，有大把现成的规则集可供你选择，比如 google、 airbnb。 在新项目或者任何现有项目中添加 eslint 自定义脚本的步骤如下： 准备被检查的代码 要做代码检查，我们必须有代码，创建 index.js 文件，输入如下内容： 12345const str = &#x27;some value&#x27;;function fn()&#123; console.log(&#x27;some log&#x27;);&#125; 添加 eslint 依赖 执行如下命令将 eslint 添加为 devDependencies： 1npm install eslint -D 初始化 eslint 配置用 eslint 做检查需要配置规则集，存放规则集的文件就是配置文件，使用如下文件生成配置文件： 1./node_modules/.bin/eslint --init TIP#3: 把 eslint 安装为项目依赖而非全局命令，项目可移植性更高。 在命令行提示中选择 Answer questions about your style，如下图回答几个问题，答案可以根据自己的偏好： 回车后根目录下就有了 .eslintrc.js 配置文件： 12345678910111213module.exports = &#123; env: &#123; es6: true, node: true, &#125;, extends: &#x27;eslint:recommended&#x27;, rules: &#123; indent: [&#x27;error&#x27;, 4], &#x27;linebreak-style&#x27;: [&#x27;error&#x27;, &#x27;unix&#x27;], quotes: [&#x27;error&#x27;, &#x27;single&#x27;], semi: [&#x27;error&#x27;, &#x27;always&#x27;], &#125;,&#125;; 添加 eslint 命令在 package.json 的 scripts 字段中新增命令 eslint： 123456&#123; &quot;scripts&quot;: &#123; &quot;eslint&quot;: &quot;eslint *.js&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;,&#125; 手动修改 package.json 时一定要注意语法正确。 运行 eslint 命令 执行 npm run eslint，可以看到，按照官方推荐规则代码里有 3 处不符合规范的地方： 20171205 增补：eslint 完成 react、vue.js 代码的检查如果需要结合 eslint 检查主流前端框架 react、vue.js，下面提供两条线索，因为官方仓库的 README 就可以作为入门文档，仔细读读相信绝大多数同学都能配置好。 使用 eslint-plugin-react 检查 react 代码，使用 react-plugin-react-native 检查 react-native 代码，如果你比较懒，可以直接使用 eslint-config-airbnb，里面内置了 eslint-plugin-react，新人常遇到 peerDependencies 安装失败问题可参照 npmjs 主页上的如下方法解决： 1234( export PKG=eslint-config-airbnb; npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &#x27;s/[\\&#123;\\&#125;,]//g ; s/: /@/g&#x27; | xargs npm install --save-dev &quot;$PKG@latest&quot;) 推荐使用 vue.js 官方的 eslint 插件：eslint-plugin-vue 来检查 vue.js 代码，具体的配置方法官方 README 写的清晰明了，这里就不赘述了。 上面的几种 eslint 规则集的官方仓库都列出了各自支持的规则，如果你需要关闭某些规则，可以直接在自己的 .eslintrc* 里面的 rules 中配置，比如我们仓库里面的： 12345678910111213module.exports = &#123; env: &#123; es6: true, node: true, &#125;, extends: &#x27;eslint:recommended&#x27;, rules: &#123; indent: [&#x27;error&#x27;, 2], &#x27;linebreak-style&#x27;: [&#x27;error&#x27;, &#x27;unix&#x27;], quotes: [&#x27;error&#x27;, &#x27;single&#x27;], semi: [&#x27;error&#x27;, &#x27;always&#x27;], &#125;,&#125;; 20171205 增补：eslint 完成 react、vue.js 代码的检查如果需要结合 eslint 检查主流前端框架 react、vue.js，下面提供两条线索，因为官方仓库的 README 就可以作为入门文档，仔细读读相信绝大多数同学都能配置好。 使用 eslint-plugin-react 检查 react 代码，使用 react-plugin-react-native 检查 react-native 代码，如果你比较懒，可以直接使用 eslint-config-airbnb，里面内置了 eslint-plugin-react，新人常遇到 peerDependencies 安装失败问题可参照 npmjs 主页上的如下方法解决： 1234( export PKG=eslint-config-airbnb; npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &#x27;s/[\\&#123;\\&#125;,]//g ; s/: /@/g&#x27; | xargs npm install --save-dev &quot;$PKG@latest&quot;) 推荐使用 vue.js 官方的 eslint 插件：eslint-plugin-vue 来检查 vue.js 代码，具体的配置方法官方 README 写的清晰明了，这里就不赘述了。 上面的几种 eslint 规则集的官方仓库都列出了各自支持的规则，如果你需要关闭某些规则，可以直接在自己的 .eslintrc* 里面的 rules 中配置，比如我们仓库里面的： 12345678910111213module.exports = &#123; env: &#123; es6: true, node: true, &#125;, extends: &#x27;eslint:recommended&#x27;, rules: &#123; indent: [&#x27;error&#x27;, 2], &#x27;linebreak-style&#x27;: [&#x27;error&#x27;, &#x27;unix&#x27;], quotes: [&#x27;error&#x27;, &#x27;single&#x27;], semi: [&#x27;error&#x27;, &#x27;always&#x27;], &#125;,&#125;; 1.2 运行多个 npm script 的各种姿势前端项目通常会包括多个 npm script，对多个命令进行编排是很自然的需求，有时候需要将多个命令串行，即脚本遵循严格的执行顺序；有时候则需要让它们并行来提高速度，比如不相互阻塞的 npm script。社区中也有比 npm 内置的多命令运行机制更好用的解决方案：npm-run-all。 哪来那么多命令？通常来说，前端项目会包含 js、css、less、scss、json、markdown 等格式的文件，为保障代码质量，给不同的代码添加检查是很有必要的，代码检查不仅保障代码没有低级的语法错误，还可确保代码都遵守社区的最佳实践和一致的编码风格，在团队协作中尤其有用，即使是个人项目，加上代码检查，也会提高你的效率和质量。 我通常会给前端项目加上下面 4 种代码检查： eslint，可定制的 js 代码检查，1.1 中有详细的配置步骤； stylelint，可定制的样式文件检查，支持 css、less、scss； jsonlint，json 文件语法检查，踩过坑的同学会清楚，json 文件语法错误会知道导致各种失败； markdownlint-cli，Markdown 文件最佳实践检查，个人偏好；需要注意的是，html 代码也应该检查，但是工具支持薄弱，就略过不表。此外，为代码添加必要的单元测试也是质量保障的重要手段，常用的单测技术栈是： mocha，测试用例组织，测试用例运行和结果收集的框架； chai，测试断言库，必要的时候可以结合 sinon 使用；TIP#4：测试工具如 tap、ava 也都提供了命令行接口，能很好的集成到 npm script 中，原理是相通的。 包含了基本的代码检查、单元测试命令的 package.json 如下： 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;hello-npm-script&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;lint:js&quot;: &quot;eslint *.js&quot;, &quot;lint:css&quot;: &quot;stylelint *.less&quot;, &quot;lint:json&quot;: &quot;jsonlint --quiet *.json&quot;, &quot;lint:markdown&quot;: &quot;markdownlint --config .markdownlint.json *.md&quot;, &quot;test&quot;: &quot;mocha tests/&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;chai&quot;: &quot;^4.1.2&quot;, &quot;eslint&quot;: &quot;^4.11.0&quot;, &quot;jsonlint&quot;: &quot;^1.6.2&quot;, &quot;markdownlint-cli&quot;: &quot;^0.5.0&quot;, &quot;mocha&quot;: &quot;^4.0.1&quot;, &quot;stylelint&quot;: &quot;^8.2.0&quot;, &quot;stylelint-config-standard&quot;: &quot;^17.0.0&quot; &#125;&#125; 让多个 npm script 串行？在我们运行测试之前确保我们的代码都通过代码检查会是比较不错的实践，这也是让多个 npm script 串行的典型用例，实现方式也比较简单，只需要用 &amp;&amp; 符号把多条 npm script 按先后顺序串起来即可，具体到我们的项目，修改如下图所示： 12345678diff --git a/package.json b/package.jsonindex c904250..023d71e 100644--- a/package.json+++ b/package.json@@ -8,7 +8,7 @@- &quot;test&quot;: &quot;mocha tests/&quot;+ &quot;test&quot;: &quot;npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown &amp;&amp; mocha tests/&quot; &#125;, 然后直接执行 npm test 或 npm t，从输出可以看到子命令的执行顺序是严格按照我们在 scripts 中声明的先后顺序来的： 1eslint ==&gt; stylelint ==&gt; jsonlint ==&gt; markdownlint ==&gt; mocha 需要注意的是，串行执行的时候如果前序命令失败（通常进程退出码非0），后续全部命令都会终止，我们可以尝试在 index.js 中引入错误（删掉行末的分号）： 123456789101112diff --git a/index.js b/index.jsindex ab8bd0e..b817ea4 100644--- a/index.js+++ b/index.js@@ -4,7 +4,7 @@ const add = (a, b) =&gt; &#123; &#125; return NaN;-&#125;;+&#125; module.exports = &#123; add &#125;; 然后重新运行 npm t，结果如下，npm run lint:js 失败之后，后续命令都没有执行： 让多个 npm script 并行？在严格串行的情况下，我们必须要确保代码中没有编码规范问题才能运行测试，在某些时候可能并不是我们想要的，因为我们真正需要的是，代码变更时同时给出测试结果和测试运行结果。这就需要把子命令的运行从串行改成并行，实现方式更简单，把连接多条命令的 &amp;&amp; 符号替换成 &amp; 即可。 代码变更如下： 12345678diff --git a/package.json b/package.jsonindex 023d71e..2d9bd6f 100644--- a/package.json+++ b/package.json@@ -8,7 +8,7 @@- &quot;test&quot;: &quot;npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown &amp;&amp; mocha tests/&quot;+ &quot;test&quot;: &quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/&quot; &#125;, 重新运行 npm t，我们得到如下结果： 细心的同学可能已经发现上图中哪里不对，npm run lint:js 的结果在进程退出之后才输出，如果你自己运行，不一定能稳定复现这个问题，但 npm 内置支持的多条命令并行跟 js 里面同时发起多个异步请求非常类似，它只负责触发多条命令，而不管结果的收集，如果并行的命令执行时间差异非常大，上面的问题就会稳定复现。怎么解决这个问题呢？ 答案也很简单，在命令的增加 &amp; wait 即可，这样我们的 test 命令长这样： 1npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/ &amp; wait 加上 wait 的额外好处是，如果我们在任何子命令中启动了长时间运行的进程，比如启用了 mocha 的 –watch 配置，可以使用 ctrl + c 来结束进程，如果没加的话，你就没办法直接结束启动到后台的进程。 有没有更好的管理方式？有强迫症的同学可能会觉得像上面这样用原生方式来运行多条命令很臃肿，幸运的是，我们可以使用 npm-run-all 实现更轻量和简洁的多命令运行。 用如下命令将 npm-run-all 添加到项目依赖中： 12npm i npm-run-all -D然后修改 package.json 实现多命令的串行执行： 123456789diff --git a/package.json b/package.jsonindex b3b1272..83974d6 100644--- a/package.json+++ b/package.json@@ -8,7 +8,8 @@- &quot;test&quot;: &quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/ &amp; wait&quot;+ &quot;mocha&quot;: &quot;mocha tests/&quot;,+ &quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown mocha&quot; &#125;, npm-run-all 还支持通配符匹配分组的 npm script，上面的脚本可以进一步简化成： 12345678diff --git a/package.json b/package.jsonindex 83974d6..7b327cd 100644--- a/package.json+++ b/package.json@@ -9,7 +9,7 @@- &quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown mocha&quot;+ &quot;test&quot;: &quot;npm-run-all lint:* mocha&quot; &#125;, 如何让多个 npm script 并行执行？也很简单： 12345678diff --git a/package.json b/package.jsonindex 7b327cd..c32da1c 100644--- a/package.json+++ b/package.json@@ -9,7 +9,7 @@- &quot;test&quot;: &quot;npm-run-all lint:* mocha&quot;+ &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot; &#125;, 并行执行的时候，我们并不需要在后面增加 &amp; wait，因为 npm-run-all 已经帮我们做了。 TIP#5：npm-run-all 还提供了很多配置项支持更复杂的命令编排，比如多个命令并行之后接串行的命令，感兴趣的同学请阅读文档，自己玩儿。 1.3 给 npm script 传递参数和添加注释本小节会介绍 3 个知识点：给 npm script 传递参数以减少重复的 npm script；增加注释提高 npm script 脚本的可读性；控制运行时日志输出能让你专注在重要信息上。 给 npm script 传递参数eslint 内置了代码风格自动修复模式，只需给它传入 –fix 参数即可，在 scripts 中声明检查代码命令的同时你可能也需要声明修复代码的命令，面对这种需求，大多数同学可能会忍不住复制粘贴，如下： 1234567diff --git a/package.json b/package.jsonindex c32da1c..b6fb03e 100644--- a/package.json+++ b/package.json@@ -5,6 +5,7 @@ &quot;lint:js&quot;: &quot;eslint *.js&quot;,+ &quot;lint:js:fix&quot;: &quot;eslint *.js --fix&quot;, 在 lint:js 命令比较短的时候复制粘贴的方法简单粗暴有效，但是当 lint:js 命令变的很长之后，难免后续会有人改了 lint:js 而忘记修改 lint:js:fix（别问我为啥，我就是踩着坑过来的），更健壮的做法是，在运行 npm script 时给定额外的参数，代码修改如下： 123456diff --git a/package.json b/package.json--- a/package.json+++ b/package.json@@ -5,6 +5,7 @@ &quot;lint:js&quot;: &quot;eslint *.js&quot;,+ &quot;lint:js:fix&quot;: &quot;npm run lint:js -- --fix&quot;, 要格外注意 –fix 参数前面的 – 分隔符，意指要给 npm run lint:js 实际指向的命令传递额外的参数。 运行效果如下图：上图第2个红色框里面是实际执行的命令，可以看到 –fix 参数附加在了后面。 TIP#6：如果你不想单独声明 lint:js:fix 命令，在需要的时候直接运行： npm run lint:js – –fix 来实现同样的效果。 问题来了，如果我想为 mocha 命令增加 –watch 模式方便在开发时立即看到测试结果，该怎么做呢？相信读到这里你心中已经有了答案。 :stuck_out_tongue: 给 npm script 添加注释如果 package.json 中的 scripts 越来越多，或者出现复杂的编排命令，你可能需要给它们添加注释以保障代码可读性，但 json 天然是不支持添加注释的，下面是 2 种比较 trick 的方式。 第一种方式是，package.json 中可以增加 &#x2F;&#x2F; 为键的值，注释就可以写在对应的值里面，npm 会忽略这种键，比如，我们想要给 test 命令添加注释，按如下方式添加： 123456diff --git a/package.json b/package.json--- a/package.json+++ b/package.json@@ -10,6 +10,7 @@+ &quot;//&quot;: &quot;运行所有代码检查和单元测试&quot;, &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot; 这种方式的明显不足是，npm run 列出来的命令列表不能把注释和实际命令对应上，如果你声明了多个，npm run 只会列出最后那个，如下图：另外一种方式是直接在 script 声明中做手脚，因为命令的本质是 shell 命令（适用于 linux 平台），我们可以在命令前面加上注释，具体做法如下： 1234567diff --git a/package.json b/package.json--- a/package.json+++ b/package.json@@ -10,8 +10,7 @@- &quot;//&quot;: &quot;运行所有代码检查和单元测试&quot;,- &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot;+ &quot;test&quot;: &quot;# 运行所有代码检查和单元测试 \\n npm-run-all --parallel lint:* mocha&quot; 注意注释后面的换行符 \\n 和多余的空格，换行符是用于将注释和命令分隔开，这样命令就相当于微型的 shell 脚本，多余的空格是为了控制缩进，也可以用制表符 \\t 替代。这种做法能让 npm run 列出来的命令更美观，但是 scripts 声明阅读起来不那么整齐美观。 上面两种方式都有明显的缺陷，个人建议的更优方案还是把复杂的命令剥离到单独的文件中管理，在单独的文件中可以自由给它添加注释，详见后续章节。 调整 npm script 运行时日志输出在运行 npm script 出现问题时你需要有能力去调试它，某些情况下你需要让 npm script 以静默的方式运行，这类需求可通过控制运行时日志输出级别来实现。 日志级别控制参数有好几个，简单举例如下： 默认日志输出级别即不加任何日志控制参数得到的输出，可能是你最常用的，能看到执行的命令、命令执行的结果。 显示尽可能少的有用信息结合其他工具调用 npm script 的时候比较有用，需要使用 –loglevel silent，或者 –silent，或者更简单的 -s 来控制，这个日志级别的输出实例如下（只有命令本身的输出，读起来非常的简洁）： 如果执行各种 lint script 的时候启用了 -s 配置，代码都符合规范的话，你不会看到任何输出，这就是没有消息是最好的消息的由来，哈哈！ npm7npm显示尽可能多的运行时状态排查脚本问题的时候比较有用，需要使用 –loglevel verbose，或者 –verbose，或者更简单的 -d 来控制，这个日志级别的输出实例如下（详细打印出了每个步骤的参数、返回值，下面的截图只是部分）：","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://justsso1.github.io/tags/npm/"}]},{"title":"前端异常","slug":"前端-前端异常","date":"2020-05-10T16:00:00.000Z","updated":"2024-10-16T04:06:40.993Z","comments":true,"path":"2020/05/11/前端-前端异常/","permalink":"https://justsso1.github.io/2020/05/11/%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8/","excerpt":"","text":"做好前端异常，才能安心的放假啊 一、为什么要处理异常？异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。增强用户体验；远程定位问题；未雨绸缪，及早发现问题；无法复线问题，尤其是移动端，机型，系统都是问题；完善的前端方案，前端监控系统；对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。异常是不可控的，因此做好前端异常的处理异常重要。 二、需要处理哪些异常？前端要处理的异常分类： js 语法错误、代码异常 ajax请求异常 静态资源加载异常 Promise异常 Iframe异常 跨域script error 崩溃和卡顿 三、Try-Catch 的误区Try Catch只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。 123456try &#123; let name = &#x27;123&#x27; console.log(nam)&#125;catch (e) &#123; console.log(&#x27;捕获到异常&#x27;, e)&#125; 输出： 1捕获到异常 ReferenceError: nam is not defined try catch 捕获不到异步的异常 九、iframe 异常对于 iframe 的异常捕获，我们还得借力 window.onerror： 1234window.onerror = function(message, source, lineno, colno, error) &#123; console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125; 一个简单的例子可能如下： 1234567&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;script&gt; window.frames[0].onerror = function (message, source, lineno, colno, error) &#123; console.log(&#x27;捕获到 iframe 异常：&#x27;,&#123;message, source, lineno, colno, error&#125;); return true; &#125;;&lt;/script&gt; 十、Script error一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。 或者动态去添加 js 脚本： 1234const script = document.createElement(‘script’);script.crossOrigin = ‘anonymous’;script.src = url;document.body.appendChild(script); 特别注意，服务器端需要设置：Access-Control-Allow-Origin此外，我们也可以试试这个-解决 Script Error 的另类思路： 12345678910111213const originAddEventListener = EventTarget.prototype.addEventListener;EventTarget.prototype.addEventListener = function (type, listener, options) &#123; const wrappedListener = function (...args) &#123; try &#123; return listener.apply(this, args); &#125; catch (err) &#123; throw err; &#125; &#125; return originAddEventListener.call(this, type, wrappedListener, options);&#125; 简单解释一下：改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果： 12345678910111213141516171819(() =&gt; &#123; const originAddEventListener = EventTarget.prototype.addEventListener; EventTarget.prototype.addEventListener = function (type, listener, options) &#123;+ // 捕获添加事件时的堆栈+ const addStack = newError(`Event ($&#123;type&#125;)`).stack; const wrappedListener = function (...args) &#123; try &#123; return listener.apply(this, args); &#125; catch (err) &#123;+ // 异常发生时，扩展堆栈+ err.stack += &#x27;\\n&#x27; + addStack; throw err; &#125; &#125; return originAddEventListener.call(this, type, wrappedListener, options); &#125; &#125;)(); 十一、崩溃和卡顿卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。 12345678910111213141516171819window.addEventListener(&#x27;load&#x27;, function () &#123; sessionStorage.setItem(&#x27;good_exit&#x27;, &#x27;pending&#x27;); setInterval(function () &#123; sessionStorage.setItem(&#x27;time_before_crash&#x27;, newDate().toString()); &#125;, 1000); &#125;); window.addEventListener(&#x27;beforeunload&#x27;, function () &#123; sessionStorage.setItem(&#x27;good_exit&#x27;, &#x27;true&#x27;); &#125;); if(sessionStorage.getItem(&#x27;good_exit&#x27;) &amp;&amp; sessionStorage.getItem(&#x27;good_exit&#x27;) !== &#x27;true&#x27;) &#123; /* insert crash logging code here */ alert(&#x27;Hey, welcome back from your crash, looks like you crashed on: &#x27; + sessionStorage.getItem(&#x27;time_before_crash&#x27;)); &#125; 基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。 十二、错误上报1.通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。2.动态创建 img 标签的形式 1234function report(error) &#123;let reportUrl = ‘http://jartto.wang/report&#x27;;new Image().src = $&#123;reportUrl&#125;?logs=$&#123;error&#125;;&#125; 收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力： 123456Reporter.send = function(data) &#123;// 只采集 30%if(Math.random() &lt; 0.3) &#123;send(data) // 上报错误信息&#125;&#125; 采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。 十三、总结回到我们开头提出的那个问题，如何优雅的处理异常呢？可疑区域增加 Try-Catch全局监控 JS 异常 window.onerror全局监控静态资源异常 window.addEventListener捕获没有 Catch 的 Promise 异常：unhandledrejectionVUE errorHandler 和 React componentDidCatch监控网页崩溃：window 对象的 load 和 beforeunload跨域 crossOrigin 解决其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。 十四、参考Logging Information on Browser Crashes http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/前端代码异常监控实战 https://github.com/happylindz/blog/issues/5Error Boundaries https://blog.csdn.net/a986597353/article/details/78469979前端监控知识点 https://github.com/RicardoCao-Biker/Front-End-Monitoring/blob/master/BasicKnowledge.mdCapture and report JavaScript errors with window.onerror https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"异常","slug":"异常","permalink":"https://justsso1.github.io/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"块级作用：var缺陷以及为什么要引入let和const","slug":"浏览器-块级作用域：var缺陷以及为什么要引入let和const","date":"2020-05-10T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/05/11/浏览器-块级作用域：var缺陷以及为什么要引入let和const/","permalink":"https://justsso1.github.io/2020/05/11/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9Avar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5let%E5%92%8Cconst/","excerpt":"","text":"服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"爬虫所用到的知识","slug":"爬虫所用到的知识","date":"2020-05-10T16:00:00.000Z","updated":"2024-10-16T04:06:39.453Z","comments":true,"path":"2020/05/11/爬虫所用到的知识/","permalink":"https://justsso1.github.io/2020/05/11/%E7%88%AC%E8%99%AB%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86/","excerpt":"","text":"node爬虫爬虫要遵守Robots协议，也就是爬虫协议，爬虫程序在爬取网站数据之前，会先看看是否存在robots.txt文件，假如有，会在这个文件允许的范围内进行爬取。像百度、谷歌都是遵循这一协议的。 根据我的经验，爬虫会有一下几种类型： 爬网页用到的模块request网络请求网页，cheerio类似于jQuery的语法解析网页。 12345678910111213141516171819202122const cheerio = require(&#x27;cheerio&#x27;);const request = require(&#x27;request&#x27;)async function getWordFromIciBa(english) &#123; return new Promise((resolve, reject) =&gt; &#123; request.get(`https://www.iciba.com/$&#123;english&#125;`, (err, response, body) =&gt; &#123; if (!err &amp;&amp; response.statusCode === 200) &#123; const $ = cheerio.load(body.toString()) let yinbiao = $(&#x27;div.base-speak&gt;span:nth-child(2)&#x27;).text().replace(/\\s/g, &#x27;&#x27;).slice(1) //美式音标 let chinese = $(&#x27;ul.switch_part li&#x27;).text().replace(/\\s/g, &#x27;&#x27;) //中文释义 resolve(&#123; us_phonetic: yinbiao, chinese: chinese &#125;) &#125; else &#123; reject(err) &#125; &#125;) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125; 模拟登录用到的模块superagent，需要登录时，在请求头中添加cookie。例子：爬取qq空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445const superagent = require(&#x27;superagent&#x27;)let url = &#x27;https://user.qzone.qq.com/proxy/domain/taotao.qq.com/cgi-bin/emotion_cgi_msglist_v6&#x27;let pos = 20;let num = 40;let fun1 = &#x27;_preloadCallback&#x27;let func2 = &#x27;_preloadCallback&#x27;async function fix() &#123; try &#123; let res = await superagent.get(url).set(&#x27;cookie&#x27;, &#x27;528226249_todaycount=0; 528226249_totalcount=29294; pgv_pvi=5218883584; pgv_si=s8073185280; qz_screen=1440x900; pgv_pvid=7967706718; pgv_info=ssid=s5682998744; QZ_FE_WEBP_SUPPORT=1; cpu_performance_v8=1; RK=oPRBCnNXSR; ptcz=fb06e745fbe330fe99a3447722d205f58030819c78f46a2e842af1b1d423faed; __Q_w_s_hat_seed=1; __Q_w_s__QZN_TodoMsgCnt=1; Loading=Yes; ptui_loginuin=528226249@qq.com; uin=o0528226249; skey=@TaX0jGEVu; p_uin=o0528226249; pt4_token=1o3CiF3KorxeXMslISpIWHSkWu6wYMVGXfrSCs6aJHM_; p_skey=a1MbdGhwOcH7Ax2IE1Ixy-N4kuO6G-khvzM1nx4u*Bo_&#x27;) .query(&#123; uin: 528226249, ftype: 0, sort: 0, pos: pos, num: num, replynum: 100, g_tk: 846558423, callback: &#x27;_preloadCallback&#x27;, code_version: 1, format: &#x27;jsonp&#x27;, need_private_comment: 1, qzonetoken: &#x27;656e856329ef0609bdae4fceadd676c8312e4371446fdd95f3f3e8cbe482db5a6c0941fadacf72&#x27;, &#125;) ; let text = res.res.text; console.log(text) text = text.slice(17) text = text.slice(0, -2) const obj = JSON.parse(text) let msglist = obj.msglist // console.log(msglist) msglist.forEach(item =&gt; &#123; // item 为每一条说说 &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125; 导出excel用到的模块node-xlsx，将数据写入xlsx文件中。可以参考文档： https://www.npmjs.com/package/node-xlsx 例子： 1234567891011121314151617const xlsx = require(&#x27;node-xlsx&#x27;);const data = [[1, 2, 3], [true, false, null, &#x27;sheetjs&#x27;], [&#x27;foo&#x27;, &#x27;bar&#x27;, new Date(&#x27;2014-02-19T14:30Z&#x27;), &#x27;0.3&#x27;], [&#x27;baz&#x27;, null, &#x27;qux&#x27;]];const options = &#123;&#x27;!cols&#x27;: [&#123;wch: 20&#125;, &#123;wch: 20&#125;, &#123;wch: 60&#125;]&#125;; let buffer = xlsx.build([&#123; name: &#x27;sheet1&#x27;, data: data &#125;], options) fs.writeFile(&#x27;./my_xlsx.xlsx&#x27;, buffer, function (err) &#123; if (err) throw err console.log(&#x27;Write to my_xlsx.xlsx has finished&#x27;) &#125;)// Parse a fileconst workSheetsFromFile = xlsx.parse(`$&#123;__dirname&#125;/no_word.xlsx`);const workSheetsFromBuffer = xlsx.parse(fs.readFileSync(`$&#123;__dirname&#125;/no_word.xlsx`)); 以上是我做Node爬虫遇到的几种类型，以后遇到了新的再补充到下面。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://justsso1.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"在JavaScript中使用ES6 Proxy做类型安全","slug":"在JavaScript中使用ES6 Proxy做类型安全","date":"2020-04-27T16:00:00.000Z","updated":"2024-10-12T08:40:56.548Z","comments":true,"path":"2020/04/28/在JavaScript中使用ES6 Proxy做类型安全/","permalink":"https://justsso1.github.io/2020/04/28/%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8ES6%20Proxy%E5%81%9A%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/","excerpt":"","text":"当前，大多数解决JavaScript中类型安全不足的解决方案都是基于静态类型检查和类型推断。TypeScript和Flow通过添加静态类型注释来拓展JavaScript，并且可以在编译时验证您的代码，并使用相同的抽象语法树来输出最终的JS代码。由于IDE可以依靠静态分析来提供自动完成和开发辅助，因此，这对于改善开发人员的体验非常有效。但是，关于类型安全，仍然存在一个主要缺陷：一旦使用JavaScript进行编译并在浏览器中运行，就不再保证所使用的变量具有预期的类型。 欺骗TypeScript非常容易。基本上，任何可以避免静态分析的操作都可能在不通知TypeScript的情况下潜在的更改变量的类型： 使用方括号和一个代表属性的变量来检索属性 通过HTML事件属性，setTimeout或Function构造函数进行动态代码评估 全局变量与外部库或浏览器扩展冲突 一个内置原型，该原型已被库或polyfill意外修改、TypeScript开发人员试图避免上面的这些模式，并认为这是最佳实践。但是，由于开发人员对静态类型系统的信任，这可能导致一些混乱的问题，而忘记了它实际上最终是在计算机上运行的动态脚本语言。 JS中还有另一种类型安全的方法被遗忘了，可能值得更多关注：JavaScript本身中的强类型检查。 由于ECMAScript5和属性getters&#x2F;setters，我们可以控制对对象属性进行的分配。看这个例子： 12345678910111213141516let _name = &#x27;joe&#x27;;const user = &#123; get name() &#123; return _name &#125;, set name(value) &#123; if (typeof value !== &#x27;string&#x27;) &#123; throw new Error(&#x27;传入类型不是字符串&#x27;) &#125; else &#123; _name = value &#125; &#125;&#125;user.name = &#x27;hello&#x27;user.name = 123 //Error: 传入类型不是字符串 只要你知道对象的所有属性名称并且始终在对象上定义它们，你就可以对对象属性进行简单的类型检查。setters还有其他的缺陷：他们无法捕获对象属性的所有操作，能很容易的通过Object.defineProperty()之类的方法推翻。 这使我们进入了ES6&#x2F;ES2015最被低估的功能之一：Proxy对象。Proxy包裹目标对象，并充当透明传递。开发人员可以通过设置陷阱来拦截对该对象执行的所有操作。这正是为我们的代码带来强大的类型检查所需要的。 让我们用Proxy重写之前的代码： 1234567891011const user = new Proxy(&#123;_name: &#x27;joe&#x27;&#125;, &#123; set(target, p, value, receiver) &#123; if (p === &#x27;_name&#x27; &amp;&amp; typeof value !== &#x27;string&#x27;) &#123; throw new Error(&#x27;传入类型不是字符串&#x27;) &#125; return Reflect.set(target, p, value) &#125;&#125;)user._name = &#x27;hello&#x27;user._name = 456 //Error: 传入类型不是字符串 在这里，我们仅对set操作进行了拦截，但是同样的，我们还可以对defineProperty、deleteProperty以及任何其他可以使用我们的属性值发生变化的陷阱进行拦截。 与getters/ setters的主要区别在于，Proxy不需要知道属性名称即可捕获执行的操作。这样就可以对尚未定义的动态属性进行类型检查，还可以编写更多通用的使用程序函数： 123456789101112131415161718192021222324function checktype(obj, definition) &#123; return new Proxy(obj, &#123; set(obj, key, value, receiver) &#123; if (key in definition &amp;&amp; typeof value !== definition[key]) &#123; throw new Error(`$&#123;key&#125;类型应该是: $&#123;definition[key]&#125;`) &#125; return Reflect.set(obj, key, value) &#125; &#125;)&#125;class User &#123; constructor(name, age) &#123; //this 是实例 return checktype(this, &#123; name: &#x27;string&#x27;, age: &#x27;number&#x27; &#125;) &#125;&#125;let joe = new User()joe.name = &#x27;joe&#x27;;joe.age = &#x27;12&#x27; //Error: age类型应该是: number (译者的话)注意：这里只能使用 let joe &#x3D; new User(); joe.name &#x3D; ‘joe的形式，而不能使用let joe &#x3D; new User({name: 11,age: ‘23’})，因为这样并不会触发 Proxy的set拦截，不会把属性写到this对象上，这样返回的对象是空的，没有属性 User {} Proxy可以处理任何类型的对象，并且可能对变量的几乎任何操作都可以拦截。这包括function用做apply被调用，可以想象基于这些构建一个完整的类型检查系统。而这正是去年使用ObjectModel所做的事情。 1234567891011121314151617// Basic Modelsconst PositiveInteger = BasicModel(Number) .assert(Number.isInteger) .assert(n =&gt; n &gt;= 0, &quot;should be greater or equal to zero&quot;)// Object Modelsclass Person extends ObjectModel(&#123; name: String, age: PositiveInteger&#125;)&#123; greet()&#123; return `Hello I&#x27;m $&#123;this.name&#125;` &#125;&#125;// Function ModelsPerson.prototype.greetSomeone = FunctionModel(Person).return(String)(function(person)&#123; return `Hello $&#123;person.name&#125;, I&#x27;m $&#123;this.name&#125;` &#125;) &#x2F;&#x2F; and models for Arrays, Maps, Sets…模型基本上是前面代码示例中类型检查功能的改进版本。 与TypeScript接口类似，它们的作用是确保变量符合模型定义。 这只是冰山一角。 因为所有这些都是在运行时完成的，所以我们可以想象出静态类型检查解决方案无法实现的所有用例： 验证来自REST API的JSON形式，并自动将嵌套数据转换为适当的JS类 检查来自localStorage或IndexedDB的内容的有效性 通过类型检查内置浏览器API来执行功能检测 快速将类型定义添加到来自CDN的外部库 现在我们的类型已从静态分析中解脱出来，我们甚至可以想象类型定义会根据应用程序的状态而变化：例如，一旦用户权限更改，便会立即向User实例添加新控件。 如果可以科学上网的话，可以观看视频 https://www.youtube.com/embed/zmojfyNH_EE 这些只是动态类型检查系统相对于静态检查的许多好处中的几个。 除此之外，它不需要学习新的语言或添加编译步骤。 它只是一个小的普通JavaScript库。 Proxy现在具有不错的浏览器支持，我认为是时候扩大我们对JavaScript类型安全性的了解了。 TypeScript和Flow提供了出色的开发人员体验，ObjectModel并不打算取代它们，但是仍有进行创新和尝试新方法的空间。 （译者的话）虽然本文最后介绍了ObjectModel这个库，它是一个动态的类型检查js库，底层依赖的是ES6的Proxy，这说明，Proxy真的很强大，可以看看这个库的源码学习将Proxy用到实际工作中。现在ObjectModel 4.0已经发布，采用ES Module，使用ES2018写的，所以源码也是学习JS的很好的例子。 原文地址：https://medium.com/@SylvainPV/type-safety-in-javascript-using-es6-proxies-eee8fbbbd600","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[{"name":"proxy","slug":"proxy","permalink":"https://justsso1.github.io/tags/proxy/"}]},{"title":"元编程是什么","slug":"元编程是什么","date":"2020-04-26T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2020/04/27/元编程是什么/","permalink":"https://justsso1.github.io/2020/04/27/%E5%85%83%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"元编程的目标是利用语言自身的内省能力使代码的其余部分更具描述性、表达性和灵活性。 ES6在JavaScript现有的基础上为元编程新增了一些形式&#x2F;特性。如下： 函数名称程序中有多种方式可以表达一个函数，函数的”名称”应该是说什么并非总是清晰无疑的。 有词法名称的函数在ES6中， 默认情况下函数的词法名称（如果有的话）也会被设为它的name属性。如果函数设定了name值，那么这个值通常也就是开发者中栈踪迹使用的名称。没有词法名称的函数推导。 12345678910111213141516171819202122232425262728(function()&#123; .. &#125;); // name: (function*()&#123; .. &#125;); // name: window.foo = function()&#123; .. &#125;; // name: class Awesome &#123; constructor() &#123; .. &#125; // name: Awesome funny() &#123; .. &#125; // name: funny &#125; var c = class Awesome &#123; .. &#125;; // name: Awesome var o = &#123; foo() &#123; .. &#125;, // name: foo *bar() &#123; .. &#125;, // name: bar baz: () =&gt; &#123; .. &#125;, // name: baz bam: function()&#123; .. &#125;, // name: bam get qux() &#123; .. &#125;, // name: get qux set fuz() &#123; .. &#125;, // name: set fuz [&quot;b&quot; + &quot;iz&quot;]: function()&#123; .. &#125;, // name: biz [Symbol( &quot;buz&quot; )]: function()&#123; .. &#125; // name: [buz] &#125;; var x = o.foo.bind( o ); // name: bound foo (function()&#123; .. &#125;).bind( o ); // name: boundexport default function() &#123; .. &#125; // name: default var y = new Function(); // name: anonymous var GeneratorFunction = function*()&#123;&#125;.__proto__.constructor; var z = new GeneratorFunction(); // name: anonymous 默认情况下，name 属性不可写，但可配置，也就是说如果需要的话，可使用 Object.defineProperty(..) 来手动修改。 元属性new.target 元属性，关键字new用于属性访问的上下文。 公开符号Symbol.iterator调用…展开和for…of循环时，会自动使用Symbol.iterator。 Symbol.iterator表示任意对象身上的一个专门位置（属性），语言机制自动在这个位置上寻找一个方法，这个方法构造一个迭代器来消耗这个对象的值。很多对象定义有这个符号的默认值。 然而，也可以通过定义 Symbol.iterator 属性为任意对象值定义自己的迭代器逻辑，即使这会覆盖默认的迭代器。 Symbol.toStringTag与Symbol.hashInstance最常见的一个元编程任务，就是在一个值上进行内省来找出它是什么种类，这通常是为了确定其上适合执行何种运算。对于对象来说，最常用的内省技术是 toString() 和instanceof。 12345function Foo() &#123;&#125; var a = new Foo(); a.toString(); // [object Object] a instanceof Foo; // true在 ES6 中，可以控制这些操作的行为特性： 12345678910111213141516function Foo(greeting) &#123; this.greeting = greeting; &#125; Foo.prototype[Symbol.toStringTag] = &quot;Foo&quot;; Object.defineProperty( Foo, Symbol.hasInstance, &#123; value: function(inst) &#123; return inst.greeting == &quot;hello&quot;; &#125; &#125; ); var a = new Foo( &quot;hello&quot; ), b = new Foo( &quot;world&quot; ); b[Symbol.toStringTag] = &quot;cool&quot;; a.toString(); // [object Foo] String( b ); // [object cool] a instanceof Foo; // true b instanceof Foo; // false 原型（或实例本身）的Symbol.toStringTag符号指定了再[object ___]字符串化使用的字符串值。 原型（或实例本身）的Symbol.toStringTag符号指定了再[object ___]字符串化使用的字符串值。 Symbol.species通过Symbol.species改写类的默认的构造器。 12345678910111213141516171819class Cool &#123; // 把@@species推迟到子类static get [Symbol.species]() &#123; return this; &#125; again() &#123; return new this.constructor[Symbol.species](); &#125; &#125; class Fun extends Cool &#123;&#125; class Awesome extends Cool &#123; // 强制指定@@species为父构造器static get [Symbol.species]() &#123; return Cool; &#125; &#125; var a = new Fun(), b = new Awesome(), c = a.again(), d = b.again(); c instanceof Fun; // true d instanceof Awesome; // false d instanceof Cool; // true 就像前面代码中 Cool 的定义那样，内置原生构造器上 Symbol.species 的默认行为是return this。在用户类上没有默认值，但是就像展示的那样，这个行为特性很容易模拟。 如果需要定义生成新实例的方法，使用 new this.constructorSymbol.species 模式元编程，而不要硬编码 new this.constructor(..) 或 new XYZ(..)。然后继承类就能够自定义 Symbol.species 来控制由哪个构造器产生这些实例。 Symbol.toPrimitive抽象类型转换运算tpPrimitive，它用在对象为了某个操作（比如比较&#x3D;&#x3D;或者相加+）必须被强制转换为一个原生类型值的时候。在ES6之前，没有办法控制这以行为。而在ES6中，在任意对象值上作为属性的符号@@toPrimitivessysmbol都可以通过指定一个方法来定制这个ToPrimitive强制换转。 1234567891011var arr = [1,2,3,4,5]; arr + 10; // 1,2,3,4,510 arr[Symbol.toPrimitive] = function(hint) &#123; if (hint == &quot;default&quot; || hint == &quot;number&quot;) &#123; // 求所有数字之和return this.reduce( function(acc,curr)&#123; return acc + curr; &#125;, 0 ); &#125; &#125;; arr + 10; // 25 Symbol.toPrimitive方法根据调用ToPrimitive的运算期望的类型，会提供一个提示（hint）指定“string”、“number”或“default”（这应该被解释为”number”）。在前面的代码中，加法 + 运算没有提示（传入 “default”）。而乘法 * 运算提示为 “number”，String(arr)提示为 “string”。 如果一个对象与另一个非对象值比较，&#x3D;&#x3D; 运算符调用这个对象上的ToPrimitive 方法时不指定提示——如果有 @@toPrimitive 方法的话，调用时提示为 “default”。但是，如果比较的两个值都是对象，&#x3D;&#x3D; 的行为和 &#x3D;&#x3D;&#x3D; 一样，也就是直接比较其引用。这种情况下完全不会调用 @@toPrimitive。 正则表达式符号对于正则表达式对象，有4个公开符号可以被覆盖，他们控制着这些正则表达式在4个对应的同名String.prototypt函数中如何被使用。 @@match ： 正则表达式的Symbol.match值是一个用于利用给定的正则表达式匹配一个字符串值的部分或全部内容的方法。 @@replace:正则表达式的Symbol.replace值是一个方法，String.prototypt.replace(..)用它来替换一个字符串内匹配模式的一个或多个字符串序列。 @@search：正则表达式的Symbol.search值试试一个方法，String.prototype.search(..)用它来在另一个字符串中搜索一个匹配给定正则表达式的子串。 @@split：正则表达式的Symbol.split值时一个方法，String.prototype.split(..)用它把字符串在匹配给定正则表达式的分隔符处分隔为子串。 如果你不够艺高人胆大的话，就不要覆盖内置正则表达式算法了！ JavaScript 的正则表达式引擎经过高度优化，所以你自己的用户代码很可能会慢上许多。这类元编程简洁强大，但是只应该在确实需要或能带来收益的时候才使用。 Symbol.isConcatSpreadable符号 @@isConcatSpreadable 可以被定义为任意对象（比如数组或其他可迭代对象）的布尔型属性（SymbolisConcatSpreadable），用来指示如果把它传给一个数组的 concat(..) 是否应该将其展开。考虑： 1234var a = [1,2,3], b = [4,5,6]; b[Symbol.isConcatSpreadable] = false; [].concat( a, b ); // [1,2,3,[4,5,6]] Symbol.unscopables符号 @@unscopables 可以被定义为任意对象的对象属性（Symbol.unscopables），用来指示使用 with 语句时哪些属性可以或不可以暴露为词法变量。考虑： 12345678910var o = &#123; a:1, b:2, c:3 &#125;, a = 10, b = 20, c = 30; o[Symbol.unscopables] = &#123; a: false, b: true, c: false&#125;; with (o) &#123; console.log( a, b, c ); // 1 20 3 &#125; @@unscopables 对象中的 true 表示这个属性应该是 unscopable 的，因此会从词法作用域变量中被过滤出去。false 表示可以将其包含到词法作用域变量中。strict 模式下不允许 with 语句，因此应当被认为是语言的过时特性。不要使用它。因为应该避免使用 with，所以符号 @@unscopables 也没有太大意义。 代理 ProxyES6中新增的最明显的元编程特性之一是Proxy。代理是一种由你创建的特殊的对象，它“封装”另一个普通对象——或者说挡在这个普通对象的前面。你可以在代理对象上注册特殊的处理函数（也就是 trap），代理上执行各种操作的时候会调用这个程序。这些处理函数除了把操作转发给原始目标 &#x2F; 被封装对象之外，还有机会执行额外的逻辑。 每个代理处理函数在对应的元编程任务执行的时候进行拦截，而每个 Reflect 工具在一个对象上执行相应的元编程任务。每个代理处理函数都有一个自动调用相应的 Reflect 工具的默认定义。几乎可以确定 Proxy 和 Reflect 总是这么协同工作的。 get(..)通过 [[Get]]，在代理上访问一个属性（Reflect.get(..)、. 属性运算符或 [ .. ] 属性运算符） set(..)通过 [[Set]]，在代理上设置一个属性值（Reflect.set(..)、赋值运算符 &#x3D; 或目标为对象属性的解构赋值） deleteProperty(..)通 过 [[Delete]]， 从 代 理 对 象 上 删 除 一 个 属 性（Reflect.deleteProperty(..) 或（delete） apply(..)（如果目标为函数）通 过 [[Call]]，将代理作为普通函数 &#x2F; 方 法 调 用（Reflect.apply(..)、call(..)、apply(..) 或 (..) 调用运算符） construct(..)（如果目标为构造函数）通过 [[Construct]]，将代理作为构造函数调用（Reflect.construct(..) 或 new） getOwnPropertyDescriptor(..)通过 [[GetOwnProperty]]，从代理中提取一个属性描述符（Object.getOwnPropertyDescriptor(..)或 Reflect.getOwnPropertyDescriptor(..)） defineProperty(..)通过 [[DefineOwnProperty]]，在代理上设置一个属性描述符（Object.defineProperty(..)或 Reflect.defineProperty(..)） getPrototypeOf(..)通 过 [[GetPrototypeOf]]，得到代理的 [[Prototype]]（Object.getPrototypeOf(..)、Reflect.getPrototypeOf(..)、proto、Object#isPrototypeOf(..) 或 instanceof） setPrototypeOf(..)通 过 [[SetPrototypeOf]]，设置代理的 [[Prototype]]（Object.setPrototypeOf(..)、Reflect.setPrototypeOf(..) 或 proto） preventExtensions(..)通过 [[PreventExtensions]]，使得代理变成不可扩展的（Object.prevent Extensions(..)或 Reflect.preventExtensions(..)） isExtensible(..)通过 [[IsExtensible]]，检测代理是否可扩展（Object.isExtensible(..) 或 Reflect.isExtensible(..)） ownKeys(..)通过 [[OwnPropertyKeys]]，提取代理自己的属性和 &#x2F; 或符号属性（Object.keys(..)、Object.getOwnPropertyNames(..)、Object.getOwnSymbolProperties(..)、Reflect.ownKeys(..) 或 JSON.stringify(..)）enumerate(..)通过 [[Enumerate]]，取得代理拥有的和“继承来的”可枚举属性的迭代器（Reflect.enumerate(..) 或 for..in） has(..)通过 [[HasProperty]]，检查代理是否拥有或者“继承了”某个属性（Reflect.has(..)、Object#hasOwnProperty(..) 或 “prop” in obj） 但是还是有些操作是无法代理的，typeof String() + 123456789var obj = &#123; a:1, b:2 &#125;, handlers = &#123; .. &#125;, pobj = new Proxy( obj, handlers ); typeof obj; String( obj ); obj + &quot;&quot;; obj == pobj; obj === pobj 可取消代理可取消代理用 Proxy.revocable(..) 创建，这是一个普通函数，而不像 Proxy(..) 一样是构造器。除此之外，它接收同样的两个参数：target 和 handlers。和 new Proxy(..) 不一样，Proxy.revocable(..) 的返回值不是代理本身。而是一个有两个属性——proxy 和 revode 的对象 123456789101112131415161718var obj = &#123; a: 1 &#125;, handlers = &#123; get(target,key,context) &#123; // 注意：target === obj, // context === pobj console.log( &quot;accessing: &quot;, key ); return target[key]; &#125; &#125;, &#123; proxy: pobj, revoke: prevoke &#125; = Proxy.revocable( obj, handlers ); pobj.a; // accessing: a // 1 // 然后：prevoke(); pobj.a; // TypeError","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[{"name":"proxy","slug":"proxy","permalink":"https://justsso1.github.io/tags/proxy/"}]},{"title":"Proxy Reflect真的很有用","slug":"Proxy、Reflect真的很有用","date":"2020-04-25T16:00:00.000Z","updated":"2024-10-12T08:40:56.538Z","comments":true,"path":"2020/04/26/Proxy、Reflect真的很有用/","permalink":"https://justsso1.github.io/2020/04/26/Proxy%E3%80%81Reflect%E7%9C%9F%E7%9A%84%E5%BE%88%E6%9C%89%E7%94%A8/","excerpt":"","text":"ProxyProxy是什么这里我想简单来说，Proxy是对象的代理器，很好理解，我们有一个很重要的对象，我们不希望别人随便获取修改该对象，我们要保护该对象，用另外一个对象代理它，对真正要操作的对象是一种数据保护和过滤。 Proxy并不是简单的通过我们常见的代码形式如if else对对象进行保护，它是在代码编程层面对对象进行保护，属于“元编程”。比如，在读取或设置对象的属性时，我们可以利用get() set()进行代理，执行函数时（函数本来就是对象）可以使用apply(),函数当作构造器时，可以使用constructor进行拦截。 Proxy的拦截操作有哪些虽然是代理器，但是也不能任由程序员“自由发挥”，所以ES6中对Proxy做了一些限制，Proxy支持的拦截操作有下面这些： get(target, propKey, receiver): 拦截对象属性的读取 set(target, propKey, value, receiver): 拦截对象属性的设置 has(target, propKey): 拦截propKey in proxy操作，返回一个布尔值 deleteProperty(target, propKey): 拦截delete proxy[propKey]的操作，返回布尔值 ownKeys(target): 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === &#x27;prototype&#x27;) &#123; return Object.prototype; &#125; return &#x27;Hello, &#x27; + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1, 2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo === &quot;Hello, foo&quot; // true Proxy的应用Proxy提供的拦截器很多种，可以根据具体的需求，组合这些拦截器达到自己的目的 防止对象的内部属性(私有属性)被外部读写，达到类型安全 JS对象中的私有属性没有规定，我们都是约定使用前缀是’‘代表私有属性，但还是并不“私有”。可以使用Proxy做到私有属性，在get&#x2F;set属性时，判断首字符是否是’‘,如果是，则剖出错误。 123456789101112131415161718192021222324252627const handle = &#123; get(target, p, receiver) &#123; inver(p, &#x27;get&#x27;) return target[p] &#125;, set(target, p, value, receiver) &#123; inver(p, &#x27;set&#x27;) target[p] = value return true; &#125;&#125;function inver(key, action) &#123; if (key[0] === &#x27;_&#x27;) &#123; throw new Error(`Invalid attempt to $&#123;action&#125; $&#123;key&#125;`) &#125;&#125;try &#123; const target = &#123;&#125; const proxy = new Proxy(target, handle) proxy._prop proxy._prop = &#x27;c&#x27;&#125; catch (e) &#123; console.log(e) // Error: Invalid attempt to get private &quot;_prop&quot; property&#125; 使用has方法隐藏某些属性，不被in运算符发现 1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === &#x27;_&#x27;) &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: &#x27;foo&#x27;, prop: &#x27;foo&#x27; &#125;;var proxy = new Proxy(target, handler);&#x27;_prop&#x27; in proxy // false 中断处理 Proxy.revocable() Proxy.revocable方法返回一个可取消的 Proxy 实例 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。 Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 抽离校验模块，类型检查 1234567891011121314151617181920let numericDataStore = &#123; count: 0, amount: 1234, total: 14&#125;;numericDataStore = new Proxy(numericDataStore, &#123; set(target, key, value, proxy) &#123; if (typeof value !== &#x27;number&#x27;) &#123; throw Error(&quot;Properties in numericDataStore can only be numbers&quot;); &#125; return Reflect.set(target, key, value, proxy); &#125;&#125;);// 抛出错误，因为 &quot;foo&quot; 不是数值numericDataStore.count = &quot;foo&quot;;// 赋值成功numericDataStore.count = 333; 可以查看我的另一篇翻译文章：在JavaScript中使用ES6 Proxy做类型安全Proxy可以做到动态的类型检查 访问日志 对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能： 12345678910111213141516171819202122232425let api = &#123; _apiKey: &#x27;123abc456def&#x27;, getUsers: function() &#123; /* ... */ &#125;, getUser: function(userId) &#123; /* ... */ &#125;, setUser: function(userId, config) &#123; /* ... */ &#125;&#125;;function logMethodAsync(timestamp, method) &#123; setTimeout(function() &#123; console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`); &#125;, 0)&#125;api = new Proxy(api, &#123; get: function(target, key, proxy) &#123; var value = target[key]; return function(...arguments) &#123; logMethodAsync(new Date(), key); return Reflect.apply(value, target, arguments); &#125;; &#125;&#125;);api.getUsers(); 预警和拦截 假设你不想让其他开发者删除 noDelete 属性，还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142let dataStore = &#123; noDelete: 1235, oldMethod: function() &#123;/*...*/ &#125;, doNotChange: &quot;tried and true&quot;&#125;;const NODELETE = [&#x27;noDelete&#x27;]; const NOCHANGE = [&#x27;doNotChange&#x27;];const DEPRECATED = [&#x27;oldMethod&#x27;]; dataStore = new Proxy(dataStore, &#123; set(target, key, value, proxy) &#123; if (NOCHANGE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; is immutable.`); &#125; return Reflect.set(target, key, value, proxy); &#125;, deleteProperty(target, key) &#123; if (NODELETE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; cannot be deleted.`); &#125; return Reflect.deleteProperty(target, key); &#125;, get(target, key, proxy) &#123; if (DEPRECATED.includes(key)) &#123; console.warn(`Warning! $&#123;key&#125; is deprecated.`); &#125; var val = target[key]; return typeof val === &#x27;function&#x27; ? function(...args) &#123; Reflect.apply(target[key], target, args); &#125; : val; &#125;&#125;);// these will throw errors or log warnings, respectivelydataStore.doNotChange = &quot;foo&quot;; delete dataStore.noDelete; dataStore.oldMethod(); 过略操作 某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处： 12345678910111213141516171819202122let obj = &#123; getGiantFile: function(fileId) &#123;/*...*/ &#125;&#125;;obj = new Proxy(obj, &#123; get(target, key, proxy) &#123; return function(...args) &#123; const id = args[0]; let isEnroute = checkEnroute(id); let isDownloading = checkStatus(id); let cached = getCached(id); if (isEnroute || isDownloading) &#123; return false; &#125; if (cached) &#123; return cached; &#125; return Reflect.apply(target[key], target, args); &#125; &#125;&#125;); 以上我们可以看出，Proxy对于对象的代理作用很大，可以只对外展示我们允许展示的内容，比如某些属性、某些方法了。Proxys属于元编程了，在框架编写中会用，当框架复杂度很高，封装的对象中肯定有一些内容是作为私有的，不能对外暴露，所以使用Proxy可以保证封装的对象的安全性和独立性。 即便不在框架中，在我们平时的开发任务中也可以用。比如封装数据库ORM，代理网络请求等等。 思考：Proxy和TypeScript的关联和区别像是set()拦截，我们可以拦截值的类型是否符合我们的要求，比如必须是数值，才会set()操作成功。Proxy和TypeScript同样都可以做到。那他们的区别是什么呢？Proxy是类似“元编程”，而TypeScript是JavaScript类型的超集，它可以编译成JS。他们解决问题的层面不一样，TypeScript是静态类型检查，在代码编译阶段就可以检测出来，IDE可以为我们报错；而Proxy可以提供动态类型检查，在运行时也能做到类型检查。 ReflectReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。 描述与大多数全局对象不同，Reflect不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）。 方法Reflect是内置对象，在浏览器控制台中输入Reflect查看： Reflect对象提供以下静态函数，它们具有与处理器对象（也就是Proxy handle）方法相同的名称。这些方法中的一些与 Object 上的对应方法相同。 Reflect.apply()对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。 Reflect.construct()对构造函数进行 new 操作，相当于执行 new target(…args)。 Reflect.defineProperty()和 Object.defineProperty() 类似。 Reflect.deleteProperty()作为函数的delete操作符，相当于执行 delete target[name]。 Reflect.enumerate()该方法会返回一个包含有目标对象身上所有可枚举的自身字符串属性以及继承字符串属性的迭代器，for…in 操作遍历到的正是这些属性。 Reflect.get()获取对象身上某个属性的值，类似于 target[name]。 Reflect.getOwnPropertyDescriptor()类似于 Object.getOwnPropertyDescriptor()。Reflect.getPrototypeOf()类似于 Object.getPrototypeOf()。Reflect.has()判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。Reflect.isExtensible()类似于 Object.isExtensible().Reflect.ownKeys()返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响).Reflect.preventExtensions()类似于 Object.preventExtensions()。返回一个Boolean。Reflect.set()将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。Reflect.setPrototypeOf()类似于 Object.setPrototypeOf()。 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect https://medium.com/@SylvainPV/type-safety-in-javascript-using-es6-proxies-eee8fbbbd600","categories":[],"tags":[{"name":"proxy","slug":"proxy","permalink":"https://justsso1.github.io/tags/proxy/"}]},{"title":"ES6 Modules模块系统","slug":"es6-ES Modules模块系统","date":"2020-04-25T16:00:00.000Z","updated":"2024-10-12T08:40:56.541Z","comments":true,"path":"2020/04/26/es6-ES Modules模块系统/","permalink":"https://justsso1.github.io/2020/04/26/es6-ES%20Modules%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"ES6 Module将每个文件作为一个模块，每个模块拥有自身的作用域。ES6 Module 会自动采用严格模式， 导出 export在ES6 Module中使用export命令来导出模块。export有两种方式： 命名导出默认导出一个模块可以有多个命名导出。它有两种不同的写法： Javascript &#x2F;&#x2F;写法一export const name &#x3D; ‘jack’;export const add &#x3D; function(a,b){return a+b} &#x2F;&#x2F;写法二const name &#x3D; ‘jack’;const add &#x3D; (a,b) &#x3D;&gt; a+bexport { name, add}在使用命名导出时，可以通过as关键字对变量重命名。 Javascriptconst name &#x3D; ‘jack’;const add &#x3D; (a,b) &#x3D;&gt; a+bexport { name, add as getSum}模块的默认导出只能有一个。如： Javascriptexport default { name: ‘jack’, add: function(a,b) { return a+b }}我们可以将export default理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。 Javascript&#x2F;&#x2F; 导出字符串export default ‘This is lal.js’ &#x2F;&#x2F; 导出 classexport default class{..} &#x2F;&#x2F;导出匿名函数export default function(){..}导入导入对应着导出，也有两种方式。 导入带有命名导出的模块Javascript&#x2F;&#x2F;lal.js const name &#x3D; ‘jack’;const add &#x3D; (a,b) &#x3D;&gt; a+bexport { name, add}import {name, add} from ‘.&#x2F;lal.js’;加载带有命名导出的模块时，import后面要跟一堆大括号来将导入的变量名包裹起来，并且这些变量名需要与导出的变量名完全一直。导入变量的效果相当于在当前作用域下声明了这些变量（name 和add）,并且不可对其进行更改，也就是所有导入的变量都是只读的。 与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。 Javascriptimport {name, add as Sum} from ‘.&#x2F;lal.js’Sum(2,3)整体导入 import * as A from ‘.&#x2F;a.js’ 对于默认导出的导入Javascript&#x2F;&#x2F;lal.jsexport default { name: ‘jack’, add: function(a,b) { return a+b }} import A from ‘.&#x2F;lal,js’A.add(2,3)对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（），它指代了lal.js中默认导出的。从原理上可以这样去处理：","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://justsso1.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"ES6语法糖之箭头函数","slug":"ES6语法糖之箭头函数","date":"2020-04-18T16:00:00.000Z","updated":"2024-10-12T08:40:56.532Z","comments":true,"path":"2020/04/19/ES6语法糖之箭头函数/","permalink":"https://justsso1.github.io/2020/04/19/ES6%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"普通函数中this的绑定是很复杂多变的，ES6箭头函数&#x3D;&gt;以特定的方式改变this的行为特性，解决this相关编码的一个特殊又常见的痛点。 箭头函数也不总是比普通函数好，当这个函数越长，&#x3D;&gt;带来的好处越小，这个函数越短，&#x3D;&gt;带来的好处越大。所以只在确实需要简短的在线函数表达式的时候才用&#x3D;&gt;，而对于那些一般长度的函数则无需改变。 123456789var controller = &#123; makeRequest: function()&#123; var self = this; btn.addEventListener( &quot;click&quot;, function()&#123; // .. self.makeRequest(); &#125;, false ); &#125; &#125;; 在这个例子中，我们使用var self &#x3D; this这一Hack，然后使用self.makeRequest，因为我们传入addEVentListener的回调函数内部，this绑定和makeRequest()本身的this绑定不一样。普通函数中的this绑定是动态的，我们需要通过self变量依赖词法作用域的可预测性。 箭头函数中的this绑定不是动态的，而是词法的。 123456789var controller = &#123; makeRequest: function()&#123; btn.addEventListener( &quot;click&quot;, () =&gt; &#123; // .. this.makeRequest(); &#125;, false ); &#125; &#125;; 我们使用=&gt;箭头函数替代普通函数，箭头函数回调中的词法this和makeRequest()中是一样的。&#x3D;&gt;就是var self &#x3D; this的词法替代形式。 我们使用Babel转换一下： 发现，在使用&#x3D;&gt;之前，也就是箭头函数的外层，先使用var self &#x3D; this保存了this 再看一个例子： 12345678910var controller = &#123; makeRequest: () =&gt; &#123; // .. this.helper(); &#125;, helper: () =&gt; &#123; // .. &#125; &#125;; controller.makeRequest(); 尽管我们以 controller.makeRequest(..) 的形式调用，this.helper 引用还是会失败，因为这里的 this 并不像平常一样指向 controller。那么它指向哪里呢？它是从包围的作用域中词法继承而来的 this。在前面的代码中也就是全局作用域，其中 this 指向那个全局对象。 箭头函数没有自己的this，只有词法this，继承自父层 箭头函数没有自己的arguments数组，只有词法arguments，继承自父层 箭头函数也没有super 箭头函数也没有new.target 作用域和作用域链 一定要记住箭头函数的特点，在适当的地方使用。如果是写对象的方法，要使用普通函数，因为普通函数中有this，一般情况下指向该对象，而箭头函数没有this,则访问不到对象的其他属性了。 如果返回值是一个简单的表达式，且这个函数内部没有this的引用，且没有自身引用（递归、绑定&#x2F;解绑定，且不会要求函数执行这些，可以使用箭头函数。 如果函数内部有很多语句，还是要用普通函数，保证可读性。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"我对模板字符串中标签模板的思考","slug":"我对模版字符串中标签模板的思考","date":"2020-04-16T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/04/17/我对模版字符串中标签模板的思考/","permalink":"https://justsso1.github.io/2020/04/17/%E6%88%91%E5%AF%B9%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"模板字符串模板字符串的几个特性： 可以嵌入变量，或者表达式 会保留多个空格、换行、缩进 12345678910111213141516171819202122232425262728//嵌入变量var name = &quot;Kyle&quot;; var greeting = `Hello $&#123;name&#125;!`; console.log( greeting ); // &quot;Hello Kyle!&quot;//多行var text = `Now is the time for all good men to come to the aid of their country!`; console.log( text ); // Now is the time for all good men // to come to the aid of their // country!var text = //插入表达式function upper(s) &#123; return s.toUpperCase(); &#125; var who = &quot;reader&quot;; var text = `A very $&#123;upper( &quot;warm&quot; )&#125; welcome to all of you $&#123;upper( `$&#123;who&#125;s` )&#125;!`; console.log( text ); // A very WARM welcome // to all of you READERS! 标签模板 模板字符串还可以跟在一个函数后面，该函数将被调用来处理这个模板字符串。这被称为”标签模板”功能。 123alert`123`// 等同于alert(123) 如果模板字符串中含有变量，标签模板会进行特殊处理，它会根据嵌入的变量，把模板字符串拆开。普通字符串组成数组做位第一个参数，插入的变量依次作为第二个、第三个…变量。 1234567891011121314151617var a = 5;var b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag([&#x27;Hello &#x27;, &#x27; world &#x27;, &#x27;&#x27;], 15, 50);function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 为什么要有标签模板？我第一次看到标签模板的时候，不禁在想为什么要有标签模板，它有什么普通函数不能替代的地方呢？如果没有不可替代的地方，那为什么还要创造它呢？答案是：标签模板确实有它存在的意义，也有普通函数无法替代它的地方。 12const logArgs = (...args) =&gt; console.log(...args) 先用普通函数形式调用 12logArgs(&#x27;a&#x27;, &#x27;b&#x27;)// -&gt; a b 再用一个简单的模板字符串试试： 12logArgs``// -&gt; [&quot;&quot;, raw: Array(1)] 上面输出了一个空数组，然后传入一个有值的模板字符串： 12logArgs`I like pizza`// -&gt; [&quot;I like pizza&quot;] 现在，进一步网模板字符串中传入变量 123456789101112const favoriteFood = &#x27;pizza&#x27;//当作普通函数调用，直接出入拼接的字符串logArgs(`I like $&#123;favoriteFood&#125;.`)// -&gt; I like pizza.//使用标签模板，会输出处理后的参数const favoriteFood = &#x27;pizza&#x27;logArgs`I like $&#123;favoriteFood&#125;.`// -&gt; [&quot;I like &quot;, &quot;.&quot;] &quot;pizza&quot; 变换过程是这样的： 当我们传入多个变量时，每一个插入的变量都作为下一个参数了 12345const favoriteFood = &#x27;pizza&#x27;const favoriteDrink = &#x27;obi&#x27;logArgs`I like $&#123;favoriteFood&#125; and $&#123;favoriteDrink&#125;.`// -&gt; [&quot;I like &quot;, &quot; and &quot;, &quot;.&quot;] &quot;pizza&quot; &quot;obi&quot; 这样看来，标签模版有什么大的作用呢？ 1234567//普通函数logArgs(`Test $&#123;() =&gt; console.log(&#x27;test&#x27;)&#125;`)// -&gt; Test () =&gt; console.log(&#x27;test&#x27;)console.log(() =&gt; console.log(&#x27;test&#x27;))// () =&gt; console.log(&#x27;test&#x27;) 普通函数，遇到变量是一个函数是，会把函数变成字符串形式的，而没有别的处理，看看标签模板的特殊之处，模板字符串中嵌入变量 123logArgs`Test $&#123;() =&gt; console.log(&#x27;test&#x27;)&#125;`// -&gt; [&quot;Test&quot;, &quot;&quot;] () =&gt; console.log(&#x27;test&#x27;) 可以看出，标签模板把模板字符串中的变量解析了出来，函数还是一个函数不会变成字符串。我们有能力拿到函数，那么我们也可以执行这个函数 12345const execFuncArgs = (...args) =&gt; args.forEach(arg =&gt; &#123; if (typeof arg === &#x27;function&#x27;) &#123; arg() &#125;&#125;) 上面的函数，我们会忽略不是函数的参数，是函数就执行它 12345678execFuncArgs(&#x27;a&#x27;, &#x27;b&#x27;)// -&gt; undefinedexecFuncArgs(() =&gt; &#123; console.log(&#x27;this is a function&#x27;) &#125;)// -&gt; &quot;this is a function&quot;execFuncArgs(&#x27;a&#x27;, () =&gt; &#123; console.log(&#x27;another one&#x27;) &#125;)// -&gt; &quot;another one&quot; 让我们把它当作普通函数来调用带有变量的模板字符串 12execFuncArgs(`Hi, $&#123;() =&gt; &#123; console.log(&#x27;Executed!&#x27;) &#125;&#125;`)// -&gt; undefined 为什么会是undfined呢？因为，普通函数调用的方式，模板字符串会全部变成字符串的形式，变量也变成了字符串的形式实际上调用参数是这样的： &quot;Hi, () =&gt; &#123; console.log(&#39;I got executed!&#39;) &#125;&quot;. 把上面的函数当作”标签模板”来调用 12execFuncArgs`Hi, $&#123;() =&gt; &#123; console.log(&#x27;Executed!&#x27;) &#125;&#125;`// -&gt; &quot;Executed!&quot; 与之前相反，execFuncArgs的第二个参数实际上是一个函数，然后会执行这个函数。由此可以解决我的疑问了：标签模板可以对传入的模板字符串中的变量，进行提取，并进一步处理，普通函数根本取不到这些变量，就甭提进一步处理了。 标签模板的实际应用“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。 1234567891011121314151617181920var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;); // Don&#x27;t escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 123456var sender = &#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;; // 恶意代码var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 12i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot; 还有common-tags库中的oneLine标签函数 12345678import &#123;oneLine&#125; from &#x27;common-tags&#x27;oneLine` foo bar baz`// &quot;foo bar baz&quot; 总之，标签模板功能很强大，可能一开始并不会觉得厉害之处，平时工作中也不会用到，但是这些知识是有用的，在很多库中会用到它，我们使用这些库的时候也在不自觉中使用了标签模板，可以慢慢开始了解它，并使用它。 参考文章： ES6 Tagged Template Literals The magic behind 💅 styled-components","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"深入理解let和const原理","slug":"深入理解let和const原理","date":"2020-04-11T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/04/12/深入理解let和const原理/","permalink":"https://justsso1.github.io/2020/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3let%E5%92%8Cconst%E5%8E%9F%E7%90%86/","excerpt":"","text":"let 和const命令是ES6新增的，让我们来看看它们是怎么回事吧～ 在有 let 和const之前，我们使用 var 来声明变量，var声明变量会有变量提升的特性， Javascriptconsole.log(a)var a &#x3D; 1 &#x2F;&#x2F;undefined用var声明a,a变量会被提升到在当前作用域的最前面声明，其实执行的代码是这样的： Javascriptvar a;console.log(a)a &#x3D; 1;为了约束变量提升，出现了块级作用域，块级作用域搭配let和const就没有变量提升了。 Javascriptconsole.log(b)let b &#x3D; 1 &#x2F;&#x2F;ReferenceError: b is not defined用let就没有变量提升的问题，但是在声明变量之前就访问，会报错，访问b会报ReferenceError错误那let为什么没有变量提升的问题呢？块级作用域又是什么呢？ 块级作用域let和const实际上为ES6引入了”块级作用域”的概念。在ES5中只有全局作用域和函数作用域。ES6新增了块级作用域来约束变量的生命周期。简单说就是两个大括号{}就形成了块级作用域，外层代码块不受内层代码块的影响。 1234567891011121314function f1()&#123; let n = 5; if(true)&#123; let n = 10 &#125; console.log(n) //5&#125;for(let i =0 ;i&lt; 10 ;i++)&#123;&#125;console.log(i) //ReferenceError: i is not defined 内层的n不会影响外层的n，所以打印n&#x3D;5for循环中声明了变量i,在for循环之外访问i变量，会报错，这是因为在外层代码块中没有声明变量i for循环中都会有块级作用域。我们来看一个经典的例子 123456789var arr = []for (var i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;&#125;arr[2]() //10console.log(i) //10 在for循环外可以访问到i，i的值为10，这是因为i在for循环中使用var声明了，会被变量提升，结果就是i挂载到全局对象中，在浏览器中就是window对象，成为window的属性。每一层循环改变的都是全局的i, 传入到循环中的console.log(i)都是10，最后外部访问的i值也变成了10 123456789var brr = []for (let i = 0; i &lt; 10; i++) &#123; brr[i] = function () &#123; console.log(i) &#125;&#125;brr[2]() //2console.log(i) //ReferenceError: i is not defined for循环中使用let声明变量i，这样每一层循环都重新声明了i，并绑定了当前循环的代码块，所以传入内存函数的额console.log(i)也是当时的i的值，所以brr2执行时，变量i的值是2，在for循环外访问i会出错。 你可能会问，每一层的循环变量都是重新声明的，那么for循环怎么知道上一层循环的值，从而计算出本层的值？这是因为Javascript引擎内部会记住上一层的循环的值，在上一层循环的基础上，计算得出初始化本层的变量的值。 细说for循环中的块级作用域for循环中（）是一个块级作用域，而循环体内{}是一个单独的子作用域。 12345678for (let i = 0; i &lt; 3; i++) &#123; let i = &#x27;abc&#x27;; console.log(i);&#125;// abc// abc// abc 上面输出三次 abc ，说明，循环内部的i变量与循环变量i不在同一个作用域，有各自单独的作用域。 我们来看看let到底是怎么由var转过来的，我用Babel试试： 12345678910var brr = []for (let i = 0; i &lt; 10; i++) &#123; brr[i] = function () &#123; console.log(i) &#125;&#125;brr[2]()console.log(i) Babel转过之后， 12345678910111213141516&quot;use strict&quot;;var brr = [];var _loop = function _loop(_i) &#123; brr[_i] = function () &#123; console.log(_i); &#125;;&#125;;for (var _i = 0; _i &lt; 10; _i++) &#123; _loop(_i);&#125;brr[2]();console.log(i); babel把for循环内层都抽象到一个函数中了，然后，把循环变量传入这个函数参数，这样每一层的循环都会返回一个函数声明，而循环变量都会锁定住。 暂时性死区只要块级作用域中有let和const命令，那么所声明的变量就”绑定”这个区域，不再受外部的影响。在块级作用域内，使用let或const声明变量之前，该变量都是不可取的，这就叫”暂时性死区” 暂时性死区解决的问题：解决了在声明变量之前访问该变量，没有变量提升，主要为了减少运行时错误。 暂时性死区的本质： 只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，不可访问，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 const基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。 const 也不会变量提升 const 也存在暂时性死区特性 const在声明变量时就要赋值，否则以后不能赋值了 const只声明不赋值会报错 const 声明的变量如果是基本类型，那么不允许改变，如果是引用类型，那么只要不改变引用的地址就是可以的。 本质Javascriptconst name &#x3D; ‘Friday’name &#x3D; ‘Sunday’ &#x2F;&#x2F;直接报错 const people &#x3D; { name: ‘Jack’, age: 21}people.age &#x3D; 22console.log(people) &#x2F;&#x2F;{ name: ‘Jack’, age: 22 }","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"聊聊function与作用域链","slug":"聊聊function与作用域链","date":"2020-04-11T16:00:00.000Z","updated":"2024-10-16T03:56:56.748Z","comments":true,"path":"2020/04/12/聊聊function与作用域链/","permalink":"https://justsso1.github.io/2020/04/12/%E8%81%8A%E8%81%8Afunction%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/","excerpt":"","text":"聊聊function与作用域链 前言：function在js中扮演了举足轻重的角色，是一等公民。function和new在一起会有实例、原型、原型链等一系列问题。function中访问变量会有作用域、作用域链的问题，以及闭包等概念。 js中数据类型：基本类型和引用类型引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 基本类型和引用类型的不同点： 存储方式不同。基本数据类型存储在栈内存中，引用类型存储在堆内存中，变量存的是指向堆内存的地址 复制时的不同。基本类型的值会创建一个值的额副本；引用类型，复制的其实是指针，因此两个变量最终都指向同一个对象传递参数传递参数，ECMAScript中所有函数的参数都是按指传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把指从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型类型值的传递，则如同引用类型变量的复制一样。 #####检测类型typeof检测出基本类型和”object”类型，具体哪种对象类型检测不出 123456var s = &quot;Nicholas&quot;; //&quot;string&quot;var b = true; //&quot;boolean&quot;var i = 22; //&quot;number&quot;var u; // &quot;undefined&quot;var n = null; //&quot;object&quot;var o = new Object(); //&quot;object&quot; instanceof可以检测出对象是哪种类型的 1var result = variable instanceof constructor 只要在该对象的原型链上有该构造函数，结果就是true。而Object是所有对象的原型链上最顶层的构造函数，所以在检测一个引用类型值和Object构造函数时，instanceof操作符一定返回true。如果使用instanceof操作符检测基本类型值时，始终返回false，因为基本类型不是对象。 所以，确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。 执行环境及作用域所有变量（包括基本类型和引用类型）都存在于一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；变量的执行环境有助于确定应该何时释放内存。代码： 1234567891011121314var color = &quot;blue&quot;; function changeColor()&#123; var anotherColor = &quot;red&quot;; function swapColors()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; // 这里可以访问 color、anotherColor 和 tempColor &#125; // 这里可以访问 color 和 anotherColor，但不能访问 tempColor swapColors(); &#125; // 这里只能访问 color changeColor(); 以上代码共涉及 3 个执行环境：全局环境、changeColor()的局部环境和 swapColors()的局部环境。全局环境中有一个变量 color 和一个函数 changeColor()。changeColor()的局部环境中有一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变量 color。swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。 JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。当代码中存在循环引用现象时，“引用计数”算法就会导致问题。解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。闭包为何有用？闭包是指有权访问另一个函数作用域中的变量的函数。 上面的作用域链对理解闭包至关重要，在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只是引用但不实际包含变量对象。 一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是闭包的情况由有所不同。闭包是有权访问包含函数的作用域的，闭包保存的是包含函数的变量对象，所以它的包含函数作用域不会被销毁掉。 关于this对象每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了 123456789101112var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //&quot;My Object&quot; 在定义匿名函数之前，我们把 this对象赋值给了一个名叫 that 的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。即使在函数返回之后，that 也仍然引用着 object，所以调用object.getNameFunc()()就返回了”My Object”。 this 和 arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。 闭包有可能产生的问题：内存泄漏 由于 IE9 之前的版本对 JScript 对象和 COM 对象使用不同的垃圾收集例程，因此闭包在 IE 的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁。来看下面的例子。 Javascriptfunction assignHandler(){ var element &#x3D; document.getElementById(“someElement”); element.onclick &#x3D; function(){ alert(element.id); };}以上代码创建了一个作为 element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用（事件将在第 13 章讨论）。由于匿名函数保存了一个对 assignHandler()的活动对象的引用，因此就会导致无法减少 element 的引用数。只要匿名函数存在，element 的引用数至少也是 1，因此它所占用的内存就永远不会被回收。 不过，这个问题可以通过稍微改写一下代码来解决，如下所示。 12345678function assignHandler()&#123; var element = document.getElementById(&quot;someElement&quot;); var id = element.id; element.onclick = function()&#123; alert(id); &#125;; element = null; &#125; 在上面的代码中，通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着 element。即使闭包不直接引用 element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把 element 变量设置为 null。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。 1.使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念）。创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用；结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。像C++是由块级作用域的就是在{}中声明的变量的生命周期只在这对花括号中，在花括号外是访问不到的。而js并不是这样。 123456function outputNumbers(count)&#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; alert(i); //计数&#125; 这个函数中定义了一个 for 循环，而变量 i 的初始值被设置为 0。在 Java、C++等语言中，变量 i只会在 for 循环的语句块中有定义，循环一旦结束，变量 i 就会被销毁。可是在 JavaScrip 中，变量 i是定义在 ouputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即使像下面这样错误地重新声明同一个变量，也不会改变它的值。 可以借助匿名函数实现块级作用域，函数表达式后面跟圆括号，代表立即执行，形成私有作用域，执行完之后，里面的变量也会被回收调。 123456789101112(function()&#123; //这里是块级作用域&#125;)();Javascriptfunction outputNumbers(count)&#123; (function () &#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //导致一个错误！&#125; 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。 2.闭包还可以用于对象中创建私有变量即使JavaScript中还没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中的定义的变量。有权访问私有变量的公有方法叫做特权方法。可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。严格来讲，JavaScript 中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。 123456789101112function Person(name)&#123; this.getName = function()&#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;; &#125; var person = new Person(&quot;Nicholas&quot;); alert(person.getName()); //&quot;Nicholas&quot; person.setName(&quot;Greg&quot;); alert(person.getName()); //&quot;Greg&quot; 在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。 静态私有变量。主要使用原型模式，公有方法定义在原型上，使用一个未经声明的变量（变成全局变量），能够在私有作用域之外被访问到。模块模式。模块模式通过为单例（一个实例对象）添加私有变量和特权方法能够使其得到增强。增强的模块模式。在模块模式的基础上，在返回对象之前加入对其增强的代码。JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"模拟实现数组的forEach","slug":"es6-模拟实现数组的forEaches6-模拟实现数组的forEach","date":"2020-04-10T16:00:00.000Z","updated":"2024-10-12T08:40:56.541Z","comments":true,"path":"2020/04/11/es6-模拟实现数组的forEaches6-模拟实现数组的forEach/","permalink":"https://justsso1.github.io/2020/04/11/es6-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84forEaches6-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84forEach/","excerpt":"","text":"Javascript底层源码应该是用c&#x2F;c++写的，并不是JS代码，所以只能是尽可能的模拟 先讲一下forEach的api用法： forEach(function(currentValue, index, arr), thisArg) forEach底层是用的最基本的for循环实现的：Javascript底层源码应该是用c&#x2F;c++写的，并不是JS代码，所以只能是尽可能的模拟 先讲一下forEach的api用法： forEach(function(currentValue, index, arr), thisArg) forEach底层是用的最基本的for循环实现的：","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"聊聊function与原型链","slug":"聊聊function与原型链","date":"2020-04-10T16:00:00.000Z","updated":"2024-10-16T03:56:52.734Z","comments":true,"path":"2020/04/11/聊聊function与原型链/","permalink":"https://justsso1.github.io/2020/04/11/%E8%81%8A%E8%81%8Afunction%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"聊聊function与原型链前言：function在js中扮演了举足轻重的角色，是一等公民。function和new在一起会有实例、原型、原型链等一系列问题。function中访问变量会有作用域、作用域链的问题，以及闭包等概念。 本篇文章主要讲解原型链相关的内容，下篇文章将会讲解作用域链相关内容。 js中神奇的的functionjs中的function其实是Function类型的实例。Function类型函数是js语言自有的类型，而一个具体的函数是Function类型的实例，函数名其实是一个指向函数实例对象的指针。而且，js中的function只不过是将一些语句封装在一起，在函数被执行时，才确定它绑定的环境对象，才会创建活动对象，所以函数非常灵活，可以动态改变绑定的环境对象，达到复用。 function有两个重要的属性：arguments和this对象。arguments类似数组，保存着函数传入参数的一份副本，this对象是指函数据以执行的环境对象，本篇主要讲解this. 函数function即可以直接调用，也可以使用new变量调用，这样的函数叫构造函数，虽然本质上和普通函数没有区别，但是为了创建自定义类型，做出区分，构造函数的首字母一般大写。 然后js中的面向对象就很有趣了，javascript也是面向对象的程序设计语言，但它和传统语言如c++在面向对象的设计上有很大不同，js没有class类的概念，它利用function的prototype ，也就是原型链来完成面向对象的设计。先看一下传统的面向对象程序的介绍吧： 面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，对象是类的实例化。对象间通过消息传递相互通信，来模拟现实世界中不同实体间的联系。在面向对象的程序设计中，对象是组成程序的基本模块。 要知道js这门语言的历史，它是创始人Brendan Eich大佬在几天之类创造出来的一门新的语言，为了让这门语言看起来像Java更受欢迎，才取名Javascript，当时js也是跑在浏览器中的脚本语言，也没想面向对象像强类型语言那样设计，所以就成了利用function和prototype这个鬼样子来实现，可见，千万不要赶工啊～你看看为了完成任务，留了多少坑，泪～所以java和javascript是雷锋和雷峰塔的关系。 面向对象要有对象和继承，我们先讲js中怎么创建对象，然后讲怎么继承。 每一个function在声明的时候，就有一个prototype属性，它指向该构造函数的原型对象。利用new 操作构建函数创建的实例，这三者之间是什么关系呢？构造函数的prototype指向原型对象，原型对象默认有一个constructor属性指向构造函数；实例有一个proto属性指向原型对象。 虽然创建对象可以使用new Object()之类的，但是要实现面向对象的继承，就离不开原型链了。 构造函数其实是js中创建对象的一种方式，还有其他方式，如工厂模式、原型模式、组合使用构造函数和原型模式等，本篇文章会讲和原型链相关的，其他的不会细细的讲。 创建对象工厂模式工厂模式，就是封装一个函数，内部负责生产对象。 123456789101112 var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 缺点：生产出的对象没有类型可言。 构造函数模式开头说了function可以作为构造函数用new创建实例，上文也基本说了构造函数。 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 现在可以说说new，虽然javascript使用new来连接构造函数和对象，但是js中的new和java中的new的含义很不同。new操作符实际上会经历以下4步：(1) 创建一个新对象；(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；(3) 执行构造函数中的代码（为这个新对象添加属性）；(4) 返回新对象。 原型模式因为所有实例的原型对象事同一个，所以原型对象上面的属性，所有实例共享，也算是可以少些一些代码创建对象了。 12345678910111213function Person()&#123; &#125; Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot; var person2 = new Person(); person2.sayName(); //&quot;Nicholas&quot; alert(person1.sayName == person2.sayName); //true 原型对象上面的基本类型属性还好，会创建值的副本，但是对于引用类型属性，指的是同一个地址，不同实例之间操作引用类型属性是对互相影响的。还有函数，函数也是一个独享，每个实例都会创建一个匿名函数绑定在sayName上面，就会造成内存浪费，函数可以只创建一个，执行的时候动态改变this就可。 原型链： 如果一个原型对象是另一个类型的实例，依次递推，那么就形成了原型链。 12345678910111213function Person()&#123; &#125; Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot; var person2 = new Person(); person2.sayName(); //&quot;Nicholas&quot; alert(person1.sayName == person2.sayName); //true 可能会觉得Person.prototype太麻烦了，想Person.prototype &#x3D; {}这样写，但是这样写会 重写原型对象，原型对象中的constructor消失，原型链也断了。所以要手动的添加constructor，手动连接原型链。 1234567891011function Person()&#123; &#125; Person.prototype = &#123; constructor : Person, name : &quot;Nicholas&quot;, age : 29, job: &quot;Software Engineer&quot;, sayName : function () &#123; alert(this.name); &#125; &#125;; 组合使用构造函数和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。 12345678910111213141516171819function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;Court&quot;]; &#125; Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); person1.friends.push(&quot;Van&quot;); alert(person1.friends); //&quot;Shelby,Count,Van&quot; alert(person2.friends); //&quot;Shelby,Count&quot; alert(person1.friends === person2.friends); //false alert(person1.sayName === person2.sayName); //true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不会影响到 person2.friends，因为它们分别引用了不同的数组。这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 继承是怎么实现继承的？利用原型链，形成”父类””子类”的关系，虽然不如java语言那样的完美，但也可以模拟出来。子类的原型对象是父类的实例的话，那么父类实例上面的属性和方法，子类都可以访问到，算是”继承”了。通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。 123456789101112131415161718192021222324252627282930 this.property = true; &#125; SuperType.prototype.getSuperValue = function()&#123; return this.property; &#125;; function SubType()&#123; this.subproperty = false; &#125; //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function ()&#123; return this.subproperty; &#125;; var instance = new SubType(); alert(instance.getSuperValue()); //trueJavascript this.property = true; &#125; SuperType.prototype.getSuperValue = function()&#123; return this.property; &#125;; function SubType()&#123; this.subproperty = false; &#125; //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function ()&#123; return this.subproperty; &#125;; var instance = new SubType(); alert(instance.getSuperValue()); //true","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"模拟实现ES6的Map数据结构","slug":"模拟实现ES6的Map数据结构","date":"2020-04-07T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/04/08/模拟实现ES6的Map数据结构/","permalink":"https://justsso1.github.io/2020/04/08/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0ES6%E7%9A%84Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"大家都知道ES6中的Map是新增的一种数据结构。它类似对象，但是对象的键只能是字符串，Map的键不限定是字符串，Map的键可以是一个对象，可以是布尔值等。Map提供”值-值”的对应关系，是一种Hash结构，但实际上ES6又比传统Hash多了一些特性。 通过下面这个小例子，我们看一下Map比传统Hash多的特性是什么： 123456let m = new Map()m.set(1,1).set(2,2).set(3,3) //Map(3) &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;m.delete(2) //true Map(2) &#123;1 =&gt; 1, 3 =&gt; 3&#125; m.set(1,&#x27;1&#x27;) //Map(2) &#123;1 =&gt; &quot;1&quot;, 3 =&gt; 3&#125;m.set(4,4) //Map(3) &#123;1 =&gt; &quot;1&quot;, 3 =&gt; 3, 4 =&gt; 4&#125; 我简单罗列一下 Map 的api（但并不是重点） Map.prototype.set(key,value)，返回Map本身，所以可以链式 Map.prototype.get(key) 如果找不到，返回undefined Map.prototype.has(key) Map.prototype.clear() 这篇文章的重点不是讲解api的，而是透过Map提供的这些api,能够体会到Map底层的数据结构是什么样的 上面的例子，先初始化一个Map m，然后一次性set 3 个值，可以看到此时的m是Map(3) &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;正好和我们set的顺序是对应的，然后删除key&#x3D;2的键值对，然后m是Map(2) &#123;1 =&gt; 1, 3 =&gt; 3&#125;,然后重新m.set(1,&#39;1&#39;)，这时m是Map(2) &#123;1 =&gt; &quot;1&quot;, 3 =&gt; 3&#125;，再m.set(4,4)，可以看到m是Map(3) &#123;1 =&gt; &quot;1&quot;, 3 =&gt; 3, 4 =&gt; 4&#125;。key&#x3D;4的键值对是在最后的，这标明了一种顺序，在set新值的时候，保持着一种先后顺序。 这个特性就是，Map的插入总是保持着先后顺序（删除了中间元素也会保持顺序），这和传统Hash并不一样。传统Hash是一种散列结构，元素并不具备顺序性，而Map很明显，后插入的元素就在最后，保持着这种先后顺序。 Hash本是哈希函数，表示为index = fn(key)，这里的fn就是哈希函数，它代表一种生成地址的规则，一般有直接定制法、数组分析法、平方取中法等等，这离本篇文章跑远了，哈希算法哪种好，已经在计算机算法中有所研究，可以看https://blog.csdn.net/u011109881/article/details/80379505我们模拟Map的数据结构，就需要自己制定一个Hash函数。 Hash是一段连续的有限的内存空间，根据散列函数H(key)和处理冲突的方法将一组关键字映射到一个有限的连续的地集（区间）上，并以关键字在地址集中的”象”作为记录在表中的存储位置，这种表就是散列表，这一映象过程称为散列造表或散列，所得的额存储位置称散列地址。 我们可以捋捋思路了，根据上文，Map底层使用了Hash毋庸置疑，但保持顺序这个特性，我猜测Map的底层使用了链表数据结构（链表是前一个结点的next指针指向后一个结点），所以Map的底层数据结构，使用了Hash + 链表实现。 Map可以保证顺序，也可以使用O(1)的时间复杂度来找到某个元素，所以我们初步方案，Hash的散列表存储Map中的数据，同时每个结点存入的先后顺序使用链表的形式表示。 我画了两张示意图，表示数据结构的一种基本实现和删除某个结点时的实现，如下： 图中，我为了简化默认散列表的长度是6，插入节点时，我们使用Hash()函数，根据传入的key，获取一个应该插入的位置index，比如第一个结点①，得出index&#x3D;1，那么放入位置，再放一个结点②，得出index,这里要有一个指针(next)，从①指向②，这样才能保证Map中数据的顺序，然后是插入结点③。插入结点④的时候，通过Hash函数，得出和①结点相同的位置，这种现象叫做Hash碰撞，碰撞是不可避免的，好的Hash函数应该尽可能少的出现碰撞，更加平均的使用散列表。出现了碰撞，怎么处理呢，这里我选择使用指针，连接①结点和④结点，这样在同一个位置，会映射多个结点。（理论上应该尽可能少的碰撞，否则影响查找速度），按照这样的规律，依次创建了结点⑤和结点⑥ 删除某个结点时，传入要删除的key，通过Hash函数，非常快的找到所在位置，不需要遍历。然而我们说了Map的值的插入是有顺序的，比如删除结点②，为了保持这种顺序性，我们使用链表的特性，把结点②的前一个结点①的next指针指向结点③。这里不需要移动结点什么，只是改变一下指针的指向，所以操作非常快 像Map的其他操作，比如get(key) 就很容易了，关键是理解上面的两个图模型。好了，接下来用Javascript原生来模拟一个Map数据结构，上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201class ListNode &#123; constructor(key, value) &#123; this.key = key; this.value = value; this.next = null; //记录插入顺序 this.ne = null; //记录Hash碰撞后的结点 &#125;&#125;function myMap() &#123; this.init()&#125;myMap.prototype.init = function()&#123; this.collection = new Array(6) //map底层用了hash算法。假如使用collection容器存放map中的数据 for (let i = 0; i &lt; this.collection.length; i++) &#123; this.collection[i] = Object.create(null) this.collection[i].ne = null; this.collection[i].next = null; &#125; this.size = 0 this.head = null; //头指针，总是指向第一个 this.tail = null; //尾指针，总是指向最后一个&#125;//插入或更新key结点myMap.prototype.set = function (key, value) &#123; let index = this.hash(key) //获取容器中的位置 let node = this.collection[index] //获得index位置处的对象 while (node.ne) &#123; if (node.ne.key === key) &#123; node.ne.value = value //更新 return this //注意返回当前对象this &#125; else &#123; node = node.ne &#125; &#125; //map中没有该key，就在链表尾部插入 let new_node = new ListNode(key, value) node.ne = new_node if (!this.tail) &#123; this.tail = new_node &#125; if (!this.head) &#123; this.head = new_node //如果是第一个结点，头指针指向它 &#125; this.tail.next = new_node //尾指针 this.tail = new_node this.size++ return this //注意返回当前对象this&#125;//获取key结点的值myMap.prototype.get = function (key) &#123; let index = this.hash(key) let node = this.collection[index] //获取容器相应位置处的对象 while (node) &#123; if (node.key === key) &#123; return node.value &#125; else &#123; node = node.ne &#125; &#125; return undefined&#125;//删掉key结点myMap.prototype.delete = function (key) &#123; if (!this.head) &#123; return false &#125; //从容器中删除 let index = this.hash(key) let node = this.collection[index] let pre = null; while (node.ne) &#123; if (node.ne.key === key) &#123; let _prev = node; //从链表中删除，需要前置结点 let _node = node.ne //保存要删除的结点 _prev.ne = node.ne.ne//从容器中删除，前置结点的指针指向要删除结点的指针 //从链表中删除 if (this.head === _node) &#123; //如果要删除的结点是头结点 this.head = _node.next; &#125; else if (this.tail === _node) &#123; //如果要删除的结点时尾结点 this.tail = _prev; //将尾指针指为前置结点 _prev.next = null; //将前置结点的指针置为空 &#125; else &#123; let cur = this.head; while (cur) &#123; if (cur.key !== key) &#123; pre = cur; cur = cur.next; &#125; else &#123; break &#125; &#125; pre.next = cur.next &#125; this.size-- return true; &#125; else &#123; node = node.ne &#125; &#125; return false&#125;myMap.prototype.has = function (key) &#123; let index = this.hash(key) let node = this.collection[index] while (node.ne) &#123; if (node.ne.key === key) &#123; return true &#125; else &#123; node = node.ne &#125; &#125; return false&#125;//返回键名的遍历器myMap.prototype.keys = function* () &#123; let head = this.head // 遍历链表，把链表中所有Key放入生成器中 while (head) &#123; if (head.key) &#123; yield head.key &#125; head = head.next &#125;&#125;//返回键值的遍历器myMap.prototype.values = function* () &#123; let head = this.head; while (head) &#123; if (head.value) &#123; yield head.value &#125; head = head.next &#125;&#125;//返回所有成员 遍历器myMap.prototype.entries = function* () &#123; let head = this.head; while (head) &#123; if (head.key) &#123; yield [head.key, head.value] &#125; head = head.next &#125;&#125;myMap.prototype[Symbol.iterator] = myMap.prototype.entries //默认遍历器接口，for of使用//返回Map的所有成员，接受一个函数作为第一个参数，第二个参数是thisArg 如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。myMap.prototype.forEach = function (callbackFn, thisArg) &#123; let head = this.head while (head) &#123; if (head.key) &#123; callbackFn.call(thisArg, head.key, head.value, this) head = head.next &#125; &#125;&#125;myMap.prototype.clear = function () &#123; this.init()&#125;/** * @param any key * @return &#123;number&#125; *///Hash 方法，Hash的算法我自己模拟一个，真正实践中的Hash算法肯定十分复杂myMap.prototype.hash = function (key) &#123; let index = 0; if (typeof key === &#x27;string&#x27;) &#123; //字符串的话取前10位，也没必要全部遍历完字符串，会影响性能、计算时间 for (let i = 0; i &lt; 10; i++) &#123; index += isNaN(key.charCodeAt(i)) ? 0 : key.charCodeAt(i) &#125; &#125; else if (typeof key === &#x27;number&#x27;) &#123; index = isNaN(key) ? this.collection.length - 1 : key % this.collection.length &#125; else if (typeof key === &#x27;object&#x27;) &#123; // 如果传入的是一个对象作为键，es6中的Map，底层Hash算法一定跟它的内存地址有关，因为取值时，比较的是是否是同一个引用。就算给了一个字面量相同的值，也不能取到值，必须试试引用相同的值才能取到 // 这里我只能模拟key为对象时，经Hash算法得到的都是index=0了 index = 0 &#125; else if (typeof key === &#x27;undefined&#x27;) &#123; index = 1 &#125; else if (typeof key === &#x27;boolean&#x27;) &#123; index = 2 &#125; return index % this.collection.length&#125; 由于要注意的细节太多，所以我加上了注释，一定要好好看注释啊～ 先说一句前提Javascript底层是用c&#x2F;c++写的，为什么这么说呢？因为ES6的Map可以用对象作为键，那么在计算机底层，肯定是和传入对象的内存地址有关系的，Map取值时，如果是引用类型，必须是相同的内存地址才可以取到。 综上，模拟的主要思路是，用Hash思想来存储数据，达到O(1)的查找时间，用链表思想来维持插入数据的先后顺序。细节点是，Hash的碰撞处理，我是自己模拟Hash函数，因为Javascript底层是用c&#x2F;c++写的，所以用js写只能是叫”模拟”。我还用了单链表来处理碰撞，通过ne指针，可以取到碰撞的后续值，这样有个隐藏问题是，当碰撞多了，Map的查找速度会慢，其实也可以用数组来处理碰撞，好处是Map查找速度会快那么点。 多说一句，在计算机领域Hash碰撞算是一个课题，如果要深入研究都可以写篇论文了。Hash函数也有很多种，但以哪种算法为准，则要看使用场景，不过最终目标是一样的，就是减少碰撞，均匀使用每个存储地址。 来验证一下结果吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243let m = new myMap();m.set(&#x27;a&#x27;, 1).set(&#x27;b&#x27;, 2)console.log(m.get(&#x27;a&#x27;), m.get(&#x27;b&#x27;)) //1 2let obj = &#123;name: &#x27;lolita&#x27;&#125;let obj2 = &#123;name: &#x27;obj2&#x27;&#125;m.set(obj, &#x27;obj&#x27;)m.set(obj2, &#x27;obj2&#x27;)console.log(m.get(obj)) //objconsole.log(m.size) //4console.log(m.delete(&#x27;a&#x27;)) //trueconsole.log(m.delete(&#x27;a&#x27;)) //false,因为&#x27;a&#x27;已经被删除过了console.log(m.delete(obj)) //trueconsole.log(m.get(obj2)) // obj2for (let key of m.keys()) &#123; console.log(&#x27;key:&#x27;, key) //key: b key: &#123; name: &#x27;obj2&#x27; &#125;&#125;for (let value of m.values()) &#123; console.log(&#x27;value:&#x27;, value) //value: 2 value: obj2&#125;for (let item of m.entries()) &#123; console.log(item[0], item[1]) //b 2 &#123; name: &#x27;obj2&#x27; &#125; &#x27;obj2&#x27; &#125;for (let [key, value] of m) &#123; console.log(key, value); //b 2 &#123; name: &#x27;obj2&#x27; &#125; &#x27;obj2&#x27;&#125;let ooo = &#123;name: &#x27;Jack&#x27;&#125;m.forEach(function (key, value, map) &#123; console.log(&quot;key: %s, value: %s&quot;, key, value) console.log(this) //forEach第二个参数不写或者null或者undefined，this都会是全局对象&#125;, ooo)//key: b, value: 2 &#123; name: &#x27;Jack&#x27; &#125;// key: [object Object], value: obj2 &#123; name: &#x27;Jack&#x27; &#125;console.log(m.clear()) //undefined 经过验证，完全符合预期结果，可以说模拟是到位的，欧耶～ Question: 为什么底层用Hash表示，用对象不行吗？不行，对象虽然也可以达到get set的效果，但是在遍历时，使用 for … in 或者Object.keys()都会按升序自动排序问题 怎么模拟内存地址生成过程呢？ 12345678let generator = function* RandomRefFun() &#123; const random = Math.random().toString(16).slice(2,8) yield `0x$&#123;random&#125;`;&#125; let RandomRefFun = generator() let randomRef = RandomRefFun().next().value 参考链接： https://es6.ruanyifeng.com/#docs/set-map#Map https://dev.to/arthurbiensur/kind-of-getting-the-memory-address-of-a-javascript-object-2mnd 百度百科-哈希","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"异步操作和Async函数","slug":"异步操作和Async函数","date":"2020-03-19T16:00:00.000Z","updated":"2024-10-12T08:40:56.548Z","comments":true,"path":"2020/03/20/异步操作和Async函数/","permalink":"https://justsso1.github.io/2020/03/20/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%92%8CAsync%E5%87%BD%E6%95%B0/","excerpt":"","text":"PromiseGenerator函数协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。期中有一种叫做”协程”（coroutine），意思是多个线程互相写作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下： 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。举例来说，读取文件的协程写法如下： 12345function *asyncJob() &#123; // 其他代码 var f = yield readFile(fileA) // 其他代码&#125; 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大有点，就是代码的写法非常像同步，如果去除yield命令，简直一模一样。 Generator函数的概念Generator函数的数据交换和错误处理Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使他可以作为异步编程的完整解决方案：函数体内外的数据叫唤和错误处理机制。 next方法返回值的value属性，是Generator函数向外输出数据，next方法还可以接受参数，这是向Generator函数体内输入数据。 12345678910function* gen(x)&#123; var y = yield x +2; return y;&#125;var g = gen(1);g.next() //&#123; value: 3, done: false &#125;g.next(2) //&#123; value: 2, done: true &#125; 上面代码中，第一个next方法的value属性，返回表达式x + 2的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。 Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 1234567891011121314function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw(&#x27;出错了&#x27;);// 出错了 上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 123456789var fetch = require(&#x27;node-fetch&#x27;);function* gen()&#123; var url = &#x27;https://api.github.com/users/github&#x27;; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 123456789var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 Thunk函数参数的求职策略争议Thunk函数早在上个世纪60年代就诞生了。那时，编程语言刚放起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底该何时求值。 传值调用 传名调用各有利弊，传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。现在的C语言采用的是传值调用。传值调用有时候造成性能损失，所以有一些计算机科学家倾向于”传名调用”，即只在执行时求值。 Thunk函数的意义传名调用有它存在的道理和实现，虽然现在C JavaScript使用的是传值调用，但是传名调用还是有一定的使用范围的。 编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。 12345678910111213141516function f(m)&#123; return m * 2;&#125;f(x + 5);// 等同于var thunk = function () &#123; return x + 5;&#125;;function f(thunk)&#123; return thunk() * 2;&#125; 上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。 JavaScript语言的Thunk函数JavaScript语言是传值调用，它的Thunk函数含义有所不同。** 在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，** 且只接受回调函数作为参数。 Thunkify模块生产环境大的转换器，建议使用Thunkify模块。 首先是安装。 12345678910$ npm install thunkify使用方式如下。var thunkify = require(‘thunkify’);var fs = require(‘fs’);var read = thunkify(fs.readFile);read(‘package.json’)(function(err, str)&#123;// …&#125;); Thunkify的源码与上一节那个简单的转换器非常像。 123456789101112131415161718192021222324252627function thunkify(fn)&#123;return function()&#123;var args = new Array(arguments.length);var ctx = this;for(var i = 0; i &lt; args.length; ++i) &#123; args[i] = arguments[i];&#125;return function(done)&#123; var called; args.push(function()&#123; if (called) return; called = true; done.apply(null, arguments); &#125;); try &#123; fn.apply(ctx, args); &#125; catch (err) &#123; done(err); &#125;&#125;&#125;&#125;; 它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。 12345678910function f(a, b, callback)&#123;var sum = a + b;callback(sum);callback(sum);&#125;var ft = thunkify(f);var print = console.log.bind(console);ft(1, 2)(print);// 3 上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果 Generator函数的流程管理Thunk函数现在可以用于Generator函数的自动流程管理 Geneerator函数可以自动执行。 1234567891011function* gen() &#123; // ***&#125;var g = gen();var res = g.next();while(!res.done)&#123; console.log(res.value) res = g.next()&#125; 上面代码中，Generator函数gen会自动执行完所有步骤。 但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这是，Thunk函数就能派上用场。以读取文件为例。下面的Generator函数封装了两个异步操作。 123456789var fs = require(&#x27;fs&#x27;);var thunkify = require(&#x27;thunkify&#x27;);var readFile = thunkify(fs.readFile);var gen = function* ()&#123; var r1 = yield readFile(&#x27;/etc/fstab&#x27;); &#125; Thunk函数的自动流程管理Thunk函数的真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。 Thunk函数的Generator执行器。 1234567891011121314151617function run(fn) &#123; var gen = fn(); function next(err,data) &#123; var result = gen.next(data); if(result.done)&#123; return ; &#125; result.value(next) &#125;&#125;function* g()&#123; // ...&#125;run(g) 上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束(result.done属性)，如果没结束，就将next函数再传入Thunk函数（result.value）属性，否则就直接退出。 有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。 12345678var g = function* () &#123; var f1 = yield readFile(&#x27;fileA&#x27;) var f2 = yield readFile(&#x27;fileB&#x27;) // ... var fn = yield readFile(&#x27;fileN&#x27;)&#125;run(g) 上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。 Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise对象也可以做到这一点。 co模块基本用法co模块用于Generator函数的自动执行。 co模块的原理为什么co可以自动执行Generator函数？前面说过，Generator就是一个异步操作的容器。它的自定执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。 回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。Promise对象。将异步操作包装成Promise对象，用then方法交回执行权。co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise函数。 基于Promise对象的自动执行还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。 1234567891011121314151617var fs = require(&#x27;fs&#x27;)var readFile = function (fileName)&#123; return new Promise(function (resolve,reject)&#123; fs.readFile(fileName, function(error, data)&#123; if(error) return reject(error) resolve(data) &#125;) &#125;) &#125;var gen = function* ()&#123; var f1 = yield readFile(&#x27;/etc/fstab&#x27;) var f2 = yield readFile(&#x27;/etc/shells&#x27;) console.log(f1.toString()) console.log(f2.toString())&#125; 然后，手动执行上面的Generator函数。 1234567var g = gen();g.next().value.then(function (data)&#123; g.next(data).value.then(function(data)&#123; g.next(data) &#125;)&#125;) 手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。 123456789101112131415function run(gen)&#123; var g = gen(); function next(data)&#123; var result = g.next(data); if (result.done) return result.value; result.value.then(function(data)&#123; next(data); &#125;); &#125; next();&#125;run(gen); 上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。 co模块的源码async函数含义ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。 前文有一个Generator函数，依次读取两个文件。 Javascriptvar fs &#x3D; require(‘fs’); var readFile &#x3D; function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) reject(error); resolve(data); }); });}; var gen &#x3D; function* (){ var f1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’); var f2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’); console.log(f1.toString()); console.log(f2.toString());};写成async函数，就是下面这样。 Javascript var asyncReadFile &#x3D; async function (){ var f1 &#x3D; await readFile(‘&#x2F;etc&#x2F;fstab’); var f2 &#x3D; await readFile(‘&#x2F;etc&#x2F;shells’); console.log(f1.toString()); console.log(f2.toString());};一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。 async 函数对Generator函数的改进，体现在以下四点。 内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。Javascriptvar result &#x3D; asyncReadFile();上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果，这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。 更好的语义。async和await，比起型号和yield，语义更清楚了。async表示函数里有异步操作，asait表示跟在后面的表达式需要等待结果。更广的适用性。co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。返回值是Promise。async函数的返回值是Promise对象，这比Geneerator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成一个Promise对象，而await命令就是内部then命令的语法糖。 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 async函数返回一个Promise对象。async函数内部return语句返回的值，会成为then方法中回调函数的参数。 Javascriptasync function f(){ return ‘hello world’;} f().then(v &#x3D;&gt; console.log(v))上面代码中，函数f内部return 命令返回的值，会被then方法回调函数接收到。 async函数内部抛出错误，会导致返回的Promise对象变成reject状态。抛出的错误对象会被catch方法回调函数接收到。 Javascriptasync function f(){ throw new Error(‘出错了’)} f().then(v &#x3D;&gt; console.log(v), e &#x3D;&gt; console.log(e)) &#x2F;&#x2F;Error: 出错了async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。 正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。 async函数的实现async函数的实现，就是将Generator函数和自动执行器，包装在一个函数里。 Javascriptasync function fn(args){ &#x2F;&#x2F; …} &#x2F;&#x2F;等同于 function fn(args){ return spawn(function*() { &#x2F;&#x2F; … })}所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。下面给出spawn函数的实现，基本就是前文自动执行器的翻版。 Javascriptfunction spawn(){ return new Promise(function (resolve, reject){ var gen &#x3D; genF(); function step(nextF) { try{ var next &#x3D; nextF(); } catch(e){ return reject(e) } } if(next.done)&#123; return resolve(next.value) &#125; Promise.resolve(next.value).then(function (v)&#123; step(function () &#123; return gen.next(v);&#125;); &#125;, function (e)&#123; step(function ()&#123; return gen.throw(e)&#125;) &#125;) step(function()&#123;return gen.next(undefined);&#125;) &#125;) }async函数是非常新的语法功能，新到不属于ES6,而是属于ES7。目前，它仍处于提案阶段，但是转码器Babel和regenerator都已经支持，转码后就能使用。 async 函数的用法async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到 await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 下面是一个例子。 Javascriptasync function getStockPriceByName(name) { var symbol &#x3D; await getStockSymbol(name); var stockPrice &#x3D; await getStockPrice(symbol); return stockPrice;} getStockPriceByName(‘goog’).then(function (result) { console.log(result);});上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。不过是pending状态的Promise,在then中才会是resolve状态的Promise. Async函数有多种使用形式。 Javascript&#x2F;&#x2F; 函数声明async function foo() {} &#x2F;&#x2F;函数表达式const foo &#x3D; async function (){} &#x2F;&#x2F;对象的方法let obj &#x3D; {async foo(){}}obj.foo().then(…) &#x2F;&#x2F; Class的方法 class Storage{ constructor() { this.cacchePromise &#x3D; caches.opeen(‘avatars’); } async getAvatar(name) &#123; const cache = await this.cacchePromise; return cache.match(&#39;/avatars/$&#123;name&#125;.jpg&#39;) &#125; } const storage &#x3D; new Storage();storage.getAvatar(‘jake’).then(..) &#x2F;&#x2F;箭头函数const foo &#x3D; async () &#x3D;&gt; {}注意点第一点，await命令后面的Promise对象，运行结果可能是rejected，随意最好把await命令放在try … catch代码块中。 Javascriptasync function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); }} &#x2F;&#x2F; 另一种写法 async function myFunction() { await somethingThatReturnsAPromise() .catch(function (err) { console.log(err); };}第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 Javascript let foo &#x3D; await getFoo();let bar &#x3D; await getBar();上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 Javascript &#x2F;&#x2F; 写法一let [foo, bar] &#x3D; await Promise.all([getFoo(), getBar()]); &#x2F;&#x2F; 写法二let fooPromise &#x3D; getFoo();let barPromise &#x3D; getBar();let foo &#x3D; await fooPromise;let bar &#x3D; await barPromise;上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。 async function dbFuc(db) {let docs &#x3D; [{}, {}, {}]; &#x2F;&#x2F; 报错docs.forEach(function (doc) {await db.post(doc);});}上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。 async function dbFuc(db) {let docs &#x3D; [{}, {}, {}]; &#x2F;&#x2F; 可能得到错误结果docs.forEach(async function (doc) {await db.post(doc);});}上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 Javascript async function dbFuc(db) { let docs &#x3D; [{}, {}, {}]; for (let doc of docs) { await db.post(doc); }}如果确实希望多个请求并发执行，可以使用Promise.all方法。 async function dbFuc(db) {let docs &#x3D; [{}, {}, {}];let promises &#x3D; docs.map((doc) &#x3D;&gt; db.post(doc)); let results &#x3D; await Promise.all(promises);console.log(results);} &#x2F;&#x2F; 或者使用下面的写法 async function dbFuc(db) {let docs &#x3D; [{}, {}, {}];let promises &#x3D; docs.map((doc) &#x3D;&gt; db.post(doc)); let results &#x3D; [];for (let promise of promises) {results.push(await promise);}console.log(results);} ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。 与Promise、Generator的比较Promise API（then catch等等）太多，操作本身的语义反而不容易看出来。 Generator函数语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。 Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因为代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。 实例：按顺序完成异步操作","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"axios中文文档","slug":"axios中文文档","date":"2020-03-17T16:00:00.000Z","updated":"2024-10-12T08:40:56.538Z","comments":true,"path":"2020/03/18/axios中文文档/","permalink":"https://justsso1.github.io/2020/03/18/axios%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/","excerpt":"","text":"axios中文文档什么是axios?Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中。 特性从浏览器中创建XMLHttpRequests从node.js创建http请求支持Promise API拦截请求和响应转换请求数据和响应数据取消请求自动转换JSON 数据客户端支持防御XSRFaxios APIaxios(config)axios(url[,config])请求方法的别名axios.request(config)axios.get(url[,config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])注意在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable)axios.spread(callback)创建实例可以使用自定义配置新建一个axios实例。 使用 axios.create([config]) 方法创建 Javascriptconst instance &#x3D; axios.create({ baseURL: ‘https://some-domain.com/api/‘, timeout: 1000, headers: {‘X-Custom-Header’: ‘foobar’}});实例方法 以下是可用的实例方法。指定的配置将与实例的配置合并。 axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])请求配置这些是创建请求时可以用的配置选项。只有url是必须的。如果没有指定method,请求将默认使用get方法。 Javascript{ &#x2F;&#x2F; ‘url’是用于请求的服务器URL url: ‘&#x2F;user’, &#x2F;&#x2F;method 是创建请求时的使用的方法 method: ‘get’, &#x2F;&#x2F; baseURL 将自动加在url前面，除非url是一个绝对URL baseURL: ‘https://some-domain.com/api/‘, &#x2F;&#x2F; transformRequest 允许向服务器发送前，修改请求数据 &#x2F;&#x2F;只能用在PUT POST 和PATCH 这几个请求方法 &#x2F;&#x2F; 后面数组中的函数必须返回一个字符串，或ArrayBuffer或Stream transformRequest: [function (data, headers) { &#x2F;&#x2F;对data 进行任意转换处理 return data; }], transformResponse: [function(data) { &#x2F;&#x2F;对data 进行任意转换处理 return data; }], &#x2F;&#x2F;headers 是即将被发送的自定义请求头 headers: {‘X-Requested-With’: ‘XMLHttpRequest’}, &#x2F;&#x2F;params 是即将与请求一起发送的URL参数 &#x2F;&#x2F;必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID : 213 },&#x2F;&#x2F; paramsSerializer 是一个负责 params 序列化的函数 &#x2F;&#x2F; (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: ‘brackets’}) }, &#x2F;&#x2F; data 是作为请求主体被发送的数据 &#x2F;&#x2F; 只适用于这些请求方法 ‘PUT’, ‘POST’, 和 ‘PATCH’ &#x2F;&#x2F; 在没有设置 transformRequest 时，必须是以下类型之一： &#x2F;&#x2F; - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams &#x2F;&#x2F; - 浏览器专属：FormData, File, Blob &#x2F;&#x2F; - Node 专属： Stream data: { firstName: ‘Fred’ },&#x2F;&#x2F; timeout 指定请求超时的毫秒数(0 表示无超时时间) &#x2F;&#x2F; 如果请求话费了超过 timeout 的时间，请求将被中断 timeout: 1000, &#x2F;&#x2F; withCredentials 表示跨域请求时是否需要使用凭证 withCredentials: false, &#x2F;&#x2F; default &#x2F;&#x2F; adapter 允许自定义处理请求，以使测试更轻松 &#x2F;&#x2F; 返回一个 promise 并应用一个有效的响应 (查阅 response docs). adapter: function (config) { &#x2F;* … *&#x2F; }, &#x2F;&#x2F; auth 表示应该使用 HTTP 基础验证，并提供凭据 &#x2F;&#x2F; 这将设置一个 Authorization 头，覆写掉现有的任意使用 headers 设置的自定义 Authorization头 auth: { username: ‘janedoe’, password: ‘s00pers3cret’ }, &#x2F;&#x2F; responseType 表示服务器响应的数据类型，可以是 ‘arraybuffer’, ‘blob’, ‘document’, ‘json’, ‘text’, ‘stream’ responseType: ‘json’, &#x2F;&#x2F; default &#x2F;&#x2F; responseEncoding indicates encoding to use for decoding responses &#x2F;&#x2F; Note: Ignored for responseType of ‘stream’ or client-side requests responseEncoding: ‘utf8’, &#x2F;&#x2F; default &#x2F;&#x2F; xsrfCookieName 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: ‘XSRF-TOKEN’, &#x2F;&#x2F; default &#x2F;&#x2F; xsrfHeaderName is the name of the http header that carries the xsrf token value xsrfHeaderName: ‘X-XSRF-TOKEN’, &#x2F;&#x2F; default &#x2F;&#x2F; onUploadProgress 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { &#x2F;&#x2F; Do whatever you want with the native progress event }, &#x2F;&#x2F; onDownloadProgress 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { &#x2F;&#x2F; 对原生进度事件的处理 }, &#x2F;&#x2F; maxContentLength 定义允许的响应内容的最大尺寸 maxContentLength: 2000, &#x2F;&#x2F; validateStatus 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 validateStatus 返回 true (或者设置为 null 或 undefined)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;&#x3D; 200 &amp;&amp; status &lt; 300; &#x2F;&#x2F; default }, &#x2F;&#x2F; maxRedirects 定义在 node.js 中 follow 的最大重定向数目 &#x2F;&#x2F; 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, &#x2F;&#x2F; default &#x2F;&#x2F; socketPath defines a UNIX Socket to be used in node.js. &#x2F;&#x2F; e.g. ‘&#x2F;var&#x2F;run&#x2F;docker.sock’ to send requests to the docker daemon. &#x2F;&#x2F; Only either socketPath or proxy can be specified. &#x2F;&#x2F; If both are specified, socketPath is used. socketPath: null, &#x2F;&#x2F; default &#x2F;&#x2F; httpAgent 和 httpsAgent 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： &#x2F;&#x2F; keepAlive 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), &#x2F;&#x2F; ‘proxy’ 定义代理服务器的主机名称和端口 &#x2F;&#x2F; auth 表示 HTTP 基础验证应当用于连接代理，并提供凭据 &#x2F;&#x2F; 这将会设置一个 Proxy-Authorization 头，覆写掉已有的通过使用 header 设置的自定义 Proxy-Authorization 头。 proxy: { host: ‘127.0.0.1’, port: 9000, auth: { username: ‘mikeymike’, password: ‘rapunz3l’ } }, &#x2F;&#x2F; cancelToken 指定用于取消请求的 cancel token &#x2F;&#x2F; （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { })}插曲：我们在做jwt验证时，通常会在request的header中添加一个token，是这样写的: Javascriptconst token &#x3D; window.sessionStorage.getItem(“token”);if (token) { config.headers.Authorization &#x3D; Bearer $&#123;token&#125;;}那么这个token的认证和上文配置中的auth有什么关联呢？ 原来auth 是进行的http用户验证，token是进行的我们自己系统的认证，是两码事。 auth 认证后的header信息一般是这样的：Authorization: Basic dWVub3NlbjpwYXNzd29yZA&#x3D;&#x3D;首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证 书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存 在接收到含有 Authorization 首部字段的请求时的操作处理会略有差 异认证方案是Basic,auth用的比较少。 配置默认值你可以指定将被用在各个请求的配置默认值 全局的axios默认值Javascriptaxios.defaults.baseURL &#x3D; ‘https://api.example.com‘;axios.defaults.headers.common[‘Authorization’] &#x3D; Auth_TOKEN;axios.defaults.head.post[‘Content-Type’] ‘application&#x2F;x-wwww-form-url’;自定义实例默认值有两种方式 Javascript &#x2F;&#x2F;1.当你创建实例的时候，就在配置config中写明const instance &#x3D; axios.create({ baseURL: ‘https://api.example.com‘}) &#x2F;&#x2F;2. 在创建实例之后，再去修改instance.defaults.headers.common[‘Authrization’] &#x3D; AUTH_TOKEN;配置的优先顺序请求配置 &gt; 实例配置 &gt; 默认配置 拦截器在请求或响应被then或catch处理前拦截它们。 Javascript&#x2F;&#x2F; 添加请求拦截器 axios.interceptors.request.use(function (config) { &#x2F;&#x2F; 在发送请求之前做些什么 return config;}, function (error){ &#x2F;&#x2F;对请求错误做些什么 return Promise.reeject(error)}) &#x2F;&#x2F; 添加响应拦截器axios.interceptors.response.use(function (response){ &#x2F;&#x2F; 对响应数据做点什么 return response;}, function (error){ &#x2F;&#x2F;对响应错误做点什么 return Promise.reject(error)})如果你想在稍后移除拦截器，可以这样： Javascript const myInterceptor &#x3D; axios.interceptors.request.use(function () {&#x2F;**&#x2F;})axios.interceptors.request.eject(myInterceptor);可以为自定义axios实例添加拦截器 Javascriptconst instance &#x3D; axios.create();instance.interceptors.request.use(function(){&#x2F;**&#x2F;})错误处理Javascriptaxios.get(‘&#x2F;user&#x2F;12345’) .catch(function (error) { if (error.response) { &#x2F;&#x2F; The request was made and the server responded with a status code &#x2F;&#x2F; that falls out of the range of 2xx console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else if (error.request) { &#x2F;&#x2F; The request was made but no response was received &#x2F;&#x2F; error.request is an instance of XMLHttpRequest in the browser and an instance of &#x2F;&#x2F; http.ClientRequest in node.js console.log(error.request); } else { &#x2F;&#x2F; Something happened in setting up the request that triggered an Error console.log(‘Error’, error.message); } console.log(error.config); });可以使用validateStatus配置选项定义一个自定义HTTP状态码的错误范围。 Javascriptaxios.get(‘&#x2F;user&#x2F;12345’, { validateStatus: function (status) { return status &lt; 500 }})取消使用cancel token取消请求 Axios的cancel token API基于cancelable promises proposal,它还处于第一阶段。 可以使用CancelToken.source工厂方法创建cancel token，像这样： Javascriptconst CancelToken &#x3D; axios.CancelToken;const source &#x3D; CancelToken.source(); axios.get(‘&#x2F;user&#x2F;12345’, { cancelToken: source.token}).catch(function(){ if(axios.isCancel(thrown)) { console.log(‘Request cancled’, thrown.message); }else{ &#x2F;&#x2F;处理错误 }}) axios.post(‘&#x2F;user&#x2F;12345’, { name: ‘new name’}, { cancelToken: source.token}) &#x2F;&#x2F; 取消请求（message 参数是可选的）source.cancel(‘Operation canceled by the user.’);还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： Javascript const CancelToken &#x3D; axios.CancelToken;let cancel; axios.get(‘&#x2F;user&#x2F;12345’, { cancelToken: new CancelToken(function executor(c) { &#x2F;&#x2F; executor 函数接收一个 cancel 函数作为参数 cancel &#x3D; c; })}); &#x2F;&#x2F; cancel the requestcancel();注意: 可以使用同一个 cancel token 取消多个请求 使用 application&#x2F;x-www-form-urlencoded format默认情况下，axios将JavaScript对象序列化为JSON。 要以application &#x2F; x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。在浏览器和Node.js中要有不同的处理方法 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： Javascriptconst params &#x3D; new URLSearchParams(); params.append(‘param1’,’value1’);params.append(‘param2’,’value2’); axios.post(‘&#x2F;foo’, params);请注意，所有浏览器都不支持URLSearchParams（请参阅 caniuse.com）polyfill(确保填充全局环境) 或者，您可以使用qs库编码数据： Javascriptconst qs &#x3D; require(‘qs’);axios.post(‘&#x2F;foo’, qs.stringify({‘bar’: 123}));或者以另一种方式（ES6）， Javascript import qs from ‘qs’;const data &#x3D; { ‘bar’: 123 };const options &#x3D; { method: ‘POST’, headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ }, data: qs.stringify(data), url,};axios(options);Node.js在node.js中，您可以使用querystring模块，如下所示： Javascriptconst querystring &#x3D; require(‘querystring’);axios.post(‘http://something.com/‘, querystring.stringify({ foo: ‘bar’ }));您也可以使用qs库。 Pomisesaxios依赖原生的ES6 Promise 实现而被支持，如果你的环境不支持ES6 Promise可以使用polyfill TypeScriptaxios包括TypeScript定义。 Javascriptimport axios from ‘axios’;axios.get(‘&#x2F;user?ID&#x3D;12345’)赞扬axios 深受Angular提供的 $http服务的启发。最终，axios是为了在Angular之外使用而提供独立的类似$http服务的。 协议MIT","categories":[],"tags":[]},{"title":"Generator函数","slug":"Generator函数","date":"2020-03-14T16:00:00.000Z","updated":"2024-10-12T08:40:56.532Z","comments":true,"path":"2020/03/15/Generator函数/","permalink":"https://justsso1.github.io/2020/03/15/Generator%E5%87%BD%E6%95%B0/","excerpt":"","text":"Generator函数简介Generator函数是ES6提供的一种异步解决方案，语法行为与传统函数完全不同。从语法上讲，Generator函数是一个状态机，封装了多个内部状态。从形式上讲，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态执行Generator函数会返回一个遍历器对象，调用Generator函数后，该函数并不执行，返回的也不是函数运行的结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。 Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。注意，不要混淆遍历器对象的throw方法和全局的throw命令。全局的throw命令只能被函数体外的catch语句捕获。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield语句，可以只用一个 try…catch代码来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。 Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获。一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。 Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 Javascriptfunction* gen() { yield 1; yield 2; yield 3;} var g &#x3D; gen(); g.next() &#x2F;&#x2F; { value: 1, done: false }g.return(‘foo’) &#x2F;&#x2F; { value: “foo”, done: true }g.next() &#x2F;&#x2F; { value: undefined, done: true }上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。 yield* 语句在一个Generator函数里执行另一个Generator函数yield** 后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for…of循环。其实，yield*后面的Generator函数（没有return语句时），不过是for…of的一种简写形式，完全可以用后者替代前者。反之，则需要用var value = yield iterator的形式获取return语句的值。 如果yield后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。 实际上，任何数据结构只要有Iterator接口，就可以被yield遍历。 任何数据结构，只要有Iterator接口，就可以被 yield*遍历。 如果被代理的Generator有return语句，那么就可以向代理它的Generator函数返回数据。 yield*命令可以很方便的取出嵌套数组的成员。 Javascriptfunction* iterTree(tree) { if (Array.isArray(tree)) { for(let i&#x3D;0; i &lt; tree.length; i++) { yield* iterTree(tree[i]); } } else { yield tree; }} const tree &#x3D; [ ‘a’, [‘b’, ‘c’], [‘d’, ‘e’] ]; for(let x of iterTree(tree)) { console.log(x);}使用yield* 命令遍历完全二叉树。 Javascript next 方法的参数yield语句本身没有返回值，或者说总是返回undeefined.next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。 Javascriptfunction *f() { for (var i &#x3D; 0; true, i++){ var rest &#x3D; yield i; if(rest){ i &#x3D; -1; } }} var g &#x3D; f();g.next() &#x2F;&#x2F;{value: 0, done: false}g.next() &#x2F;&#x2F;{value: 1, done: false}g.next(true) &#x2F;&#x2F;{value: 0, doneL false}上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 作为对象属性的Generator函数如果一个对象的属性是Generator函数，可以简写成下面的形式。 Javascript let obj &#x3D; { myGeneratorMethod() {&#x2F;&#x2F;··· }}; &#x2F;&#x2F;等价let obj &#x3D; { myGeneratorMethod: function* () { &#x2F;&#x2F; ··· }};Generator函数返回的总是遍历器对象，而不是this对象。这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。 Generator函数不能跟new命令一起使用，会报错。 应用场景异步操作的同步化表达控制流管理部署Iterator接口，本质上是一样的，都是遍历器看作数据结构，确切的说，看作数组结构因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。Javascriptfunction *doStuff() { yield fs.readFile.bind(null, ‘hello.txt’); yield fs.readFile.bind(null, ‘world.txt’); yield fs.readFile.bind(null, ‘and-such.txt’);}上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。 Javascript for (task of doStuff()) { &#x2F;&#x2F; task是一个函数，可以像回调函数那样使用它}实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。 Javascriptfunction doStuff() { return [ fs.readFile.bind(null, ‘hello.txt’), fs.readFile.bind(null, ‘world.txt’), fs.readFile.bind(null, ‘and-such.txt’) ];}上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"Iterator和for...of循环","slug":"Iterator和for...of循环","date":"2020-03-11T16:00:00.000Z","updated":"2024-10-16T04:06:52.505Z","comments":true,"path":"2020/03/12/Iterator和for...of循环/","permalink":"https://justsso1.github.io/2020/03/12/Iterator%E5%92%8Cfor...of%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"Iterator和for…of循环Iterator和for（遍历器）概念 出现的原因ES6 中有4种表示”集合”的数据结构，主要是数组Array 对象Object Set Map，用户可以定义自己得数据结构，比如Set里嵌套Map,Map里嵌套Object，这样就需要一种统一的接口机制，来处理所有不同的数据结构。遍历器（Iterator）就是这样一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 2.Iterator的作用为各种数据结构，提供一个统一的、简便的访问接口使得数据结构的成员能够按某种次序排列ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费原生具备Iterator接口的数据结构在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。可以被for…of循环遍历，这些数据结构原生就部署了Symbol iterator属性，凡是部署了Symbol iterator属性的数据结构，就称为部署了遍历器接口，调用这个接口就会返回一个遍历器对象。 数据结构的默认Iterator接口遍历器的根本特征上是含有 next()方法。 当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。 一种数据结构只要部署了Iterator接口，我们就称这种数据结构是”可遍历的“（iterable）。 Javascriptlet arr &#x3D; [‘a’, ‘b’, ‘c’];let iter &#x3D; arrSymbol.iterator; iter.next() &#x2F;&#x2F; { value: ‘a’, done: false }iter.next() &#x2F;&#x2F; { value: ‘b’, done: false }iter.next() &#x2F;&#x2F; { value: ‘c’, done: false }iter.next() &#x2F;&#x2F; { value: undefined, done: true }上面提到，原生就部署Iterator接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们，执行遍历器对象的next()方法 除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。 对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。 一个对象如果要有可被for…of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 通过遍历器实现指针结构的例子： Javascriptfunction Object(value){ this.value&#x3D; value; this.next &#x3D; null;}Obj.prototype[Symbol.iterator] &#x3D; function() { var iterator &#x3D; { next: next }; var current &#x3D; this; function next() { if (current) { var value &#x3D; current.value; current &#x3D; current.next; return { done: false, value: value }; } else { return { done: true }; } } return iterator;} var one &#x3D; new Obj(1);var two &#x3D; new Obj(2);var three &#x3D; new Obj(3); one.next &#x3D; two;two.next &#x3D; three; for (var i of one){ console.log(i);}&#x2F;&#x2F; 1&#x2F;&#x2F; 2&#x2F;&#x2F; 3调用Iterator接口的场合有一些场合会默认调用Iterator接口（即Symbol.iterator方法），除了下文会介绍的for … of循环，还有几个别的场合。 解构赋值[first,… rest] 扩展运算符… yieldyield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 Javascript let generator &#x3D; function* () { yield 1; yield* [2,3,4]; yield 5;}; var iterator &#x3D; generator(); iterator.next() &#x2F;&#x2F; { value: 1, done: false }iterator.next() &#x2F;&#x2F; { value: 2, done: false }iterator.next() &#x2F;&#x2F; { value: 3, done: false }iterator.next() &#x2F;&#x2F; { value: 4, done: false }iterator.next() &#x2F;&#x2F; { value: 5, done: false }iterator.next() &#x2F;&#x2F; { value: undefined, done: true }4. 其他场合 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。 for…ofArray.from()Map() Set() WeakMap() WeakSet(),（比如new Map([[‘a’,1],[‘b’,2]])）Promise.all()Promise.race()字符串的Iterator接口Iterator接口与Generator函数Symbol.Iterator方法的最简单实现，还是使用一下Generator函数 Set Map结构Map遍历返回的是一个数组，0位是键名，1位是键值 与其他遍历语法的比较以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。 Javascript for (var index &#x3D; 0; index &lt; myArray.length; index++) { console.log(myArray[index]);}这种写法比较麻烦，因此数组提供内置的forEach方法。 Javascript myArray.forEach(function (value) { console.log(value);});这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 for…in循环可以遍历数组的键名。 Javascript for (var index in myArray) { console.log(myArray[index]);}for…in循环有几个缺点。 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。某些情况下，for…in循环会以任意顺序遍历键名。总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 for…of循环相比上面几种做法，有一些显著的优点。 Javascriptfor (let value of myArray) { console.log(value);}有着同for…in一样的简洁语法，但是没有for…in那些缺点。不同用于forEach方法，它可以与break、continue和return配合使用。提供了遍历所有数据结构的统一操作接口。下面是一个使用break语句，跳出for…of循环的例子。 Javascript for (var n of fibonacci) { if (n &gt; 1000) break; console.log(n);}上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for…of循环。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"Symbol","slug":"Symbol","date":"2020-03-11T16:00:00.000Z","updated":"2024-10-16T04:06:46.810Z","comments":true,"path":"2020/03/12/Symbol/","permalink":"https://justsso1.github.io/2020/03/12/Symbol/","excerpt":"","text":"Symbol一句话介绍Symbol：Symbol是ES6的第七种原始数据类型，(前六种是 Null Undefined Boolean String Number Object)，表示独一无二的值。 概述 出现的原因ES5对象的属性都是字符串类型，为了避免属性名冲突、不出现同名的属性，ES6创建了新的原始数据类型Symbol 如何获得一个Symbol值通过 Symbol函数创建，不能使用 new 命令，否则报错。因为生成的Symbol不是对象，而是一个原始数据类型，类似一种字符串的数据类型。 Javascriptlet s&#x3D; Symbol()typeof s&#x2F;&#x2F; “symbol”3. Symbol函数的参数有哪几种无参字符串， 用来描述(description) Symbol值对象，会调用对象的toString()，将其转化成字符串，用来描述Symbol值。4. Symbol 值的比较Symbol 函数中的参数，只是用来做描述符，（对程序员或者控制台有用，方便区分），但是没有任何两个 Symbol的值相等，Symbol代表独一无二的值。就算两个都无参的Symbol 或者参数相同的Symbol也是不相等的。 怎么成为对象的属性名使用方括号[] 或者 Object.defineProperty ，就可以使用一个Symbol值作为对象的属性。 Symbol值用作对象属性名时，不能用点操作符，因为点操作符后面总是字符串。 注意： Symbol作为对象属性时，是公开属性，不是私有属性。 实战： 魔术字符串 Javascript var shapeType &#x3D; { triangle: ‘Triangle’}; function getArea(shape, options) { var area &#x3D; 0; switch (shape) { case shapeType.triangle: area &#x3D; .5 * options.width * options.height; break; } return area;} getArea(shapeType.triangle, { width: 100, height: 100 });可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用Symbol值。 Javascriptconst shapeType &#x3D; { triangle: Symbol()};上面代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改。 属性名的遍历，妙用Symbol属性不能被常规的方法遍历到，for … in Object.getOwnPropertyNames() Object.keys() 都不能遍历到Symbol属性名，但是Object.getOwnPropertySymbols可以获取到Symbol属性名，所以利用这个特性我们可以做一些非私有的，但是又只想让内部访问到的属性名。 Symbol.for(), Symbol.keyFor()Symbol.for()也是会生成一个Symbol的值，但是和Symbol()有区别。Symbol.for()它会在全局环境中登录你创建的这个Symbol值，以供后面的Symbol.for()查找。所以Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。而Symbol()会每次返回一个新的Symbol值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 Javascriptvar s1 &#x3D; Symbol.for(“foo”);Symbol.keyFor(s1) &#x2F;&#x2F; “foo” var s2 &#x3D; Symbol(“foo”);Symbol.keyFor(s2) &#x2F;&#x2F; undefined需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 Javascriptiframe &#x3D; document.createElement(‘iframe’);iframe.src &#x3D; String(window.location);document.body.appendChild(iframe); iframe.contentWindow.Symbol.for(‘foo’) &#x3D;&#x3D;&#x3D; Symbol.for(‘foo’)&#x2F;&#x2F; true上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。 实战： 模块的 Singleton 模式 （Singleton n.独生子） 利用Symbol.for()在全局环境下只有一个，且要通过Symbol.keyFor()方法来找到。但是这个也存在一些问题，也不可靠，再议。 内置的Symbol值Symbol值可以自己定义之外，ES6 还提供了11个内置的Symbol值，指向语言内部使用的方法。 Symbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 Javascriptvar myIterator &#x3D; {}; myIterator[Symbol.iterator] &#x3D; function*(){ yield 1; yield 2; yield 3;} [… myIterator] &#x2F;&#x2F;[1,2,3] &#x2F;&#x2F;… 操作符，其实是使用了for of 将myIterator全部遍历一遍对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator和for…of循环》一章。 1234567891011121314151617181920class Collection &#123; *[Symbol.iterator]() &#123; let i = 0; while(this[i] !== undefined) &#123; yield this[i]; ++i; &#125; &#125;&#125;let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2;for(let value of myCollection) &#123; console.log(value);&#125;// 1// 2","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"cookie session jwt token","slug":"cookie session jwt token","date":"2020-03-11T16:00:00.000Z","updated":"2024-10-12T08:40:56.538Z","comments":true,"path":"2020/03/12/cookie session jwt token/","permalink":"https://justsso1.github.io/2020/03/12/cookie%20session%20jwt%20token/","excerpt":"","text":"cookie session jwt tokencookie 和session 结合认证token 认证jwt 认证扫码认证Oauth2 认证单点登录LDAP 认证cookie 、session重点： 在父域名下设置cookie，在他的二级子域名可以获取到，这样可以共享cookiecookie 应该设置httponly属性 ,防止跨站攻击XSSreadonly问题： 在于后台要存储session数据，数据量过大会是一种问题，如果用负载均衡，一旦那个负责session的机器挂了，就会出现问题，所有人的登录态就失效了JWT认证、Token认证JWT 全称是JSON Web Token，一种无状态的认证方式。 JWT解决的不是数据传输安全JWT解决的是服务端cookie 、session存储，这种前后端有状态的问题常用的Token和JWT认证是有一定差别的JWT和Token有一定的差别，JWT适合一次性验证，比方邮件激活，Token适合我们一般的API请求。 常见流程用户发起请求登录，服务端验证后，通过JWT生成一个Token，并返回给前端前端存储起来，一般存在sessionStorage中后续API请求都带上这个Token，服务端通过这个Token来验明身份Token有一个时效性，过了时间需要重新获取，所以一般前端会在Ajax的请求做个统一的intreceptors组成JavascriptHeader.Payload.SignatureHeader Javascript{ “alg”: “HS256”， &#x2F;&#x2F; 标记签名的算法 “typ”: “JWT”}Payload Javascript { “sub”: “1234567890”， &#x2F;&#x2F; payload 这里是存我们的方存放的用户信息 “name”: “John Doe”， “admin”: false， exp: number &#x2F;&#x2F; 过期时间 &#x2F;&#x2F; ……}Signature签名：密钥好好保存，伪代码展示： Javascriptconst signature &#x3D; HMACSHA256( base64UrlEncode(Header)+”.”+base64UrlEncode(Plyload)+”.”+ secret);res.send({signature: signature})因为 Header、Payload 实际是个 Base64 过的，所以拿到后经过 Base64 解码后是可以看到实际内容的，所以隐私数据不要放在 Payload 里，Payload 存放用户的基本信息，userId、userName、mail 啥的。 通常我么恩在调用后端API的时候，都只有一个常常的字符串，没有见到这个x.x.x的三段式阿？ 这是因为我们在客户端存储的事Token，即上文说的Signature 对于 API 请求 Header 这个其实是多余的，只要我的 Token 能唯一标记是哪个用户就可以，也不需要验签这个流程的，我只需要在 Redis 存储用户 和 Token 的关系就好，所以 JWT 和 Token 的差别是，JWT 不需要在后端存储用户和 Signature 的关系，只需要做个验签就可以所以 JWT 适合做一次行验证，比方邮箱激活账号，Token 适合做 API 请求认证。 2 者的差别就是 Token 需要服务端存储 Token 和用户的关系，JWT 不需要，这二者对于前端开发者来说，在调用方式上没有差别。 安全性相关 缩短 Token 有效时间secret 定时替换使用 HTTPS 加密协议对标准字段 iss、sub、aud、nbf、exp 进行校验参考：https://www.jianshu.com/p/8f7009456abc OAuth2 认证第三方登录","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"lodash常用方法","slug":"lodash常用方法","date":"2020-03-10T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2020/03/11/lodash常用方法/","permalink":"https://justsso1.github.io/2020/03/11/lodash%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"lodash常用方法Object_.get(object, path, [defaultValue]) 根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代。 添加版本3.7.0 参数 object (Object): 要检索的对象。 path (Array|string): 要获取属性的路径。 [defaultValue] (*): 如果解析值是 undefined ，这值会被返回。 返回 (*): 返回解析的值。 例子 Javascript var object &#x3D; { ‘a’: [{ ‘b’: { ‘c’: 3 } }] }; _.get(object, ‘a[0].b.c’);&#x2F;&#x2F; &#x3D;&gt; 3 _.get(object, [‘a’, ‘0’, ‘b’, ‘c’]);&#x2F;&#x2F; &#x3D;&gt; 3 _.get(object, ‘a.b.c’, ‘default’);&#x2F;&#x2F; &#x3D;&gt; ‘default’Array_.tail(array) 获取除了array数组第一个元素以外的全部元素。 添加版本4.0.0 参数array (Array): 要检索的数组。返回(Array): 返回 array 数组的切片（除了array数组第一个元素以外的全部元素）。 例子 Javascript_.tail([1, 2, 3]);&#x2F;&#x2F; &#x3D;&gt; [2, 3]Util_.flow([funcs]) 创建一个函数。 返回的结果是调用提供函数的结果，this 会绑定到创建函数。 每一个连续调用，传入的参数都是前一个函数返回的结果。 添加版本3.0.0 参数 [funcs] (…(Function|Function[])): 要调用的函数。 返回 (Function): 返回新的函数。 例子 Javascript function square(n) { return n * n;} var addSquare &#x3D; .flow([.add, square]);addSquare(1, 2);&#x2F;&#x2F; &#x3D;&gt; 9","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"由JS继承所想","slug":"由JS继承所想","date":"2020-03-08T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/03/09/由JS继承所想/","permalink":"https://justsso1.github.io/2020/03/09/%E7%94%B1JS%E7%BB%A7%E6%89%BF%E6%89%80%E6%83%B3/","excerpt":"","text":"由JS继承所想原型JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。 虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。 实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。 由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。 第一个不同之处在于 JavaScript 使用原型链的继承方式。 注意: 简单的使用 Bar.prototype = Foo.prototype 将会导致两个对象共享相同的原型。 因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。 1234567891011121314151617181920212223242526function Foo() &#123; this.value = 42;&#125;Foo.prototype = &#123; method: function() &#123;&#125;&#125;;function Bar() &#123;&#125;// 设置Bar的prototype属性为Foo的实例对象Bar.prototype = new Foo();Bar.prototype.foo = &#x27;Hello World&#x27;;// 修正Bar.prototype.constructor为Bar本身Bar.prototype.constructor = Bar;var test = new Bar() // 创建Bar的一个新实例// 原型链test [Bar的实例] Bar.prototype [Foo的实例] &#123; foo: &#x27;Hello World&#x27; &#125; Foo.prototype &#123;method: ...&#125;; Object.prototype &#123;toString: ... /* etc. */&#125;; 注意: 不要使用 Bar.prototype = Foo，因为这不会执行 Foo 的原型，而是指向函数 Foo。 因此原型链将会回溯到 Function.prototype 而不是 Foo.prototype，因此 method 将不会在 Bar 的原型链上。 上面的例子中，test 对象从 Bar.prototype 和 Foo.prototype 继承下来；因此， 它能访问 Foo 的原型方法 method。同时，它也能够访问那个定义在原型上的 Foo 实例属性 value。 需要注意的是 new Bar() 不会创造出一个新的 Foo 实例，而是 重复使用它原型上的那个实例；因此，所有的 Bar实例都会共享相同的 value 属性。 属性查找当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。 到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined。 原型属性当原型属性用来创建原型链时，可以把任何类型的值赋给它（prototype）。 然而将原子类型赋给 prototype 的操作将会被忽略。 12function Foo() &#123;&#125;Foo.prototype = 1; // 无效 而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。 性能如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。 并且，当使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问。 扩展内置类型的原型一个错误特性被经常使用，那就是扩展 Object.prototype 或者其他内置类型的原型对象。 这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些非标准的函数是个好主意。 扩展内置类型的唯一理由是为了和新的 JavaScript 保持一致，比如 Array.forEach。 总结在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。 更进一步，绝对不要扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。 hasOwnProperty 函数为了判断一个对象是否包含自定义属性而不是原型链上的属性， 我们需要使用继承自 Object.prototype 的 hasOwnProperty 方法。 注意: 通过判断一个属性是否 undefined 是不够的。 因为一个属性可能确实存在，只不过它的值被设置为 undefined。 hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。 123456789// 修改Object.prototypeObject.prototype.bar = 1; var foo = &#123;goo: undefined&#125;;foo.bar; // 1&#x27;bar&#x27; in foo; // truefoo.hasOwnProperty(&#x27;bar&#x27;); // falsefoo.hasOwnProperty(&#x27;goo&#x27;); // true 只有 hasOwnProperty 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。 hasOwnProperty 作为属性JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用外部的 hasOwnProperty 函数来获取正确的结果。 1234567891011var foo = &#123; hasOwnProperty: function() &#123; return false; &#125;, bar: &#x27;Here be dragons&#x27;&#125;;foo.hasOwnProperty(&#x27;bar&#x27;); // 总是返回 false// 使用其它对象的 hasOwnProperty，并将其上下文设置为foo(&#123;&#125;).hasOwnProperty.call(foo, &#x27;bar&#x27;); // true 结论当检查对象上某个属性是否存在时，hasOwnProperty 是唯一可用的方法。 同时在使用 for in loop 遍历对象时，推荐总是使用 hasOwnProperty 方法， 这将会避免原型对象扩展带来的干扰。 for in 循环和 in 操作符一样，for in 循环同样在查找对象属性时遍历原型链上的所有属性。 注意: for in 循环不会遍历那些 enumerable 设置为 false 的属性；比如数组的 length 属性。 1234567// 修改 Object.prototypeObject.prototype.bar = 1;var foo = &#123;moo: 2&#125;;for(var i in foo) &#123; console.log(i); // 输出两个属性：bar 和 moo&#125; 由于不可能改变 for in 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性， 这可以通过 Object.prototype 原型上的 hasOwnProperty函数来完成。 注意: 由于 for in 总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。 使用 hasOwnProperty 过滤123456// foo 变量是上例中的for(var i in foo) &#123; if (foo.hasOwnProperty(i)) &#123; console.log(i); &#125;&#125; 这个版本的代码是唯一正确的写法。由于我们使用了 hasOwnProperty，所以这次只输出 moo。 如果不使用 hasOwnProperty，则这段代码在原生对象原型（比如 Object.prototype）被扩展时可能会出错。 一个广泛使用的类库 Prototype 就扩展了原生的 JavaScript 对象。 因此，当这个类库被包含在页面中时，不使用 hasOwnProperty 过滤的 for in 循环难免会出问题。 总结推荐总是使用 hasOwnProperty。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。 构造函数、原型对象和实例之间的关系每个构造函数都有一个prototype属性指向原型对象，原型对象有一个指针（constructor）指向构造函数，实例有一个 __proto__ 的指针指向原型对象，实例中的constructor属性会遵从原型对象的constructor属性的值。 JS继承原因很多面向对象的语言都支持两种继承方式：接口继承和实现继承。接口继承只支持方法签名，而实现继承则继承实际的方法。由于函数没有签名，ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 原型链原型链的基本概念： 实例和原型对象是有直接关系的，而和构造函数没有直接关系，所以原型对象是另外一个对象的实例的时候，原型链其实就延伸了，如此层层递进，就构成了实例和原型的链条。 继承实现的本质是重写原型对象，代之以一个新类型的实例。 123456789101112131415161718function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); 以上代码定义了两个类型:SuperType 和 SubType。每个类型分别有一个属性和一个方法。它们的主要区别是 SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如下图。 在上面的代码中，我们没有使用 SubType 默认提供的原型，而是给它换了一个新原型;这个新原型就是 SuperType 的实例。于是，新原型不仅具有作为一个 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了 SuperType 的原型。最终结果就是这样的:instance 指向 SubType 的原型，SubType 的原型又指向 SuperType 的原型。getSuperValue()方法仍然还在SuperType.prototype 中，但 property 则位于SubType.prototype 中。这是因为 property 是一个实例属性，而 getSuperValue()则是一个原型方法。既然SubType.prototype 现在是 SuperType的实例，那么 property 当然就位于该实例中了。此外，要注意 instance.constructor 现在指向的 是 SuperType，这是因为原来 SubType.prototype 中的 constructor 被重写了的缘故( 实际上，不是 SubType 的原型的 constructor 属性被重写了，而是 SubType 的原型指向了另一个对象——SuperType 的原型，而这个原型对象的 constructor 属性指向的是 SuperType。)。 通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访 问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在 通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用 instance.getSuperValue()会经历三个搜索步骤:1)搜索实例;2)搜索 SubType.prototype; 3)搜索 SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过 程总是要一环一环地前行到原型链末端才会停下来。 1. 别忘记默认的原型 事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默认都继承了 Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。这也正是所有自定义类型都会继承 toString()、valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层次。 一句话，SubType 继承了 SuperType，而 SuperType 继承了 Object。当调用 instance.toString() 时，实际上调用的是保存在 Object.prototype 中的那个方法。 2.确定原型和实例的关系 可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用 这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码就说明了这 一点。 123alert(instance instanceof Object); //truealert(instance instanceof SuperType); //truealert(instance instanceof SubType); //true 由于原型链的关系，我们可以说 instance 是 Object、SuperType 或 SubType 中任何一个类型 的实例。因此，测试这三个构造函数的结果都返回了 true。 第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true，如下所示。 123alert(Object.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototypeOf(instance)); //true alert(SubType.prototype.isPrototypeOf(instance)); //true 3.谨慎的定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。 1234567891011121314151617181920function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();//添加新方法SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;//重写超类型中的方法 SubType.prototype.getSuperValue = function ()&#123; return false;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //false 在以上代码中，加粗的部分是两个方法的定义。第一个方法 getSubValue()被添加到了 SubType中。第二个方法 getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过 SubType 的实例调用 getSuperValue()时，调用的就是这个重新定义的方法;但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。 还有一点需要提醒读者，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示。 1234567891011121314151617181920function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();//使用字面量添加新方法，会导致上一行代码无效 SubType.prototype = &#123; getSubValue : function ()&#123; return this.subproperty;&#125;, someOtherMethod : function ()&#123; return false;&#125; &#125;;var instance = new SubType();alert(instance.getSuperValue()); //error! 以上代码展示了刚刚把 SuperType 的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个 Object 的实例，而非 SuperType 的实例，因此我们设想中的原型链已经被切断——SubType 和 SuperType 之间已经没有关系了。 4.原型链的问题（原型中的引用类型属性会共享，比如数组） 原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享;而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。下列代码可以用来说明这个问题。 1234567891011121314function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; &#125;function SubType()&#123;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType(); instance1.colors.push(&quot;black&quot;); alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType(); alert(instance2.colors); //&quot;red,blue,green,black&quot; 这个例子中的 SuperType 构造函数定义了一个 colors 属性，该属性包含一个数组(引用类型值)。 SuperType 的每个实例都会有各自包含自己数组的 colors 属性。当 SubType 通过原型链继承了 SuperType 之后，SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自 己的 colors 属性——就跟专门创建了一个 SubType.prototype.colors 属性一样。但结果是什么 呢?结果是 SubType 的所有实例都会共享这一个 colors 属性。而我们对 instance1.colors 的修改 能够通过 instance2.colors 反映出来，就已经充分证实了这一点。 原型链的第二个问题是:在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上， 应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上 前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 借用构造函数在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数 (constructor stealing)的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单，即 在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象， 因此通过使用 apply()和 call()方法也可以在(将来)新创建的对象上执行构造函数，如下所示: 123456789101112131415function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125; function SubType()&#123; //继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green&quot; 代码中加粗的那一行代码“借调”了超类型的构造函数。通过使用 call()方法(或 apply()方法也可以)，我们实际上是在(未来将要)新创建的 SubType 实例的环境下调用了 SuperType 构造函数。这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的 colors 属性的副本了。 传递参数 相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数。看下面这个例子。 12345678910111213function SuperType(name)&#123; this.name = name;&#125;function SubType()&#123; //继承了 SuperType，同时还传递了参数 SuperType.call(this, &quot;Nicholas&quot;); //实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); //&quot;Nicholas&quot;;alert(instance.age); //29 以上代码中的 SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造 函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的属性。 借用构造函数的问题 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 组合继承组合继承(combination inheritance)，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。下面来看一个例子。 1234567891011121314151617181920212223242526272829303132333435 function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125; function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType(); //这块，SubType.prototype.constructor是SupertypeSubType.prototype.constructor = SubType; //这块，手动改写了SubType.prototype.constructor为 //SubTypeSubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29 var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors);//&quot;red,blue,green&quot;instance2.sayName();//&quot;Greg&quot;;instance2.sayAge(); //27 在这个例子中，SuperType 构造函数定义了两个属性:name 和 colors。SuperType 的原型定义了一个方法 sayName()。SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着又定义了它自己的属性 age。然后，将 SuperType 的实例赋值给 SubType 的原型，然后又在该新原型上定义了方法 sayAge()。这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包括 colors 属性，又可以使用相同的方法了。 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象 原型式继承道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 10中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数。 12345function object(o)&#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。 12345678910111213var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; 克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给 object()函数，然后再根据具体需求对得到的对象加以修改即可。在这 个例子中，可以作为另一个对象基础的是 person 对象，于是我们把它传入到 object()函数中，然后该 函数就会返回一个新对象。这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性 和一个引用类型值属性。这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。实际上，这就相当于又创建了 person 对象的两个副本。 ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。 12345678910111213var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; Object.create()方法的第二个参数与 Object.defineProperties()方法的第二个参数格式相同:每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如: 1234567891011var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person, &#123; name: &#123; value: &quot;Greg&quot; &#125;&#125;);alert(anotherPerson.name); //&quot;Greg&quot; 支持 Object.create()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模 式一样。 寄生式继承寄生式(parasitic)继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。 1234567function createAnother(original)&#123; var clone=object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(&quot;hi&quot;); &#125;; return clone; //返回这个对象&#125; 在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然后，把这个对象(original)传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象添加一个新方法 sayHi()，最后返回 clone 对象。可以像下面这样来使用 createAnother()函数: 123456var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot; 这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object()函数不是必需的;任何能够返回新对象的函数都适用于此模式。 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率;这一点与构造函数模式类似。 寄生组合式继承前面说过，组合继承是 JavaScript 最常用的继承模式;不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数:一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。再来看一看下面组合继承的例子。 1234567891011121314151617181920function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //第二次调用SuperType() this.age = age;&#125;SubType.prototype = new SuperType(); //第一次调用SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 加粗字体的行中是调用 SuperType 构造函数的代码。在第一次调用 SuperType 构造函数时，SubType.prototype 会得到两个属性:name 和 colors;它们都是 SuperType 的实例属性，只不过 现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这 一次又在新对象上创建了实例属性 name和colors。于是，这两个属性就屏蔽了原型中的两个同名属 性。图 6-6 展示了上述过程。 如图 6-6 所示，有两组 name 和 colors 属性:一组在实例上，一组在 SubType 原型中。这就是调 用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。 12345function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125; 这个示例中的 inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数:子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。最后一步，将新创建的对象(即副本)赋值给子类型的原型。这样，我们就可以用调用 inherit- Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如: 123456789101112131415function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age); &#125;; 这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变;因此，还能够正常使用instanceof 和 isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 总结ECMAScript 支持面向对象(OO)编程，但不使用类或者接口。对象可以在代码执行过程中创建和 增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来 被构造函数模式所取代。 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局 限于任何对象(即与对象具有松散耦合的特点)，因此没有理由不在多个对象间共享函数。 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 ​ JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。 ​ 此外，还存在下列可供选择的继承模式。 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"利用GitLab自动化部署","slug":"利用GitLab自动化部署","date":"2020-02-29T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2020/03/01/利用GitLab自动化部署/","permalink":"https://justsso1.github.io/2020/03/01/%E5%88%A9%E7%94%A8GitLab%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","excerpt":"","text":"我了解到GitLab上面有两种方式可以做到自动化部署，webhooks和GitLab CI&#x2F;CD。webhooks能完成的事情也比较单一，它的原理就是：webhooks提供一个网络钩子，当你的git仓库触发某些动作比如push时，会触发执行一个脚本，脚本中会有git pull 重启应用等一些操作。GitLab CI&#x2F;CD是持续集成、持续部署，简单来讲持续集成跟多人合作，多个账户提交git有关，持续部署，会经过自动测试，自动打包操作，可以打成能够部署的状态，所以CI&#x2F;CD做的事情比webhooks多很多，可以说，二者解决问题的场景时不同的。在实际的生产中呢，一个项目的部署要考虑到代码合并、环境配置的，所以显而易见，GitLab CI&#x2F;CD更满足现在的需求。 既然都想自动化部署了，那干脆就搞的彻底一点吧，利用GitLab CI&#x2F;CD做一套自动化部署，从此远离人肉部署。 CI&#x2F;CD 什么是CI&#x2F;CD?持续集成可以通过自动运行测试来帮助检测代码缺陷，而持续部署可以帮助您向生产环境交付代码。 在这里我想使用shell脚本命令就能达到自动部署项目的目的，暂时不使用docker，虽然docker更好解决环境兼容问题，但是目前服务器上面已经部署了好几个项目了，环境也是搭建好的，所以暂时跳过docker，把GitLab CI&#x2F;CD配置好就OK 从8.0版开始，GitLab 持续集成（CI）已完全集成到GitLab本身，并且默认情况下在所有项目上都启用。它具有持续部署和持续交付的功能，可用于构建、测试和部署你的应用程序，下面是GitLab CI&#x2F;CD流程图。 步骤一：因为GitLab已经集成了CI ，所以我们在项目的根目录下，创建一个.gitlab-ci.yml文件即可，便可触发CI过程 步骤二：配置GitLab Runner,它相当于一个运行软件，去按照gitlab-ci.yml中写的命令去执行。GitLab Runner参考文档： https://docs.gitlab.com/runner/我使用同一台服务器作为Runner,其实最好不要用同一台服务器做Runner,它会占用一些资源，有可能会影响生产环境。 先说明一下我服务器的额环境：ubuntu系统 安装Runner我选择Repositories方式curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash sudo apt-get install gitlab-runner 注册Runner注册时需要你项目的token，先来拿到token，在项目仓库的设置&gt;CI&gt;Runner展开，看到左侧有”指定的Runner”，下面有token好，服务器上运行如下： Shellscriptsudo gitlab-runner registerEnter your GitLab instance URL: ShellscriptPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )https://gitlab.comShellscriptPlease enter the gitlab-ci token for this runner输入你的token然后是让你输入description 和 tag，tag的作用是当你的提交有你设置的tag时，也就是选定这个Runner运行。 输入Runner executor ShellscriptPlease enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:shell这里我选择了shell 然后不出意外就会注册成功 然后回到gitlab仓库查看，runner是否成功 GitLab Runner 会自动的创建一个gitlab runner用户，然后你的CI 操作会有这个用户运行 好，接下来编写.gitlab-ci.yml 文件： Yaml stages: build deploy cache: key: ${CI_BUILD_REF_NAME} paths: - node_modules build_all: stage: build tags: - tags script: - echo ‘build_all’ - pwd deploy_all: stage: deploy only: - master tags: - tags script: - cnpm install - pm2 restart qiniu when: manual allow_failure: false我每个stage都打了tag tags: - tags这样可以触发你指定的runner，不然的话，gitlab ci就会选运行的最快的那个runner，往往就会选定共享runner了。 我还做了缓存： Yamlcache: key: ${CI_BUILD_REF_NAME} paths: - node_modules我的项目的nodejs写的后台项目，然后使用pm2维护进程。 deploy阶段我选择，手动触发，不可失败，确保线上不会出现问题。 这样，当push到GitLab时，会自动触发CI&#x2F;CD 由于我的deploy需要手动触发，所以得自己去点击按钮 执行成功 流水线也显示成功了","categories":[],"tags":[]},{"title":"深入理解css中的层叠上下文和层叠顺序","slug":"深入理解CSS中的层叠上下文和层叠顺序","date":"2020-02-27T16:00:00.000Z","updated":"2024-10-12T08:40:56.550Z","comments":true,"path":"2020/02/28/深入理解CSS中的层叠上下文和层叠顺序/","permalink":"https://justsso1.github.io/2020/02/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CSS%E4%B8%AD%E7%9A%84%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"底层需要了解的知识：浏览器的分层渲染有特点的场景：transform和fixed定位","categories":[{"name":"css","slug":"css","permalink":"https://justsso1.github.io/categories/css/"}],"tags":[]},{"title":"浅拷贝与深拷贝总结","slug":"浅拷贝与深拷贝总结","date":"2020-02-25T16:00:00.000Z","updated":"2024-10-16T04:07:01.950Z","comments":true,"path":"2020/02/26/浅拷贝与深拷贝总结/","permalink":"https://justsso1.github.io/2020/02/26/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%80%BB%E7%BB%93/","excerpt":"","text":"js\b进阶-浅拷贝与深拷贝总结.md浅拷贝的方式：Object.assign()简单的把一个对象的第一层属性复制到另一个对象上，如果属性是一个引用类型，复制的其实只是指针地址，指向的还是同一个引用类型，带来的问题是，改变其中一个对象会影响另一个对象。 代码实现浅拷贝深拷贝的方式：深拷贝简介的说就是浅拷贝+递归。遍历对象的每一个属性，如果属性是基本类型，就是直接拷贝到新的对象中；如果属性是引用类型，就进一步递归的调用该属性，直到全部遍历完，这样就完成了深拷贝。 JSON.parse()+JSON.string()问题： 会有嵌套循环问题 1 代码实现递归深拷贝参考链接 ：【进阶4-3期】面试题之如何实现一个深拷贝","categories":[],"tags":[]},{"title":"react中的事件","slug":"事件event","date":"2019-11-16T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2019/11/17/事件event/","permalink":"https://justsso1.github.io/2019/11/17/%E4%BA%8B%E4%BB%B6event/","excerpt":"","text":"Event 事件冒泡 和原生dom事件的区别","categories":[],"tags":[]},{"title":"微信小程序开发经验之登录","slug":"微信小程序开发经验之登陆","date":"2019-11-15T16:00:00.000Z","updated":"2024-10-12T08:40:56.549Z","comments":true,"path":"2019/11/16/微信小程序开发经验之登陆/","permalink":"https://justsso1.github.io/2019/11/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E4%B9%8B%E7%99%BB%E9%99%86/","excerpt":"","text":"小程序一般是在app onLaunch程序初始化时，检测用户是否登录过，（查看localStorage中是否有登录标志），然后wx.checkSession() 接口来判断session_key是否过期作为用户登录状态是否过期，没有过期就直接进行下一步，过期了先去重新登录再进行下一步操作。 登录系统设计方面，无论是小程序还是app分为两种： 一种是首页中是否有和用户相关的信息获取展示模块（比如获取用户的报名课程，任务，扇贝阅读app，不背单词app），这种需要在程序启动时检测session是否过期，如果过期了，这时应该在进入首页前，就截断用户操作（不然，用户获取不到属于他的正确信息），界面给出一个提示进行重新登陆或者路由跳转到重新登陆界面，登录完成之后再返回到首页。 另一种是首页中没有和用户相关的信息（比如获取用户的报名课程，大多都是系统的推荐相关，分类展示信息，比如美团app），用户的信息一般放在 其他的tab（我的页面）中， 这种就不需要做一个明显的session_key过期的重新登陆模式，因为之所以要重新登录主要是和用户的信息有关系，首页不需要获取用户信息，就没必要做出一个提示要用户重新登录，一般是在用户无感知的情况下，系统自动进行了重新登录，本地存储最新的登录标志。当用户手动切换到到其他tab的时候，app本地已经进行过重新登陆了，用户可以不受干扰的继续使用app。 实际举例1. 思路 1）用户登录态过期时间如何设置？ 这里我们在前端进行控制，即利用wx.checkSession() 接口来判断session_key 是否过期来作为用户登录态是否过期的标志。如果过期了，则跳转到统一的登录页面引导用户点击按钮重新授权登录，重新登录之后session_key 会刷新，相当于在获取用户最新信息的同时重新设定了过期时间。 （2）onShow() 与onLoad() 小程序js 中有onShow 与onLoad两种事件。两种事件的区别就在于onLoad 每次打开小程序只加载一次，跳转到其他页面再回来的时候这个事件就不会再触发。而onShow 则每次进入页面都会触发，所以我们在进入每个页面检查用户登录态是否过期的代码需要放在onShow 中。 （3）重新登录过程分析 如果用户登录态过期，则需要进行重新登录。前端引导用户点击按钮触发getUserInfo 获取最新用户信息 -&gt; 前端调用wx.login() 获取code -&gt; 前端将code 发送给后端获取openid 和seesion_key -&gt; 后端写session 并返回对应session 的唯一标志 -&gt; 前端存储这个唯一标志。 2. 代码实例 在每个页面的onShow 事件中添加以下代码来检查当前用户登录态是否过期: 1`wx.checkSession(&#123;`` ``success: ``function` `() &#123;`` ``//session_key 未过期，并且在本生命周期一直有效`` ``return` `;`` ``&#125;,`` ``fail: ``function` `() &#123;`` ``// session_key 已经失效，需要重新执行登录流程`` ``wx.navigateTo(&#123;`` ``url: ``&quot;/pages/authorize/index&quot;`` ``&#125;)`` ``&#125;``&#125;)` 因为进入每个页面中都需要进行用户登录态是否过期的检查，所以需要有一个公共的授权页面，当检查不同过的时候，就跳转到这个授权页面引导用户重新进行授权，授权页面authorize 代码如下： wxml 12345&lt;view class=&quot;container&quot;&gt; &lt;view style=&#x27;width:100%;padding-left:30rpx;font-size: 28rpx;margin-top:30rpx;&#x27;&gt;1、同意当前小程序获取我的微信头像；&lt;/view&gt; &lt;view style=&#x27;width:100%;padding-left:30rpx;font-size: 28rpx;margin-top:30rpx;&#x27;&gt;2、同意当前小程序获取我的微信昵称等其他信息；&lt;/view&gt; &lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;bindGetUserInfo&quot; class=&quot;save-btn&quot;&gt;授权登录&lt;/button&gt;&lt;/view&gt; wxss 123456789101112131415161718page&#123; height: 100%;&#125;.container&#123; background-color: #f5f5f9; justify-content: initial;&#125;.save-btn&#123; width: 690rpx; height: 80rpx; line-height: 80rpx; text-align: center; margin-top:30rpx; border-radius: 6rpx; box-sizing: border-box; background-color: #e64340; color:#fff;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// pages/authorize/index.jsvar app = getApp();let Domain = app.globalData.domain;Page(&#123; /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;, bindGetUserInfo: function (e) &#123; // 获得最新的用户信息 if (!e.detail.userInfo)&#123; return; &#125; wx.setStorageSync(&#x27;userInfo&#x27;, e.detail.userInfo) this.checkSessionAndLogin(); &#125;, /* 这里使用openid 作为与后端session 连接的标志 检查是否存在openid，即之前是否登录过 如果登录过，检查session_key 是否过期 如果过期了，remove openid 重新执行login 并将用户信息发送到服务器端更新 如果没过期则返回 如果没登录过则执行login 并将用户信息发送到服务器更新 */ checkSessionAndLogin: function () &#123; let that = this; let thisOpenId = wx.getStorageSync(&#x27;openid&#x27;); // 已经进行了登录，检查登录是否过期 if (thisOpenId) &#123; console.log(&#x27;have openid&#x27;) wx.checkSession(&#123; success: function () &#123; //session_key 未过期，并且在本生命周期一直有效 wx.navigateBack(&#123;&#125;); &#125;, fail: function () &#123; console.log(&#x27;but session_key expired&#x27;); // session_key 已经失效，需要重新执行登录流程 wx.removeStorageSync(&#x27;openid&#x27;); //这里会让openid在本地不存在，通不过if判断，从而走else逻辑，进行登录 that.checkSessionAndLogin(); &#125; &#125;) &#125; else &#123; // 没有进行登录则先进行登录操作 console.log(&#x27;do not have openid&#x27;); that.loginAndGetOpenid(); &#125; &#125;, // 执行登录操作并获取用户openId loginAndGetOpenid: function () &#123; console.log(&#x27;do login and get openid&#x27;); let that = this; wx.login(&#123; success: function (res) &#123; if (res.code) &#123; wx.request(&#123; url: Domain + &#x27;/user/wx_login&#x27;, data: &#123; code: res.code &#125;, success: function (res) &#123; res = res.data; console.log(res) // 保存openId，并将用户信息发送给后端 if (res.code === 0) &#123; wx.showModal(&#123; title: &#x27;set openid&#x27;, content: res.data, &#125;) wx.setStorageSync(&#x27;openid&#x27;, res.data); that.sendUserInfoToServer(); &#125; else &#123; wx.showModal(&#123; title: &#x27;Sorry&#x27;, content: &#x27;用户登录失败~&#x27;, &#125;) &#125; &#125; &#125;) &#125; &#125; &#125;) &#125;, sendUserInfoToServer: function () &#123; console.log(&#x27;now send user info to server&#x27;); let userInfo = wx.getStorageSync(&#x27;userInfo&#x27;); let thisOpenId = wx.getStorageSync(&#x27;openid&#x27;); userInfo.openid =thisOpenId; wx.request(&#123; url: Domain + &#x27;/user/updateUser&#x27;, method: &#x27;POST&#x27;, dataType: &#x27;json&#x27;, data: userInfo, success: function (res) &#123; res = res.data; if (res.code === 0) &#123; wx.navigateBack(&#123;&#125;); &#125; else &#123; wx.showModal(&#123; title: &#x27;Sorry&#x27;, content: &#x27;同步信息出错~&#x27;, &#125;) &#125; &#125; &#125;) &#125;&#125;) 另外，unionID的获取也是有必要的UnionID 机制说明如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。 UnionID获取途径绑定了开发者帐号的小程序，可以通过以下途径获取 UnionID。 调用接口 wx.getUserInfo，从解密数据中获取 UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。 如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过 wx.login + code2Session 获取到该用户 UnionID，无须用户再次授权。 如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过 wx.login + code2Session 获取到该用户 UnionID ，无须用户再次授权。 用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过getPaidUnionId接口获取该用户的 UnionID，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请开发者妥善处理。 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号，可在云函数中通过 cloud.getWXContext 获取 UnionID。 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用，也可在云函数中通过 cloud.getWXContext 获取 UnionID。","categories":[{"name":"微信开发","slug":"微信开发","permalink":"https://justsso1.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"微信公众平台经验分享","slug":"微信开发-微信公众平台经验分享","date":"2019-11-15T16:00:00.000Z","updated":"2024-10-12T08:40:56.549Z","comments":true,"path":"2019/11/16/微信开发-微信公众平台经验分享/","permalink":"https://justsso1.github.io/2019/11/16/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/","excerpt":"","text":"微信公众平台经验 微信生态的繁荣与复杂也是并存的。2018年小程序和小游戏的火爆，也可以说明微信生态越来越繁荣，微信超级app\b给我们的生活带来了\b很多的\b便利，同时有很多的企业和自由工作者也依赖于微信的生态环境，发展公司和自己。 我接触微信开发快有一年了，对于微信的生态环境有一定的了解。主要做微信服务号的开发，也做过微信小程序的开发，微信公众号的开发，在工作过程中积累了很多的经验，记录在这片文章中。 微信的生态环境的关系层级如下： 微信开放平台 微信公众平台 订阅号 服务号 公众号开发 小程序&#x2F;小游戏 企业微信 在申请微信公众平台的时候，要了解\b每种账号类型可以做哪些事情，不可以做哪些事情，能不能满足你的需求，否则后期要改的话，费时费力，有可能前期的积累的粉丝都白费了。 服务号的有更多的接口权限，以满足开发者的需求，有一些权限需求经过认证才可以，比如微信支付功能。 \b微信公众平台技术文档 微信公众平台接口调试工具 微信公众平台接口测试帐号申请 通常微信服务号中内嵌很多网页，大多数是spa，获取用户的信息以满足业务开发。 微信公众平台，就是管理微信服务号 资源中心是微信开放平台开发者所需所有相关资源的汇集地，包括： 移动应用开发 网站应用开发 公众帐号开发 公众号服务开发 用户向公众帐号发送消息时，公众帐号方收到的消息发送者是一个OpenID，是使用用户微信号加密后的结果，每个用户对每个公众帐号有一个唯一的OpenID。 微信公众帐号接口只支持80接口。 UnionID 机制说明如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。 开发过程中，可以申请一个测试号，微信这块做的也是很贴心了。登陆测试号","categories":[{"name":"微信开发","slug":"微信开发","permalink":"https://justsso1.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"Redux","slug":"react学习-Redux","date":"2019-11-11T16:00:00.000Z","updated":"2024-10-16T04:06:47.187Z","comments":true,"path":"2019/11/12/react学习-Redux/","permalink":"https://justsso1.github.io/2019/11/12/react%E5%AD%A6%E4%B9%A0-Redux/","excerpt":"","text":"Redux标签（空格分隔）： redux 状态管理 Finally, to tie state and actions together, we write a function called a reducer.最后，为了将状态和动作联系在一起，我们编写了一个名为reducer的函数。 it’s just a function that takes state and action as arguments, and returns the next state of the app它只是一个将状态和动作作为参数的函数，并返回应用程序的下一个状态。 Three Principles 三个原则 Redux 可以用三个基本的原则来描述： Single source of truth 单一来源的真理 The state of your whole application is stored in an object tree within a single store. store.getState() State is read-only 状态只读 The only way to change the state is to emit an action, an object describing what happened. 改变状态的唯一方法是发出一个动作，一个描述所发生事情的对象。 Changes are made with pure functions 使用纯函数改变 To specify how the state tree is transformed by actions, you write pure reducers. 要指定状态树如何通过操作进行转换，您需要编写纯粹的reducers。 You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination 你可以从一个简化程序开始，随着应用程序的增长，你可以把它拆分成更小的简化程序来管理状态树的特定部分。因为还原剂只是函数，所以您可以控制它们被调用的顺序，传递额外的数据，甚至可以为常见的任务(如分页)制作可重用的还原剂。 123import &#123; combineReducers, createStore &#125; from &#x27;redux&#x27;const reducer = combineReducers(&#123; visibilityFilter, todos &#125;)const store = createStore(reducer) Learning Resourcesconnect function Taking Advantage of combineReducers selector functions Stack Overflow: Why do we need middleware for async flow in Redux? Connect 函数将react组件连接到redux存储 connect是redux-react库的函数，这个函数提供了很多优化去阻止不必要的更新，提升react性能。 它可以接受两个函数 mapStateToProps(state, ownProps) ,mapDispatchToProps(dispatch, ownProps) Provider 组件 Provider 来自react-redux库，可以将store传递给应用中所有的容器组件，而无需显示传递它，只需在渲染根组件的时候使用它一次。 123&lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt;&lt;/Provider&gt; redux的高级使用方法 异步的Action使用中间件Middlewaremiddleware提供的是一个位于action被发起之后，到达reducer之前的扩展。你可以利用redux middler来进行日志记录，创建崩溃报告，调用异步接口或者路由等等。","categories":[],"tags":[]},{"title":"微信小程序支付","slug":"微信小程序开发-微信支付","date":"2019-10-27T16:00:00.000Z","updated":"2024-10-12T08:40:56.549Z","comments":true,"path":"2019/10/28/微信小程序开发-微信支付/","permalink":"https://justsso1.github.io/2019/10/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/","excerpt":"","text":"微信小程序开发-微信支付微信小程序支付开发步骤和H5支付非常类似。 我先说说在开发之前的准备工作吧，因为这块也很重要的。 首先，如果没有微信支付商户号的话，需要去申请一个微信支付商户平台账号，需要根据你要申请账号类型准备相应的材料。 提交材料审核，大约1-2工作日，材料通过之后，就是在线签署协议 通过之后，在商户平台中绑定你的小程序appid 做完以上这些，就可以开始开发了。 开发步骤如下： 统一下单 https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1 应用场景 商户在小程序中先调用该接口在微信支付服务后台生成预支付交易单，返回正确的预支付交易后调起支付。这一步的目地就是获取prepay_id,它是预支付交易回话标识。将prepay_id传给前台，前台调用js-sdk。 接口链接 URL地址：https://api.mch.weixin.qq.com/pay/unifiedorder ​ 是否需要证书 ​ 否 有一点还是要说一下，1、请求参数中的spbill_create_ip终端IP ，可以写你服务器的ip地址。2、可以使用xml2js把xml解析出来 12345678910111213141516171819202122232425262728293031323334353637383940let body = productItem.title || &#x27;启德国际教育规划院出品&#x27;; //商品描述 let url = &#x27;https://api.mch.weixin.qq.com/pay/unifiedorder&#x27;; let nonce_str = getRanId(32); let out_trade_no = &quot;&quot; + new Date().getTime() + Math.floor(Math.random() * 10); let client_ip = &quot;118.190.153.113&quot;; let notify_url = &#x27;https://wordcamp.ibt.tel/index&#x27;; let trade_type = &#x27;JSAPI&#x27;; let openid = await getOpenId(ctx); let stringA = `appid=$&#123;MiniProgram.appId&#125;&amp;body=$&#123;body&#125;&amp;mch_id=$&#123;mch_id&#125;&amp;nonce_str=$&#123;nonce_str&#125;&amp;notify_url=$&#123;notify_url&#125;&amp;openid=$&#123;openid&#125;&amp;out_trade_no=$&#123;out_trade_no&#125;&amp;spbill_create_ip=$&#123;client_ip&#125;&amp;total_fee=$&#123;total_fee&#125;&amp;trade_type=$&#123;trade_type&#125;`; let stringSighTemp = stringA + &quot;&amp;key=你的商户平台的key&quot;; let sign = md5(stringSighTemp).toUpperCase(); let xml = `&lt;xml&gt; &lt;appid&gt;$&#123;MiniProgram.appId&#125;&lt;/appid&gt; &lt;body&gt;$&#123;body&#125;&lt;/body&gt; &lt;mch_id&gt;$&#123;mch_id&#125;&lt;/mch_id&gt; &lt;nonce_str&gt;$&#123;nonce_str&#125;&lt;/nonce_str&gt; &lt;notify_url&gt;$&#123;notify_url&#125;&lt;/notify_url&gt; &lt;openid&gt;$&#123;openid&#125;&lt;/openid&gt; &lt;out_trade_no&gt;$&#123;out_trade_no&#125;&lt;/out_trade_no&gt; &lt;spbill_create_ip&gt;$&#123;client_ip&#125;&lt;/spbill_create_ip&gt; &lt;total_fee&gt;$&#123;total_fee&#125;&lt;/total_fee&gt; &lt;trade_type&gt;$&#123;trade_type&#125;&lt;/trade_type&gt; &lt;sign&gt;$&#123;sign&#125;&lt;/sign&gt;&lt;/xml&gt;`; console.log(xml); let res = await axios(&#123; method: &#x27;post&#x27;, url: url, data: xml, responseType: &#x27;text/xml&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;text/xml&#x27; &#125;, body: &#123; &#x27;content-type&#x27;: &#x27;text/xml&#x27; &#125; &#125;); let parseObj = await xml2js.parseStringPromise(res.data); ctx.body = parseObj 2.小程序调起支付api https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;index=5 这一步中会用到上一步中返回的数据，prepay_id 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let appid = res.data.xml.appid[0]; let prepay_id = res.data.xml.prepay_id[0]; let nonce_str = res.data.xml.nonce_str[0]; let stringA = &quot;appId=&quot; + appid + &quot;&amp;nonceStr=&quot; + nonce_str + &quot;&amp;package=prepay_id=&quot; + prepay_id + &quot;&amp;signType=MD5&amp;timeStamp=&quot; + timeStamp; var stringSignTemp = stringA + &quot;&amp;key=你的商户平台的key&quot;; let paySign = md5(stringSignTemp).toUpperCase(); let that = this; wx.requestPayment(&#123; timeStamp: timeStamp, nonceStr: nonce_str, package: `prepay_id=$&#123;prepay_id&#125;`, signType: &#x27;MD5&#x27;, paySign: paySign, success(res) &#123; console.log(res, &#x27;用户支付成功&#x27;); myrequest.post(addProductOrder, &#123; productId: productId, actualMoney: that.state.productDetail.price &#125;).then(res =&gt; &#123; console.log(res, 77); if (res.data.code === 200) &#123; that.setState(&#123; toastStatus: &quot;success&quot;, toastText: &quot;下单成功&quot;, toastOpen: true &#125;, () =&gt; &#123; setTimeout(() =&gt; &#123; wx.navigateTo(&#123; url: `../orderData/orderData?productId=$&#123;that.state.productDetail.id&#125;&amp;type=product` &#125;) &#125;, 1500) &#125;) &#125; else &#123; that.setState(&#123; toastStatus: &quot;error&quot;, toastText: &quot;下单失败&quot;, toastOpen: true &#125;) &#125; &#125;) &#125;, fail(res) &#123; console.log(res, &#x27;用户取消支付&#x27;); that.setState(&#123; toastStatus: &quot;error&quot;, toastText: &quot;您已取消支付&quot;, toastOpen: true &#125;); &#125;, complete(res) &#123; console.log(res, &#x27;complete&#x27;) &#125; &#125;)&#125; 小程序微信支付要比H5支付友好很多，即使是在开发阶段，开发者也是可以用自己的手机扫码进行支付来调试，不用设置任何的代理，非常棒。","categories":[{"name":"微信开发","slug":"微信开发","permalink":"https://justsso1.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"ArrayBuffer","slug":"es6-ArrayBuffer","date":"2019-10-05T16:00:00.000Z","updated":"2024-10-12T08:40:56.540Z","comments":true,"path":"2019/10/06/es6-ArrayBuffer/","permalink":"https://justsso1.github.io/2019/10/06/es6-ArrayBuffer/","excerpt":"","text":"es6-ArrayBufferArrayBuffer对象是什么ArrayBuffer对象代表存储二进制数据的一段内存，它不能直接读写，只能通过视图（DataView视图或者TypedArray视图）来读写，视图的作用是以指定格式解读二进制数据。 ArrayBuffer也是一个构造函数，可以分配一段存储数据的连续内存区域。 1const buf = new ArrayBuffer(32); 上面代码生成了一段 32 字节的内存区域，每个字节的值默认都是 0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。 为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。 123const buf = new ArrayBuffer(32);const dataView = new DataView(buf);dataView.getUint8(0) // 0 上面代码对一段 32 字节的内存，建立DataView视图，然后以不带符号的 8 位整数格式，从头读取 8 位二进制数据，结果得到 0，因为原始内存的ArrayBuffer对象，默认所有位都是 0。 另一种TypedArray视图，与DataView视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。 12345678const buffer = new ArrayBuffer(12);const x1 = new Int32Array(buffer);x1[0] = 1;const x2 = new Uint8Array(buffer);x2[0] = 2;x1[0] // 2 上面代码对同一段内存，分别建立两种视图：32 位带符号整数（Int32Array构造函数）和 8 位不带符号整数（Uint8Array构造函数）。由于两个视图对应的是同一段内存，一个视图修改底层内存，会影响到另一个视图。 TypedArray视图的构造函数，除了接受ArrayBuffer实例作为参数，还可以接受普通数组作为参数，直接分配内存生成底层的ArrayBuffer实例，并同时完成对这段内存的赋值。 12345const typedArray = new Uint8Array([0,1,2]);typedArray.length // 3typedArray[0] = 5;typedArray // [5, 1, 2] 上面代码使用TypedArray视图的Uint8Array构造函数，新建一个不带符号的 8 位整数视图。可以看到，Uint8Array直接使用普通数组作为参数，对底层内存的赋值同时完成。 存储单位换算ArrayBuffer的实例方法 ArrayBuffer.prototype.byteLength ArrayBuffer.prototype.slice(start,end) ArrayBuffer的静态方法 ArrayBuffer.isView() ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。 12345const buffer = new ArrayBuffer(8);ArrayBuffer.isView(buffer) // falseconst v = new Int32Array(buffer);ArrayBuffer.isView(v) // true 二进制数组的应用FileApiFile接口和FileReader对象。 准备工作 12345&lt;input type=&quot;file&quot; id=&quot;files&quot; multiple /&gt;&lt;div id=&quot;list&quot;&gt;&lt;/div&gt;&lt;div id=&quot;images&quot;&gt;&lt;/div&gt;&lt;!-- File API相关操作写在了script.js中 --&gt;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt; File对象是特殊类型的blob。需要在浏览器中检测其兼容性。 123if (!(window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob)) &#123; throw new Error(&quot;当前浏览器对FileAPI的支持不完善&quot;);&#125; 文件属性-Fileevent.target.files 是一个FileList对象，它是一个由File对象组成的列表。 每个 File 对象，保存着选中的对应文件的属性。常用的有： name：文件名type：文件类型size：文件大小下面，通过 type 属性，过滤掉非图片类型的文件，只展示图片类型文件的信息： fileReader对应的event的详细内容在console控制台打印如下： 12345678910111213141516171819ProgressEvent &#123;isTrusted: true, lengthComputable: true, loaded: 6121, total: 6121, type: &quot;load&quot;, …&#125;bubbles: falsecancelBubble: falsecancelable: falsecomposed: falsecurrentTarget: FileReader &#123;readyState: 2, result: &quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD…iM0kREBEWWjOecYRokiIgIiICIiCpFJE2jQiIiRERSl//2Q==&quot;, error: null, onprogress: null, onloadstart: ƒ, …&#125;defaultPrevented: falseeventPhase: 0isTrusted: truelengthComputable: trueloaded: 6121path: []returnValue: truesrcElement: FileReader &#123;readyState: 2, result: &quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD…iM0kREBEWWjOecYRokiIgIiICIiCpFJE2jQiIiRERSl//2Q==&quot;, error: null, onprogress: null, onloadstart: ƒ, …&#125;target: FileReader &#123;readyState: 2, result: &quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD…iM0kREBEWWjOecYRokiIgIiICIiCpFJE2jQiIiRERSl//2Q==&quot;, error: null, onprogress: null, onloadstart: ƒ, …&#125;timeStamp: 4294.750000000931total: 6121type: &quot;load&quot;__proto__: ProgressEvent FileReader有以下几个监听事件。 onloadstart onload onloadend onprgress 通过 lengthComputable``total``loaded这几个属性可以做到监听文件加载进度。 监听文件加载进度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677if (!(window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob)) &#123; throw new Error(&quot;当前浏览器对FileApi支持不完善&quot;);&#125;function handleFileSelect(e) &#123; const &#123;files&#125; = e.target; console.log(&#x27;选取文件个数：&#x27;, files.length); console.log(files); let vm = document.createDocumentFragment(); let innerHtml = &#x27;&#x27;; let loaded = 0, total = files.length; for (let file of files) &#123; innerHtml += `&lt;li&gt; &lt;strong&gt;$&#123;file.name&#125;&lt;/strong&gt; &lt;span&gt;$&#123;file.type&#125;&lt;/span&gt; &lt;span&gt;$&#123;file.size&#125; bytes&lt;/span&gt; &lt;/li&gt;`; const reader = new FileReader(); reader.onloadstart = function (ev) &#123; handleLoadStart(ev, file) &#125;; reader.onload = function (ev) &#123; handleOnLoad(ev, file) &#125;; reader.onprogress = ev =&gt; handleOnProgress(ev, file); reader.onloadend = function (ev) &#123; handleLoadEnd(ev, file) &#125;; reader.readAsDataURL(file); &#125; const handleLoadStart = function (ev, file) &#123; console.log(&#x27;&gt;&gt;&gt; start load&#x27;, file.name) &#125;; const handleOnLoad = function (ev, file) &#123; console.log(&#x27;&gt;&gt;&gt; Load file&#x27;, file.name); const img = document.createElement(&#x27;img&#x27;); img.height = 150; img.width = 250; img.src = ev.target.result; vm.appendChild(img); loaded++; if (loaded === total) &#123; document.querySelector(&#x27;#images&#x27;).appendChild(vm); &#125; &#125;; const handleOnProgress = function (ev, file) &#123; if (!ev.lengthComputable) &#123; return; &#125; console.log(ev); //计算进度，展示百分比 let percent = Math.round((ev.loaded / ev.total) * 100); console.log(&#x27;&gt;&gt;&gt; Loading&#x27;, file.name, &#x27;progress is &#x27;, percent, &#x27;%&#x27;); &#125;; const handleLoadEnd = function (ev, file) &#123; console.log(&#x27;&gt;&gt;&gt; End Load&#x27;, file.name) &#125;; document.querySelector(&#x27;#list&#x27;).innerHTML = `&lt;ul&gt;$&#123;innerHtml&#125;&lt;/ul&gt;`;&#125;document.querySelector(&#x27;#files&#x27;).addEventListener(&#x27;change&#x27;, handleFileSelect, false); 大文件分片File是Blob对象的一个特例，可以使用slice()来截取文件 拖拽上传拖拽上传主要会用到的知识点有：拖拽drog|drop，FileAPI 读取文件，formData Drag&amp;Drop : HTML5基于拖拽的事件机制. File API : 可以很方便的让 Web 应用访问文件对象，File API 包括FileList、Blob、File、FileReader、URI scheme，本文主要讲解拖拽上传中用到的 FileList 和 FileReader 接口。 FormData : FormData 是基于 XMLHttpRequest Level 2的新接口，可以方便 web 应用模拟 Form 表单数据，最重要的是它支持文件的二进制流数据，这样我们就能够通过它来实现 AJAX 向后端发送文件数据了。 H5原生的Drag和Drop事件H5原生提供拖拽操作，不必使用鼠标事件来模拟。 Drag和Drop包括以下事件： dragstart： 要被拖拽的元素开始拖拽时触发，这个事件对象是被拖拽元素dragenter： 拖拽元素进入目标元素时触发，这个事件对象是目标元素dragover： 拖拽某元素在目标元素上移动时触发，这个事件对象是目标元素dragleave： 拖拽某元素离开目标元素时触发，这个事件对象是目标元素dragend： 在drop之后触发，就是拖拽完毕时触发，这个事件对象是被拖拽元素drop：将被拖拽元素放在目标元素内时触发，这个事件对象是目标元素完成一次成功页面元素拖拽的行为事件过程： dragstart –&gt; dragenter –&gt; dragover –&gt; drop –&gt; dragend &#x2F;&#x2F;要想实现拖拽，首页需要阻止浏览器默认行为，一共四个事件 $(document).on({ dragleave:function(e){ &#x2F;&#x2F;拖离 e.preventDefault(); }, drop:function(e){ &#x2F;&#x2F;放下 e.preventDefault(); }, dragenter:function(e){ &#x2F;&#x2F;拖进 e.preventDefault(); }, dragover:function(e){ &#x2F;&#x2F;拖来拖去 e.preventDefault(); }}); 拖拽对于浏览器的默认行为是打开该文件。 File API 中的 FileList 接口,它主要通过两个途径获取本地文件列表：一种是 的表单形式，一种是 e.dataTransfer.files 拖拽事件传递的文件信息 示例代码： 1234&lt;div style=&quot;position: relative&quot;&gt; &lt;div id=&quot;container&quot;&gt;拖拽上传&lt;/div&gt; &lt;input type=&quot;file&quot; style=&quot;position: absolute;left: 0;top: 0&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637//拖拽上传//阻止浏览器拖拽默认行为document.ondragleave = (e) =&gt; &#123; //脱离 e.preventDefault()&#125;;document.ondragover = (e) =&gt; &#123; //托来托去 e.preventDefault(); document.querySelector(&#x27;#container&#x27;).classList.add(&#x27;over&#x27;);&#125;;document.ondragenter = (e) =&gt; &#123; //拖进 e.preventDefault(); document.querySelector(&#x27;#container&#x27;).classList.add(&#x27;over&#x27;);&#125;;document.ondrop = (e) =&gt; &#123; // 托后放 e.preventDefault(); document.querySelector(&#x27;#container&#x27;).classList.add(&#x27;over&#x27;);&#125;;let contaienr = document.querySelector(&#x27;#container&#x27;);contaienr.addEventListener(&#x27;dragover&#x27;, handleDragover, false);contaienr.addEventListener(&#x27;drop&#x27;, handleDrop, false);function handleDragover(event) &#123; event.stopPropagation(); //停止冒泡 event.preventDefault(); //阻止默认行为 console.log(&#x27;&gt;&gt;&gt; dragover...&#x27;)&#125;function handleDrop(event) &#123; event.stopPropagation(); event.preventDefault(); /***** 访问拖拽文件 *****/ const files = event.dataTransfer.files; console.log(files); /**********/&#125;","categories":[{"name":"es6","slug":"es6","permalink":"https://justsso1.github.io/categories/es6/"}],"tags":[]},{"title":"hook","slug":"react学习-hook","date":"2019-08-14T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2019/08/15/react学习-hook/","permalink":"https://justsso1.github.io/2019/08/15/react%E5%AD%A6%E4%B9%A0-hook/","excerpt":"","text":"react学习-HookHook是什么Hook是react 16.8 新增的特性，可以让你在不编写class的情况下，使用state以及其他的React特性。 React 需要为共享状态逻辑提供更好的原生途径。你可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。 Hook 是能让你在函数组件中“钩入” React 特性的函数。它们名字通常都以 use 开始。 Hook: useState当我们使用 useState 定义 state 变量时候，它返回一个有两个值的元组。第一个值是当前的 state，第二个值是更新 state 的函数。我们使用数组解构把他们分离出来。 第二个值是改变state的函数， 但是它不会把新的 state 和旧的 state 进行合并。而是直接替换它。 class的this.setState和 useState的区别：this.setState({}) ： 新的state 和旧的state进行合并 useState(值) ： 新的state 直接替换旧的state HooK: useEffectEffect Hook 在函数组件中，执行副作用操作，并且它与 class 中的生命周期函数极为类似。 数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。不管你知不知道这些操作，或是“副作用”这个名字，应该都在组件中使用过它们。 如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。 在react中有两种常见的副作用操作： 需要清除的和不需要清除的。 无需清楚的操作： React 更新 DOM 之后运行一些额外的代码，比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。 为什么在组件内部调用 useEffect？ 将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。 useEffect 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。 每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。 123456789101112131415161718192021222324252627import React, &#123;useState, useEffect&#125; from &#x27;react&#x27;;function MyEffect() &#123; const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; // Update the document title using the browser API document.title = &#x27;this is &#x27; + count + &#x27;.&#x27; &#125;); return ( &lt;div&gt; &lt;p&gt; The count is &#123;count&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;点击+1 &lt;/button&gt; &lt;/div&gt; )&#125;export default MyEffect; 需要清除的副作用，例句订阅外部数据源。可以防止引起内存泄漏。 12345678910111213141516171819202122import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect: return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;&#125; 为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。 React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。 并不需要特定的代码来处理更新逻辑，因为 useEffect 默认就会处理。它会在调用一个新的 effect 之前对前一个 effect 进行清理 并不是必须为 effect 中返回的函数命名。这里我们将其命名为 cleanup 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。 小结了解了 useEffect 可以在组件渲染后实现各种不同的副作用。有些副作用可能需要清除，所以需要返回一个函数，其他的 effect 可能不必清除，所以不需要返回。effect Hook 使用同一个 API 来满足这两种情况。 提示: 通过跳过 Effect 进行性能优化如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可: 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 12345678910useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 自定义hook","categories":[{"name":"react","slug":"react","permalink":"https://justsso1.github.io/categories/react/"}],"tags":[]},{"title":"简单三步配置https网站","slug":"简单三步配置https网站","date":"2019-06-13T16:00:00.000Z","updated":"2024-10-14T10:20:25.730Z","comments":true,"path":"2019/06/14/简单三步配置https网站/","permalink":"https://justsso1.github.io/2019/06/14/%E7%AE%80%E5%8D%95%E4%B8%89%E6%AD%A5%E9%85%8D%E7%BD%AEhttps%E7%BD%91%E7%AB%99/","excerpt":"","text":"简单三步配置https网站第一步：申请SSL证书ssl证书是一种加密协议。大部分企业级的SSL证书都是需要收费的，个人使用的SSL证书，有一些是免费的。像阿里云、腾讯云都有提供免费证书申请的接口。 我采用得是阿里云，登陆阿里云账号之后，在 **阿里云》控制台》我的云产品》SSL证书(应用安全)**下，进入该页面。 点击购买证书按钮 选择免费型 DV SSL 填写个人信息，配置域名信息 配置域名授权验证，这一步，如果你选择的是阿里云域名的话，它会自动帮你增加一条TXT记录 做完以上步骤，就会发现在域名的dns解析下面多了一条TXT记录。证书的状态变成已签发之后，就可以把证书下载到本地。 第二步：配置nginx服务器我的服务器是nginx ，所以本文提供的是nginx 的配置方法。把下载下来的证书(包括 .pem文件和 .key文件)上传到服务器nginx安装的位置，一般是在 /etc/nginx下，我放在ssl目录下。 第三步：修改配置文件，重启nginx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455server &#123; listen 80; server_name xxx.com; root /home/xxx; index index.html index.htm index.nginx-debian.html; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; #rewrite ^(.*)$ http://$host$1 permanent; location / &#123; root /; proxy_pass http://localhost:3003; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &#x27;upgrade&#x27;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; client_max_body_size 1000m;# try_files $uri $uri/ =404; &#125;&#125;server &#123; listen 443 ssl; server_name xxx.com; ssl on; root /home/xxx; index index.html index.htm index.nginx-debian.html; ssl_certificate ssl/2353222_wordcamp.ibt.tel.pem; //主要改这儿 ssl_certificate_key ssl/2353222_wordcamp.ibt.tel.key; //主要改这儿 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root /; proxy_pass http://localhost:3003; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &#x27;upgrade&#x27;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; # try_files $uri $uri/ =404; &#125;&#125; 保存配置文件后，重启Nginx：nginx -s reload。 之后就可以使用https访问我们的网址了。","categories":[],"tags":[]},{"title":"异步的发展历史","slug":"前端必备-异步的发展历史","date":"2019-06-02T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2019/06/03/前端必备-异步的发展历史/","permalink":"https://justsso1.github.io/2019/06/03/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87-%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/","excerpt":"","text":"前端必备-异步的发展历史回掉 callback例子： jquery经典的写法 promisepromise是什么？ javascritp的一个内置对象 generatorasync await","categories":[],"tags":[]},{"title":"函数节流与函数防抖","slug":"前端必备-函数节流与函数防抖","date":"2019-06-01T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2019/06/02/前端必备-函数节流与函数防抖/","permalink":"https://justsso1.github.io/2019/06/02/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/","excerpt":"","text":"函数节流与函数防抖应用场景函数节流和防抖在开发中非常常见，浏览器页面滚动 、 Input输入 、 window.onresize、鼠标事件( onmouseover）等，总结来说是在短时间内触发非常频繁的事件。 概念函数节流（throttle） 某个函数在一定时间间隔内（例如 3 秒）只执行一次，在这 3 秒内 无视后来产生的函数调用请求，也不会延长时间间隔 主要思路：预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。 函数防抖（debounce） 当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间 其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。 函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。 说一下我的理解： 节流的特点： 有时间规律的调用。 防抖的特点： 密集性操作之后才触发调用。第二次密集性操作和第一次有时间间隔 节流适用情况触发很频繁的场景：如window对象的resize、scroll事件，拖拽时的mousemove事件 防抖适用情况验证文字输入、自动完成的keyup事件，提交按钮的点击事件 实现1. 函数节流函数节流把要触发的函数根据时间段划分开来，那么就有两种方法实现： 时间戳记录法。函数每一次执行时，都和上一次执行的时间做差，如果大于时间间隔，那么执行操作，记录当前时间戳，下一次调用时，运用同样的方法，以此类推。 setTimeout 定时器法。函数执行时，判断当前有没有定时器，如果有，说明在时间段内，不操作。如果没有，那么执行操作，并且创建一个新的定时器setTimeout，并设置好消除时间。 第一种写法： 123456789101112131415161718//节流函数，时间戳法function fn1(fn, wait) &#123; let lastTime = 0; return function (...args) &#123; let nowTime = new Date().getTime(); if ((nowTime - lastTime) &gt; wait) &#123; lastTime = nowTime; //执行你的代码 fn.apply(this, args); //这里把 event 对象传递进去 &#125; &#125; &#125; let betterFn = fn1((e) =&gt; &#123; console.log(&#x27;hello world&#x27;); console.log(e); &#125;, 3000); window.onscroll = betterFn; 第二种写法： 12345678910111213//节流函数，定时器法let timer = null;let number = 0; function fn() &#123; if (!timer) &#123; console.log(&#x27;hello world&#x27;); timer = setTimeout(() =&gt; &#123; timer = null; &#125;, 3000) &#125; &#125; // window.onscroll = fn; 为了更加直观的看函数节流的调用规律，我添加了以下检测函数。 1234567//检测函数let timer2 = setInterval(() =&gt; &#123; console.log(number++);&#125;, 1000);setTimeout(() =&gt; &#123; clearInterval(timer2)&#125;, 20000); 2.函数防抖（debounce）1234567891011121314function _debounce(fn,wait)&#123; var timer = null; return function()&#123; clearTimeout(timer); //每次密集操作都会清除掉定时器，只有最后一次的执行，没有【下一次】来清除，所以会在wait之后，执行回掉函数 timer = setTimeout(()=&gt;&#123; fn() &#125;,wait) &#125;&#125;function _log()&#123; console.log(1)&#125;window.onscroll = _debounce(_log,500) 3. 函数节流（throttle）[升级版]仔细想想，上面的防抖方式还是有一定的缺点。如果页面很长，我们一直在滚动页面，那_log方法就一直不会被执行。所以我们可以升级一下上述的防抖方法。 12345678910111213141516171819202122232425function _throttle(fn,wait,time)&#123; var previous = null; //记录上一次运行的时间 var timer = null; return function()&#123; var now = +new Date(); if(!previous) previous = now; //当上一次执行的时间与当前的时间差大于设置的执行间隔时长的话，就主动执行一次 if(now - previous &gt; time)&#123; clearTimeout(timer); fn(); previous = now;// 执行函数后，马上记录当前时间 &#125;else&#123; clearTimeout(timer); timer = setTimeout(function()&#123; fn(); &#125;,wait); &#125; &#125;&#125;function _log()&#123; console.log(1)&#125;window.onscroll = _debounce(_log,500,2000)","categories":[{"name":"前端必备","slug":"前端必备","permalink":"https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87/"}],"tags":[]},{"title":"对象委托","slug":"js-基础 对象委托","date":"2019-05-14T16:00:00.000Z","updated":"2024-10-16T04:06:53.094Z","comments":true,"path":"2019/05/15/js-基础 对象委托/","permalink":"https://justsso1.github.io/2019/05/15/js-%E5%9F%BA%E7%A1%80%20%E5%AF%B9%E8%B1%A1%E5%A7%94%E6%89%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"react生命周期","slug":"react学习-生命周期","date":"2019-05-07T16:00:00.000Z","updated":"2024-10-16T04:06:48.705Z","comments":true,"path":"2019/05/08/react学习-生命周期/","permalink":"https://justsso1.github.io/2019/05/08/react%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"react学习-生命周期v16.8.6class组件提供了更加丰富的功能，需要继承React.Component 生命周期速查表 http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ react生命周期阶段： 组件挂载constructor 构造函数(唯一可以给this.state赋值的地方)static getDerivedStateFromPropsrender 渲染ComponentDidMount 组件挂载componentWillUnmount 组件卸载当组件的props或者state改变的时候，render函数都会被重新调用 state的更新方法：出于性能考虑，react可能把多个setState()调用合并成一个调用。 因为this.state和this.props可能是异步更新的，所以不要依赖他们的值去更新下一个状态。 ​ 异步更新state 123this.setState(state, props =&gt; (&#123; counter: state.counter + props.increment&#125;)) 数据流： 自上而下【单向】任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。 在React应用中，组件是有状态组件还是无状态组件属于组件的实现细节，它可能会随着时间的推移发生改变。你你可以在有状态组件中使用无状态组件，反之亦然。 更新当组件的props和state发生变化时会触发更新。组件更新的生命周期调用顺序如下： Static getDerivedStateFromProps() ShouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 卸载componentWillUnmount() React 16 中的错误处理当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法： Static getDerivedStateFromError() 1static getDerivedStateFromError(error) 1componentDidCatch(error, info) 此生命周期在后代组件抛出错误后被调用。 它接收两个参数： error —— 抛出的错误。 info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 请注意，错误边界仅捕获树中它们下面的组件中的错误。错误边界本身无法捕获错误。如果错误边界尝试呈现错误消息失败，则错误将传播到其上方最接近的错误边界。这也类似于catch &#123;&#125;JavaScript在JavaScript中的工作方式。 componentWillRecieveProps(){}快被弃用了","categories":[],"tags":[]},{"title":"React PureComponent使用指南","slug":"react学习-React PureComponent 使用指南","date":"2019-05-02T16:00:00.000Z","updated":"2024-10-16T04:06:47.870Z","comments":true,"path":"2019/05/03/react学习-React PureComponent 使用指南/","permalink":"https://justsso1.github.io/2019/05/03/react%E5%AD%A6%E4%B9%A0-React%20PureComponent%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"React15.3中新加了一个 PureComponent 类，顾名思义， pure 是纯的意思，PureComponent也就是纯组件，取代其前身 PureRenderMixin ,PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码","categories":[],"tags":[]},{"title":"苹果手机专属bug集","slug":"苹果手机专属bug集","date":"2019-03-25T16:00:00.000Z","updated":"2024-10-16T04:06:37.130Z","comments":true,"path":"2019/03/26/苹果手机专属bug集/","permalink":"https://justsso1.github.io/2019/03/26/%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E4%B8%93%E5%B1%9Ebug%E9%9B%86/","excerpt":"","text":"苹果手机专属bug集1.键盘弹起后页面上滑，导致弹框（使用了position:fixed）中按钮响应区域错位，被挤压的页面没有恢复成原来的样子 系统： IOS 12 解决方案： 在点击按钮那里加下面其中一个即可解决. 12345//滚动到顶部window.scrollTo(0, 0);//滚动到底部window.scrollTo(0, document.documentElement.clientHeight); 这个的关键点在于，什么时机调用这个代码 2.苹果手机上不能自动播放音频 由于 iOS Safari 限制不允许 audio autoplay, 必须用户主动交互(例如 click)后才能播放 audio, 因此我们通过一个用户交互事件来主动 play 一下 audio. iOS 9 还需要额外的 load 一下, 否则直接 play 不能让 audio 开始播放 解决方案： 123456789101112131415161718192021222324252627282930313233play() &#123; const node = this.audio.current; clearTimeout(a); console.log(node.readyState, &#x27;readyState 4&#x27;); if (!node.ended) &#123; // 没有结束,第一次点击 node.play(); this.setState(&#123; VolumeColor: green &#125;); var that = this; setTimeout(() =&gt; &#123; that.setState(&#123; VolumeColor: grey &#125;) &#125;, 1000) &#125; else &#123; // 第2..n次点击 node.currentTime = 0; node.load(); //先load一下 node.play(); this.setState(&#123; VolumeColor: green &#125;); var that = this; var a = setTimeout(() =&gt; &#123; that.setState(&#123; VolumeColor: grey &#125;) &#125;, 1000) &#125; &#125;","categories":[],"tags":[]},{"title":"微信H5授权登录的优雅方式","slug":"微信H5中授权登陆的优雅方式","date":"2019-03-20T16:00:00.000Z","updated":"2024-10-12T08:40:56.549Z","comments":true,"path":"2019/03/21/微信H5中授权登陆的优雅方式/","permalink":"https://justsso1.github.io/2019/03/21/%E5%BE%AE%E4%BF%A1H5%E4%B8%AD%E6%8E%88%E6%9D%83%E7%99%BB%E9%99%86%E7%9A%84%E4%BC%98%E9%9B%85%E6%96%B9%E5%BC%8F/","excerpt":"","text":"在微信中打开网页，获取用户信息（open,头像）的时候，微信官方给我们提供了两种登陆调用方式：静默登陆和非静默登陆。 在工作实践中，我总结出了比较好的方式。 先看官方文档传送门 关于网页授权的两种scope的区别说明 1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面） 2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。 具体而言，网页授权流程分为四步： 1、引导用户进入授权页面同意授权，获取code 2、通过code换取网页授权access_token（与基础支持中的access_token不同） 3、如果需要，开发者可以刷新网页授权access_token，避免过期 4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制） util.js 123456789101112131415161718192021222324252627282930313233343536import * as wxConfig from &quot;./wxConfig&quot;;const homepagedir = &#x27;http://testwordcamp.ibt.tel/wx_login?from=&#x27;;function quietLogin(pathname) &#123; const loginConfig = &#123; &#x27;appid&#x27;: wxConfig.appId, &#x27;redirect_uri&#x27;: homepagedir + pathname, &#x27;response_type&#x27;: &#x27;code&#x27;, &#x27;scope&#x27;: &#x27;snsapi_base&#x27;, &#x27;state&#x27;: &#x27;120&#x27; &#125;; window.location.href = &#x27;https://open.weixin.qq.com/connect/oauth2/authorize?&#x27; + qs.stringify(loginConfig) + &#x27;#wechat_redirect&#x27;&#125;//redirect_uri 的值里面有#是会产生response type错误的，且无法修改// 解决方案： 可以把#后面的路径解析出来，用query携带参数，可以做到授权之后跳转回原来的页面function login(pathname) &#123; const loginConfig = &#123; &#x27;appid&#x27;: wxConfig.appId, &#x27;redirect_uri&#x27;: homepagedir + pathname, &#x27;response_type&#x27;: &#x27;code&#x27;, &#x27;scope&#x27;: &#x27;snsapi_userinfo&#x27;, &#x27;state&#x27;: &#x27;120&#x27; &#125;; window.location.href = &#x27;https://open.weixin.qq.com/connect/oauth2/authorize?&#x27; + qs.stringify(loginConfig) + &#x27;#wechat_redirect&#x27;&#125;export &#123; quietLogin, login&#125; 项目的首页作为检测是否登陆的入口 12345678910111213141516171819202122232425262728293031323334Home.jsimport React from &#x27;react&#x27;;import * as wxConfig from &#x27;../../wxConfig&#x27;;import qs from &#x27;querystring&#x27;;import &#123;login, quietLogin&#125; from &quot;../../util&quot;;const homepagedir = &#x27;http://testwordcamp.ibt.tel/wx_login?from=&#x27;;class Home extends React.Component &#123; constructor(props) &#123; super(props); &#125; componentDidMount() &#123; //检查是否登陆过 let wx_login = window.localStorage.getItem(&#x27;wx_login&#x27;); let phone_login = window.localStorage.getItem(&#x27;phone_login&#x27;); if (!wx_login) &#123; // login(this.props.location.pathname); quietLogin(this.props.location.pathname); &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;Home page&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default Home; 在静默授权中, window.location.href &#x3D; ‘https://open.weixin.qq.com/connect/oauth2/authorize?’ + qs.stringify(loginConfig) + ‘#wechat_redirect’ 网页打开 https://open.weixin.qq.com/connect/oauth2/authorize?&#39; + qs.stringify(loginConfig) + &#39;#wechat_redirect&#39;微信浏览器会自动打开你设置的 redirect_uri,并且携带code 。在redirect_uri我携带了跳转前的网页地址，这样在登陆之后，还可以跳转回之前的页面。我是在WxLogin 页面中接收code WxLogin.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;import &#123;fixSearch, login&#125; from &quot;../../util&quot;;// 微信登陆class WxLogin extends React.Component &#123; constructor(props) &#123; super(props) &#125; async componentDidMount() &#123; const &#123;from, code, state&#125; = fixSearch(this.props.location.search); console.log(&#123;from, code, state&#125;); // 如果有code，调用后端的微信登陆接口 setTimeout(() =&gt; &#123; console.log(&#x27;登陆成功&#x27;); window.localStorage.setItem(&#x27;wx_login&#x27;, true); window.location.href = from; &#125;, 1000); // if (code &amp;&amp; state) &#123; // let res = await axios.get(`/api/auth?code=$&#123;code&#125;&amp;state=$&#123;state&#125;`); // console.log(res.data, 16); // if (res.data.is_ok) &#123; // setTimeout(() =&gt; &#123; // console.log(&#x27;登陆成功&#x27;); // window.localStorage.setItem(&#x27;wx_login&#x27;, true); // window.location.href = from; // // &#125;, 1000); // &#125; else &#123; // login(from) // &#125; // //登陆成功之后，跳转回去 // // &#125; else &#123; // // &#125; &#125; render() &#123; return (&lt;div&gt; &lt;p&gt; 微信登陆页面 &lt;/p&gt; &lt;/div&gt;) &#125;&#125;export default WxLogin;","categories":[{"name":"微信开发","slug":"微信开发","permalink":"https://justsso1.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"3作用域和闭包","slug":"js基础-3 作用域和闭包","date":"2019-02-23T16:00:00.000Z","updated":"2024-10-13T16:40:43.618Z","comments":true,"path":"2019/02/24/js基础-3 作用域和闭包/","permalink":"https://justsso1.github.io/2019/02/24/js%E5%9F%BA%E7%A1%80-3%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"js基础-作用域和闭包作用域概念：查找变量的规则。 编译原理为什么要知道编译原理呢？编译原理是从源代码到可执行代码到机器可以识别的代码的一个过程。 不同的语言的编译原理不一样，可能同样一份代码，在java中和在javascript中的执行结果不同。根本的区别就在于两者对于程序的编译的过程不同。 传统的语言是提前编译的，但js不是提前编译的。编译结果也不能在分布式系统中进行移植。 传统编译语言，程序中的源代码在执行前会经历3个步骤，统称为“编译”。 分词&#x2F;词法分析 解析&#x2F;语法分析 代码生成 引擎查找方式有2种： LHS和RHS 变量赋值，LHS非变量赋值：RHS 为什么区分LHS和RHS？ 因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要(也就是说它们没有找到所 需的标识符)，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域(一层 楼)，最后抵达全局作用域(顶层)，无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常(严格模式下)。 作用域查找规则 引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级查找。当抵达最外层的全局作用域时，无论找到还是没有找到，都会结束。 词法作用域作用域有两种：词法作用域和动态作用域。js选择了词法作用域。作用域查找会在找到第一个匹配的标识符时停止。 欺骗词法作用域 两种机制,都不推荐使用，虽然可以欺骗词法作用域，但是会损坏性能。 eval() with 关键字 严格模式下，这两种都被禁用了。 作用域和函数作用域最小授权或者最小暴露原则是指应该最小限度的暴露必要内容。有些变量或者函数应该是私有的，不应该全部暴露出去。正确的代码应该可以阻止对这些变量或者函数的访问。良好的软件都会依次实现。 用var声明的变量都会在全局作用域中。js中有全局作用域，函数作用域，块作用域。 块作用域：with() try…catch… let let 声明的变量不会有变量提升，在块作用域之外也不会被访问到的。块作用域的好处： 闭包和垃圾回收机制闭包的例子就是for循环了，垃圾回收机制，为变量显示声明块作用域，并对变量进行本地绑定是非常有用的工具。 变量提升，编译器会分成2部进行。第一步是变量声明，第二部是执行阶段。 我们习惯将var a &#x3D; 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a和 a &#x3D; 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 作用域闭包闭包的概念：在声明时所在作用域之外调用该函数，就会产生闭包。副作用：保留一段作用域声明周期，垃圾回收机制不能回收，作用域一直存在。 函数在它本身的词法作用域之外执行。 &#x2F;&#x2F; function foo(){&#x2F;&#x2F; var a &#x3D; 2;&#x2F;&#x2F; function bar() {&#x2F;&#x2F; console.log(a)&#x2F;&#x2F; }&#x2F;&#x2F; return bar;&#x2F;&#x2F; }&#x2F;&#x2F;&#x2F;&#x2F; var baz &#x3D; foo();&#x2F;&#x2F; baz(); &#x2F;&#x2F;闭包的例子&#x2F;&#x2F; function wait(message){&#x2F;&#x2F; setTimeout(function timer () {&#x2F;&#x2F; console.log(message)&#x2F;&#x2F; }, 1000)&#x2F;&#x2F; }&#x2F;&#x2F; wait(‘hello world’); &#x2F;&#x2F;for循环闭包的例子&#x2F;&#x2F;1s，2s,3s,4s,5s后输出的都是6&#x2F;&#x2F; for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) {&#x2F;&#x2F; &#x2F;&#x2F; setTimeout(function timer() {&#x2F;&#x2F; &#x2F;&#x2F; console.log(i)&#x2F;&#x2F; &#x2F;&#x2F; }, 100)&#x2F;&#x2F; &#x2F;&#x2F; } &#x2F;&#x2F;这样和上面的结果一样，虽然每一个for循环都创建了一个新的词法作用域出来&#x2F;&#x2F; for (var i &#x3D; 1; i &lt;&#x3D;5 ; i++) {&#x2F;&#x2F; (function () {&#x2F;&#x2F; setTimeout(function timer() {&#x2F;&#x2F; console.log(i)&#x2F;&#x2F; }, i*1000)&#x2F;&#x2F; })()&#x2F;&#x2F; } &#x2F;&#x2F;这样可以1 2 3 4 5依次输出&#x2F;&#x2F;这样不仅创建了5个不同的词法作用域，还把不同循环中的i的值，传入到立即执行函数中&#x2F;&#x2F; for (var i &#x3D; 1; i &lt;&#x3D;5 ; i++) {&#x2F;&#x2F; (function (i) {&#x2F;&#x2F; setTimeout(function timer() {&#x2F;&#x2F; console.log(i)&#x2F;&#x2F; }, i*1000)&#x2F;&#x2F; })(i)&#x2F;&#x2F; } &#x2F;&#x2F;这样便不会每次手动创建一个作用域了&#x2F;&#x2F;因为let有拦截作用域的作用&#x2F;&#x2F; for (let i &#x3D; 1; i &lt;&#x3D; 5; i++) {&#x2F;&#x2F; setTimeout(function timer() {&#x2F;&#x2F; console.log(i)&#x2F;&#x2F; }, i*1000)&#x2F;&#x2F; } &#x2F;&#x2F;模块function foo() { var something &#x3D; ‘something’; var arr &#x3D; [1,2,3]; function a() { console.log(something) } function b() &#123; console.log(arr.join(&#39;,&#39;)) &#125; return &#123; a, b &#125; } var Foo &#x3D; foo();Foo.a();Foo.b(); 词法作用域和动态作用域的区别：主要区别:词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定 的。(this 也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 异步","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"2异步回调","slug":"js基础-2 异步回调","date":"2019-02-17T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2019/02/18/js基础-2 异步回调/","permalink":"https://justsso1.github.io/2019/02/18/js%E5%9F%BA%E7%A1%80-2%20%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/","excerpt":"","text":"js基础-2 异步回调再说回Javascript引擎Google V8 引擎使用 C++ 代码编写，实现了 ECMAScript 规范的第五版，可以运行在所有的主流操作系统中，甚至可以运行在移动终端 ( 基于 ARM 的处理器，如 HTC G7 等 )。V8 最早被开发用以嵌入到 Google 的开源浏览器 Chrome 中，但是 V8 是一个可以独立的模块，完全可以嵌入您自己的应用，著名的 Node.js( 一个异步的服务器框架，可以在服务端使用 JavaScript 写出高效的网络服务器 ) 就是基于 V8 引擎的。 和其他 JavaScript 引擎一样，V8 会编译 &#x2F; 执行 JavaScript 代码，管理内存，负责垃圾回收，与宿主语言的交互等。V8 的垃圾回收器采用了众多技术，使得其运行效率大大提高。通过暴露宿主对象 ( 变量，函数等 ) 到 JavaScript，JavaScript 可以访问宿主环境中的对象，并在脚本中完成对宿主对象的操作。 克服单线程编程的缺点 —————异步回调JavaScript 程序的单元块,最常见的单元块就是函数。 由于javascript的单线程，使得从现在到“将来”要执行的函数的这段时间时间间隙是空的，这是不能允许的。 鼠标点击、定时器、Ajax响应的函数都是异步执行的，它们关联的函数都不是立刻就执行。 其实浏览器的控制台也是异步的，其本质是I&#x2F;O 的异步化。 解析事件循环事件循环机制是由宿主环境提供的。事件是怎么调度的，是有宿主环境控制的，可能不同的宿主环境提供的事件循环机制有所不同，javascript引擎只是去执行这些js代码。 宿主环境提供的事件循环机制并不是那么的精确。比如setTimeout()函数，能够保证在指定的时间之后把回调函数放入事件循环队列，但是此时事件循环队列已经存在未执行的函数，那么回调函数就应该等待。所以，setTimeout()可能会在指定间隔调用，也可能在指定间隔之后调用。 直到在ES6中，JavaScript才真正建立起直接的异步概念。 JavaScript 引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块。 JavaScript 引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是 Web 浏览器。经过最近几年(不仅于此)的发展，JavaScript 已经超出了浏览器的范围， 进入了其他环境，比如通过像 Node.js 这样的工具进入服务器领域。实际上，JavaScript 现如今已经嵌入到了从机器人到电灯泡等各种各样的设备中。 但是，所有这些环境都有一个共同“点”(thread，也指线程。不论真假与否，这都不算一 个很精妙的异步笑话)，即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为事件循环。 我们先从一个奇怪的说法谈起 —— 尽管 JavaScript 允许异步的代码(就像是我们刚刚说的 setTimeout) ，但直到 ES6，JavaScript 自身从未有过任何关于异步的直接概念。JavaScript 引擎只会在任意时刻执行一个程序。 PromisePromise的异步特性是基于任务的。 事件循环队列类似于一个游乐园游戏:玩过了一个游戏之后，你需要重新到队尾排队才能 再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩。一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，任务循环(job loop)可能无限循环(一个任务总是添加另一个任务，以此类推)，进而导致程序的 饿死，无法转移到下一个事件循环 tick。从概念上看，这和代码中的无限循环(就像 while(true)..)的体验几乎是一样的。 代码中语句的顺序和javascript引擎执行语句的顺序并不一定要一致。 async await思路： 从回调函数到promise到generator到async await 深入底层 js的执行机制，v8引擎的执行机制，才可以了解js的异步机制。 promise 和 js异步机制是两码事吗？ js的引擎有很多中，浏览器中采用得是由谷歌发明得V8引擎。js还可以应用在物联网，硬件产品中，只是采用得引擎机制不同而已。 js执行时，v8 引擎和宿主环境结合，宿主环境就是浏览器，或者物联网硬件。 声明式编程 真正理解回调函数回调函数带来两个两个缺点：控制反转进 Tina","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"1调用堆栈","slug":"js基础-1 调用堆栈","date":"2019-02-17T16:00:00.000Z","updated":"2024-10-16T04:06:54.382Z","comments":true,"path":"2019/02/18/js基础-1 调用堆栈/","permalink":"https://justsso1.github.io/2019/02/18/js%E5%9F%BA%E7%A1%80-1%20%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/","excerpt":"","text":"js基础-1 调用堆栈调用栈是解释器（就像浏览器中的javascript解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。 每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。 正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。 当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。 当分配的调用栈空间被占满时，会引发“堆栈溢出”。 12345678910111213function greeting() &#123; // [1] Some codes here sayHi(); // [2] Some codes here&#125;function sayHi() &#123; return &quot;Hi!&quot;;&#125;// 调用 `greeting` 函数greeting();// [3] Some codes here 上面的代码将这样执行: 忽略前面所有函数，直到greeting()函数被调用。 把greeting()添加进调用栈列表。 执行greeting()函数体中的所有代码。 调用栈列表: -greeting 代码执行到sayHi()时，该函数被调用。 把sayHi()添加进调用栈列表。 执行sayHi()函数体中的代码，直到全部执行完毕。 调用栈列表: -greeting -sayHi 返回来继续执行greeting()函数体中sayHi()后面的代码。 删除调用栈列表中的sayHi()函数。 当greeting()函数体中的代码全部执行完毕，返回到调用greeting()的代码行，继续执行剩余JS代码。 调用栈列表: -greeting 删除调用栈列表中的greeting()函数。 一开始，我们得到一个空空如也的调用栈。随后，每当有函数被调用都会自动地添加进调用栈，执行完函数体中的代码后，调用栈又会自动地移除这个函数。最后，我们又得到了一个空空如也的调用栈。 再来看个例子： 12345678910111213141516function baz() &#123; console.log(&#x27;baz&#x27;); bar();&#125;function bar() &#123; console.log(&#x27;bar&#x27;); foo();&#125;function foo() &#123; debugger; console.log(&#x27;foo&#x27;);&#125;baz(); 浏览器中的调用堆栈截图： JavaScript底层是怎么运作的Javascript引擎JavaScript 引擎说起来最流行的当然是谷歌的 V8 引擎了， V8 引擎使用在 Chrome 以及 Node 中，下面有个简单的图能说明他们的关系： 这个引擎主要由两部分组成: 内存堆：这是内存分配发生的地方 调用栈：这是你的代码执行时的地方 运行时 有些浏览器的 API 经常被使用到(比如说：setTimeout)，但是，这些 API 却不是引擎提供的。那么，他们是从哪儿来的呢？事实上这里面实际情况有点复杂。 很多引擎之外的api，我们把这些称为浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout等等。 然后我们还拥有如此流行的事件循环和回调队列。 调用栈JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。 调用栈是一种数据结构，它记录了我们在程序中的位置。如果我们运行到一个函数，它就会将其放置到栈顶。当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情。 让我们来看一看下面的例子： 123456789function multiply(x, y) &#123; return x * y; &#125; function printSquare(x) &#123; var s = multiply(x, x); console.log(s); &#125; printSquare(5); 当程序开始执行的时候，调用栈是空的，然后，步骤如下： 每一个进入调用栈的都称为__调用帧__。 这能清楚的知道当异常发生的时候堆栈追踪是怎么被构造的，堆栈的状态是如何的。让我们看一下下面的代码： 1234567891011function foo() &#123; throw new Error(&#x27;SessionStack will help you resolve crashes :)&#x27;); &#125; function bar() &#123; foo(); &#125; function start() &#123; bar(); &#125; start(); 如果这发生在 Chrome 里(假设这段代码实在一个名为 foo.js 的文件中)，那么将会生成以下的堆栈追踪： “堆栈溢出”，当你达到调用栈最大的大小的时候就会发生这种情况，而且这相当容易发生，特别是在你写递归的时候却没有全方位的测试它。我们来看看下面的代码： 1234function foo() &#123; foo();&#125;foo(); 当我们的引擎开始执行这段代码的时候，它从 foo 函数开始。然后这是个递归的函数，并且在没有任何的终止条件的情况下开始调用自己。因此，每执行一步，就会把这个相同的函数一次又一次地添加到调用堆栈中。然后它看起来就像是这样的： 并发与事件循环由于javascript是单线程运行，只有一个调用堆栈，当某个函数占用大量的时间时，浏览器就不能做任何其他事情，它会被堵塞。这意味着浏览器不能渲染，不能运行其他的代码，它被卡住了。如果你想在应用里让 UI 很流畅的话，这就会产生问题。如何在不阻塞 UI 的情况下执行复杂的代码，让浏览器不会不响应?解决方案就是异步回调。 下篇文章[异步回调](.&#x2F;js基础-2 异步回调.md)","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"解决前端跨域的方法","slug":"前端必备-解决跨域的方法","date":"2019-02-15T16:00:00.000Z","updated":"2024-10-16T04:06:44.986Z","comments":true,"path":"2019/02/16/前端必备-解决跨域的方法/","permalink":"https://justsso1.github.io/2019/02/16/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"解决前端跨域的方法 jsonp cors，需要后端配合 服务器代理 nginx反向代理 devServer 前言前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。 一、什么是跨域？1.什么是同源策略及其限制内容？同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源： &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 2.常见跨域场景当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：特别说明两点： 第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。 第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。 这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？ 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。 二、跨域解决方案1.jsonp1) JSONP原理利用 &lt;script&gt; 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。 2) JSONP和AJAX对比JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求） 3) JSONP优缺点JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。 4) JSONP的实现流程 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。 创建一个&lt;script&gt;标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback&#x3D;show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show(&#39;我不爱你&#39;)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。 123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(&#x27;script&#x27;) window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join(&#x27;&amp;&#x27;)&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: &#x27;http://localhost:3000/say&#x27;, params: &#123; wd: &#x27;Iloveyou&#x27; &#125;, callback: &#x27;show&#x27;&#125;).then(data =&gt; &#123; console.log(data)&#125;) 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(&#39;我不爱你&#39;)，最后会运行show()这个函数，打印出’我不爱你’ 12345678910// server.jslet express = require(&#x27;express&#x27;)let app = express()app.get(&#x27;/say&#x27;, function(req, res) &#123; let &#123; wd, callback &#125; = req.query console.log(wd) // Iloveyou console.log(callback) // show res.end(`$&#123;callback&#125;(&#x27;我不爱你&#x27;)`)&#125;)app.listen(3000) 5) jQuery的jsonp形式JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。 123456789$.ajax(&#123;url:&quot;http://crossdomain.com/jsonServerResponse&quot;,dataType:&quot;jsonp&quot;,type:&quot;get&quot;,//可以省略jsonpCallback:&quot;show&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略jsonp:&quot;callback&quot;,//-&gt;把传递函数名的那个形参callback，可省略success:function (data)&#123;console.log(data);&#125;&#125;); 2.corsCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 1) 简单请求只要同时满足以下两大条件，就属于简单请求 条件1：使用下列方法之一： GET HEAD POST 条件2：Content-Type 的值仅限于下列三者之一： text&#x2F;plain multipart&#x2F;form-data application&#x2F;x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 2) 复杂请求不符合以上条件的请求就肯定是复杂请求了。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 我们用PUT向后台请求时，属于复杂请求，后台需做如下配置： 12345678910111213// 允许哪个方法访问我res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT&#x27;)// 预检的存活时间res.setHeader(&#x27;Access-Control-Max-Age&#x27;, 6)// OPTIONS请求不做任何处理if (req.method === &#x27;OPTIONS&#x27;) &#123; res.end() &#125;// 定义后台返回的内容app.put(&#x27;/getData&#x27;, function(req, res) &#123; console.log(req.headers) res.end(&#x27;我不爱你&#x27;)&#125;) 接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest()document.cookie = &#x27;name=xiamen&#x27; // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open(&#x27;PUT&#x27;, &#x27;http://localhost:4000/getData&#x27;, true)xhr.setRequestHeader(&#x27;name&#x27;, &#x27;xiamen&#x27;)xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader(&#x27;name&#x27;)) &#125; &#125;&#125;xhr.send() 12345//server1.jslet express = require(&#x27;express&#x27;);let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require(&#x27;express&#x27;)let app = express()let whitList = [&#x27;http://localhost:3000&#x27;] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin) // 允许携带哪个头访问我 res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;name&#x27;) // 允许哪个方法访问我 res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT&#x27;) // 允许携带cookie res.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;, true) // 预检的存活时间 res.setHeader(&#x27;Access-Control-Max-Age&#x27;, 6) // 允许返回的头 res.setHeader(&#x27;Access-Control-Expose-Headers&#x27;, &#x27;name&#x27;) if (req.method === &#x27;OPTIONS&#x27;) &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put(&#x27;/getData&#x27;, function(req, res) &#123; console.log(req.headers) res.setHeader(&#x27;name&#x27;, &#x27;jw&#x27;) //返回一个响应头，后台需设置 res.end(&#x27;我不爱你&#x27;)&#125;)app.get(&#x27;/getData&#x27;, function(req, res) &#123; console.log(req.headers) res.end(&#x27;我不爱你&#x27;)&#125;)app.use(express.static(__dirname))app.listen(4000) 上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。 3.postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 otherWindow.postMessage(message, targetOrigin, [transfer]); message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。 123456789101112// a.html &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById(&#x27;frame&#x27;) frame.contentWindow.postMessage(&#x27;我爱你&#x27;, &#x27;http://localhost:4000&#x27;) //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt; 12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage(&#x27;我不爱你&#x27;, e.origin) &#125; 4.websocketWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据 12345678910// socket.html&lt;script&gt; let socket = new WebSocket(&#x27;ws://localhost:3000&#x27;); socket.onopen = function () &#123; socket.send(&#x27;我爱你&#x27;);//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express = require(&#x27;express&#x27;);let app = express();let WebSocket = require(&#x27;ws&#x27;);//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on(&#x27;connection&#x27;,function(ws) &#123; ws.on(&#x27;message&#x27;, function (data) &#123; console.log(data); ws.send(&#x27;我不爱你&#x27;) &#125;);&#125;) 5. Node中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求 转发给服务器。 拿到服务器 响应 数据。 将 响应 转发给客户端。 我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。 12345678910111213141516// index.html(http://127.0.0.1:5500) &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: &#x27;http://localhost:3000&#x27;, type: &#x27;post&#x27;, data: &#123; name: &#x27;xiamen&#x27;, password: &#x27;123456&#x27; &#125;, contentType: &#x27;application/json;charset=utf-8&#x27;, success: function(result) &#123; console.log(result) // &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require(&#x27;http&#x27;)// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, &#x27;Access-Control-Allow-Methods&#x27;: &#x27;*&#x27;, &#x27;Access-Control-Allow-Headers&#x27;: &#x27;Content-Type&#x27; &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: &#x27;127.0.0.1&#x27;, port: 4000, url: &#x27;/&#x27;, method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = &#x27;&#x27; serverResponse.on(&#x27;data&#x27;, chunk =&gt; &#123; body += chunk &#125;) serverResponse.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;The data is &#x27; + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;The proxyServer is running at http://localhost:3000&#x27;)&#125;) 1234567891011// server2.js(http://localhost:4000)const http = require(&#x27;http&#x27;)const data = &#123; title: &#x27;fontend&#x27;, password: &#x27;123456&#x27; &#125;const server = http.createServer((request, response) =&gt; &#123; if (request.url === &#x27;/&#x27;) &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&gt; &#123; console.log(&#x27;The server is running at http://localhost:4000&#x27;)&#125;) 上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 6.nginx反向代理实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 先下载nginx，然后将nginx目录下的nginx.conf修改如下: 1234567891011121314// proxy服务器server &#123; listen 80; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 最后通过命令行nginx -s reload启动nginx 1234567// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:81/?user=admin&#x27;, true);xhr.send(); 123456789101112131415// server.jsvar http = require(&#x27;http&#x27;);var server = http.createServer();var qs = require(&#x27;querystring&#x27;);server.on(&#x27;request&#x27;, function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; &#x27;Set-Cookie&#x27;: &#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27; // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen(&#x27;8080&#x27;);console.log(&#x27;Server is running at port 8080...&#x27;); 7.window.name + iframewindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567891011121314151617// a.html(http://localhost:3000/b.html) &lt;iframe src=&quot;http://localhost:4000/c.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById(&#x27;iframe&#x27;); iframe.src = &#x27;http://localhost:3000/b.html&#x27;; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。 1234// c.html(http://localhost:4000/c.html) &lt;script&gt; window.name = &#x27;我不爱你&#x27; &lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 8.location.hash + iframe实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567// a.html &lt;iframe src=&quot;http://localhost:4000/c.html#iloveyou&quot;&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function () &#123; //检测hash的变化 console.log(location.hash); &#125; &lt;/script&gt; 12345// b.html &lt;script&gt; window.parent.parent.location.hash = location.hash //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面 &lt;/script&gt; 12345// c.htmlconsole.log(location.hash); let iframe = document.createElement(&#x27;iframe&#x27;); iframe.src = &#x27;http://localhost:3000/b.html#idontloveyou&#x27;; document.body.appendChild(iframe); 9.document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值 1234567891011// a.html&lt;body&gt; helloa &lt;iframe src=&quot;http://b.zf1.cn:3000/b.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = &#x27;zf1.cn&#x27; function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678// b.html&lt;body&gt; hellob &lt;script&gt; document.domain = &#x27;zf1.cn&#x27; var a = 100; &lt;/script&gt;&lt;/body&gt; 三、总结 CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案 JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。 日常工作中，用得比较多的跨域方案是cors和nginx反向代理 参考文章 跨域资源共享 CORS 详解 前端面试之道 window.postMessage 前端常见跨域解决方案（全） 深入跨域问题(4) - 利用代理解决跨域 CORS-mdn","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"this和对象原型2","slug":"js基础-this和对象原型2","date":"2019-02-12T16:00:00.000Z","updated":"2024-10-16T03:57:21.085Z","comments":true,"path":"2019/02/13/js基础-this和对象原型2/","permalink":"https://justsso1.github.io/2019/02/13/js%E5%9F%BA%E7%A1%80-this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B2/","excerpt":"","text":"js基础-this和对象原型[[Prototype]]JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有对象在创建时[[Prototype]]属性都会被赋予一个非空值。 对象的[[Prototype]]链1234var anotherObject = &#123; a:2&#125;;// 创建一个关联到 anotherObject 的对象var myObject = Object.create( anotherObject ); myObject.a; // 2 Object.create(..) 的原理.创建一个 对象并把这个对象的 [[Prototype]] 关联到指定的对象 使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到 (并且是 enumerable，参见第 3 章)的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链(无论属性是否可枚举) 通过各种语法进行属性查找时都会查找 [[Prototype]] 链，直到找到属性或者查找完整条原型链 Object.prototype所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype Object.prototype包涵很多通用的功能：toString() 和 .valueOf() .hasOwnProperty(..)。 属性设置和屏蔽给一个对象设置属性的过程。 myObject.foo = &#39;aa&#39;; 如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那 么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。 屏蔽比我们想象的更复杂。 下面我们分析一下如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo &#x3D; “bar” 会出现的三种情况。 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性(参见第3章)并且没 有被标记为只读(writable:false)，那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性。 如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable:false)，那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 如果在[[Prototype]]链上层存在foo并且它是一个setter(参见第3章)，那就一定会 调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这 个 setter。 大多数开发者都认为如果向 [[Prototype]] 链上层已经存在的属性([[Put]])赋值，就一 定会触发屏蔽，但是如你所见，三种情况中只有一种(第一种)是这样的。如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 &#x3D; 操作符来赋值，而是使 用 Object.defineProperty(..)(参见第 3 章)来向 myObject 添加 foo。 隐式屏蔽++ 操作 “类”JavaScript中只有对象，没有类。js是少有的可以不通过类，直接创建对象的语言。 “类”函数js都是在模仿类。 所有的函数默认都会拥有一个 名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象 123function Foo() &#123; // ...&#125;Foo.prototype; // &#123; &#125; （原型）继承如果要访问对象中并不存在的一个属性，[[Get]] 操作(参见第 3 章)就会查找对象内部[[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链)，在查找属性时会对它进行遍历。 所有普通对象都有内置的 Object.prototype，指向原型链的顶端(比如说全局作用域)，如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。 关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤(第 2 章)中会创建一个关联其他对象的新对象。使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。 虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但 是 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。 出于各种原因，以“继承”结尾的术语(包括“原型继承”)和其他面向对象的术语都无 法帮助你理解 JavaScript 的真实机制(不仅仅是限制我们的思维模式) 继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两 个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。 委托(参见第 6 章)这个术语可以更加准确地描述 JavaScript 中对象的关联机制。 对象关联行为委托面向委托的设计类与对象更简洁的设计es6中class的认识","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"this和对象原型1","slug":"js基础-this和对象原型1","date":"2019-02-11T16:00:00.000Z","updated":"2024-10-16T03:57:17.090Z","comments":true,"path":"2019/02/12/js基础-this和对象原型1/","permalink":"https://justsso1.github.io/2019/02/12/js%E5%9F%BA%E7%A1%80-this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B1/","excerpt":"","text":"js基础-this和对象原型认识thisthis是一个关键字，被自动定义在所有函数的作用域中。this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计的更加简洁并且易于复用。 函数可以自动引用合适的上下文对象是非常重要的。 12345678910111213141516171819202122function foo(num) &#123; console.log(&#x27;foo:&#x27;, num); this.count++; console.log(this) //window对象&#125;foo.count = 0;for (var i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; foo(i) &#125;&#125;console.log(foo.count); //0//所有打印//foo: 6//foo: 7//foo: 8//foo: 9//0 打印和我们预期的不一样，为什么foo.count\b还是0呢？为了达到一样，我们可以这样做： 1.函数标示符替代this来引用函数对象 函数分为具名函数和匿名函数，具名函数中，函数名可以指向this,但是匿名函数就找不到名称指向this. 123456789101112131415161718192021function foo(num) &#123; console.log(&#x27;foo:&#x27;, num); foo.count++&#125;foo.count = 0;for (var i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; foo(i) &#125;&#125;console.log(foo.count);//所有打印// foo: 6// foo: 7// foo: 8// foo: 9// 4 2.强制this指向函数，使用call()函数,把函数标示符传入。 123456789101112131415161718192021function foo(num) &#123; console.log(&#x27;foo:&#x27;, num); this.count++&#125;foo.count = 0;for (var i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; foo.call(foo, i) &#125;&#125;console.log(foo.count);//所有打印// foo: 6// foo: 7// foo: 8// foo: 9// 4 但是上面的两种方法都\b避免了使用this。我们之前说了，this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计的更加简洁并且易于复用。函数可以自动引用合适的上下文对象是非常重要的。 所以我们\b认识一下this.\b 注意\b：this在任何时候都不等于函数的作用域。在js内容，作用域确实和对象类似，可见的标示符都是它的属性。但是作用域“对象”无法通过js\b代码访问（也就是作用域只和词法作用域有关于，而和运行时是无关的）， 它存在与javascript引擎内。 this 和作用域是不可以混合的,this既不指向自身，也不指向函数的词法作用域。this实际上是在函数被调用的时候发生的绑定，它指向什么完全取决于函数在哪里被调用。 this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包 含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到 解析thisthis完全取决于函数调用的位置。那找到调用位置了，就离this更进一步了。所以，调用位置是什么呢？是函数被调用的位置？没那么简单，因为有些编程会隐藏函数的真正的调用位置。 先来看个例子； 12345678910111213141516function baz() &#123; console.log(&#x27;baz&#x27;); bar();&#125;function bar() &#123; console.log(&#x27;bar&#x27;); foo();&#125;function foo() &#123; debugger; console.log(&#x27;foo&#x27;);&#125;baz(); \b控制台的截图： Call Stack是调用堆栈 栈结构是先入后出，后入先出的。 栈的第二位是函数的调用位置。 栈里面存的是调用堆栈。 this的绑定规则this的几种绑定规则 1 默认绑定，运行在非严格模式下，this绑定window,运行在严格模式下，this是undefined 2 隐式绑定函数在调用的时候，被一些上下文对象拥有，这么说也不太准确 12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo();//打印： 2 函数的上下文对象和它的最高层调用有关系 12345678910111213141516function foo() &#123; console.log(this.a)&#125;var obj1 = &#123; a: 2, obj2: obj2&#125;;var obj2 = &#123; a: &#x27;3&#x27;, foo: foo&#125;;console.log(obj1.obj2); //undefinedobj1.obj2.foo(); //Cannot read property &#x27;foo&#x27; of undefined 123456789101112131415161718//会产生错误的写法function foo() &#123; console.log(this.a)&#125;var obj2 = &#123; a: &#x27;3&#x27;, foo: foo&#125;;var obj1 = &#123; a: 2, obj2: obj2&#125;;console.log(obj1.obj2); //undefinedobj1.obj2.foo(); //Cannot read property &#x27;foo&#x27; of undefined 2.隐式丢失 隐式绑定中最容易出现的问题是，this丢失绑定的上下文对象.从而变成默认绑定，this指向window或者undefined. 1234567891011121314151617function foo() &#123; console.log(this.a)&#125;function doFun(fn) &#123; fn()&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = &#x27;我是window的a&#x27;;doFun(obj.foo);//打印： 我是window的a 为了解决绑定丢失的问题，有了显示绑定， bind() ES5内置了，不过也可以手动实现这个函数 传入的参数，最终返回一个函数 函数的[[原型]]可以解决这个问题。JavaScript提供的大部分函数以及我们创建的自定义函数，都可以实用apply()和call()函数。 他们的第一个参数是一个对象，他们会把这个对象绑定到this上面，接着在调用函数时，指定这个this. 从this的绑定角度，apply()和call()的效果是一样的，只是参与的传入不一样。 Es5提供了硬绑定的函数在Function.prototype中 bind() 3-2 api调用上下文 12345678910111213function foo(item) &#123; console.log(this.id, item)&#125;var obj = &#123; id: &#x27;aseome&#x27;&#125;;[1, 2, 3].forEach(foo, obj);// aseome 1// aseome 2// aseome 3 4.new绑定 并不存在构造函数，只是存在 1234567891011121314function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar);console.log(bar.a);//打印//foo &#123;a: 2&#125;// a: 2// __proto__: Object// this.js:213 2 this规则的优先级1。 new绑定 2。 显示绑定 call() apply()高于隐式绑定的，也就是隐式绑定一个上下文对象 硬绑定 bind() 会创建一个新的包装函数 3。 隐式绑定 4。 最后的是默认绑定了，this是window或者undefined 手动实现bind()函数，在一些古老的浏览器中没有Function.prototype没有bind函数 123456789101112131415161718192021222324252627282930function bind() &#123; // console.log(typeof Function.prototype.bind); if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; // if (typeof this !== &#x27;function&#x27;) &#123; // throw new Error(&#x27;这不是一个函数&#x27;) // &#125; console.log(typeof this); &#125; &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123; &#125;, fBind = function () &#123; return fToBind.apply( (this instanceof fNOP &amp;&amp; oThis ? this : oThis), aArgs.concat( Array.prototype.slice.call(arguments) ) ) &#125; ; fNOP.prototype = this.prototype; fBound.prototype = new fNOP();&#125;// bind(2); console.log(Array.prototype);console.log(Number.prototype);console.log(Function.prototype); 对象在javascript中一共有7种a语言类型 string number boolean undefined null object symbol 简单基本类型有6中，string number boolean undefined null symbol,他们不是对象 实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。内置对象 String Number Boolean Object Function Array Data RegExp Error .在js 插曲： 123var myObject = &#123;&#125;;myObject.toString()&quot;[object Object] 可计算属性。[]符号内部存放表达式，[]和es6中的symbol结合的比较多。 属性和方法 从技术角度来说，函数永远不会“属于”一个对象。无论返回值是什么类型，每次访问对象，都叫做属性访问。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"}],"tags":[]},{"title":"js对象","slug":"对象","date":"2019-02-05T16:00:00.000Z","updated":"2024-10-16T03:56:51.585Z","comments":true,"path":"2019/02/06/对象/","permalink":"https://justsso1.github.io/2019/02/06/%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"js基础-对象-属性描述符思考下面的代码： Jsvar myObject &#x3D; { a:2}; Object.getOwnPropertyDescriptor( myObject, “a” );&#x2F;&#x2F; {&#x2F;&#x2F; value: 2,&#x2F;&#x2F; writable: true,&#x2F;&#x2F; enumerable: true,&#x2F;&#x2F; configurable: true &#x2F;&#x2F; }Object.getOwnPropertyDescriptor()Object.defineProperty()Jsvar myObject &#x3D; {};Object.defineProperty( myObject, “a”, { value: 2, writable: false, &#x2F;&#x2F; 不可写! configurable: true, enumerable: true });myObject.a &#x3D; 3;myObject.a; &#x2F;&#x2F; 2configurable它的修改都是单向的，不可逆转的enumerablewritable 混合对象“类”类的机制类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。 类的继承父类和子类","categories":[],"tags":[]},{"title":"上传与下载","slug":"前端必备-上传与下载","date":"2019-01-23T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2019/01/24/前端必备-上传与下载/","permalink":"https://justsso1.github.io/2019/01/24/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87-%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"前端必备-上传与下载 掘金文章链接 Koa2 之文件上传下载 koa 中的examples 前端压缩图片 想搞一下，不同文件上传的不同处理。图片上传，pdf上传。怎么上传到自己的服务器，怎么上传到七牛云中。 想搞一下，通过url下载文件，图片文件，excel文件，\bpdf文件在前端页面和node中是怎么处理的。 \b场景1: ant-design\b Upload 组件使用,后台使用koa2react 代码 12345678910111213141516171819202122&lt;Upload name=&quot;image&quot; accept=&#123;&quot;.bmp,.png,.jpeg,.jpg,.gif&quot;&#125; multiple=&#123;true&#125; action=&#123;&#x27;/api/upload?type=image&#x27;&#125; onChange=&#123;info =&gt; &#123; //上传中、完成、失败都会调用这个函数 // console.log(info.file, 39); // info.file.status = uploading done error removed if (info.file.status !== &#x27;uploading&#x27;) &#123; if (info.file.status === &#x27;done&#x27;) &#123; if (info.file.response.code === 200) &#123; message.success(`$&#123;info.file.name&#125; 上传成功`); &#125; &#125; else if (info.file.status === &#x27;error&#x27;) &#123; message.error(`$&#123;info.file.name&#125; $&#123;info.file.response.info&#125;`; &#125; &#125; // console.log(info.event) &#125;&#125;&gt; &lt;Button type=&quot;primary&quot;&gt;&lt;Icon type=&quot;upload&quot;/&gt;上传&lt;/Button&gt;&lt;/Upload&gt; koa2中的代码： koa2 中使用的中间件是koa-body 1234567app.use(bodyParser(&#123; multipart: true, formidable: &#123; maxFileSize: 200 * 1024 * 1024, //单个文件的最大限制 maxFieldsSize: 200 * 1024 * 1024 //所有文件，整个表单的大小限制\b &#125;&#125;)); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//上传素材router.post(&#x27;/upload&#x27;, async (ctx, next) =&gt; &#123; // console.log(&#x27;这里是上传素材中心&#x27;); // console.log(ctx.request.files.images, 202); try &#123; //创建文件可读流，把文件存储到本地 let type = ctx.query.type; let file = ctx.request.files[type]; console.log(file); if (file) &#123; let fsread = fs.createReadStream(file.path); //创建文件可读流 let ext = file.name.split(&#x27;.&#x27;).pop(); //获取文件后缀 if (file.size &lt;= fileControl[type].size) &#123; if (fileControl[type].accept.indexOf(ext) !== -1) &#123; let uploadPath = path.resolve(__dirname, defaultUploadPath); if (!fs.existsSync(uploadPath)) &#123; mkdirp.sync(uploadPath) &#125; //查看是否存在同名文件 if (fs.existsSync(uploadPath + &#x27;/&#x27; + file.name)) &#123; ctx.response.status = 500; ctx.response.body = &#123; code: 500, info: &#x27;存在同名文件&#x27; &#125; &#125; else &#123; let fswrite = fs.createWriteStream(uploadPath + &#x27;/&#x27; + file.name); await fsread.pipe(fswrite); ctx.body = &#123; code: 200, info: &#x27;ok&#x27; &#125; &#125; &#125; else &#123; ctx.response.status = 500; ctx.body = &#123; code: 500, info: `文件仅支持$&#123;fileControl[type].accept&#125;格式` &#125; &#125; &#125; else &#123; ctx.response.status = 500; ctx.body = &#123; code: 500, info: `文件体积超过$&#123;fileControl[type].info&#125;` &#125; &#125; &#125; else &#123; ctx.response.status = 500; ctx.body = &#123; code: 500, info: &#x27;未找到上传文件&#x27; &#125; &#125; &#125; catch (e) &#123; console.log(e); &#125;&#125;); 场景2: 原生\bjs 与 a 标签使用场景3: axios、koa2 实现上传\b场景4: 上传到微信公众\b平台12345678910111213141516171819//创建永久素材async function uploadMaterial(access_token, filePath, mediaType) &#123; try &#123; return new Promise((resolve, reject) =&gt; &#123; exec(`curl -F media=@$&#123;filePath&#125; &quot;https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=$&#123;access_token&#125;&amp;type=$&#123;mediaType&#125;&quot; `, (er, result) =&gt; &#123; er &amp;&amp; console.log(er, 346); console.log(result, 347); if (result) &#123; resolve(result) &#125; else &#123; reject(null) &#125; &#125;) &#125;) &#125; catch (e) &#123; console.log(e.message, 130); throw (e) &#125;&#125; 场景5: 上传到七牛云空间HTML5中的文件上传知识文章链接：&lt;input type=&quot;file&quot;&gt; 原生的，原理一定要\b会 服务端处理文件，主要使用“流”读入流、写入流、管道","categories":[],"tags":[]},{"title":".gitignore文件了解一下","slug":"git 学习-.gitignore文件了解一下？","date":"2019-01-08T16:00:00.000Z","updated":"2024-10-12T08:40:56.541Z","comments":true,"path":"2019/01/09/git 学习-.gitignore文件了解一下？/","permalink":"https://justsso1.github.io/2019/01/09/git%20%E5%AD%A6%E4%B9%A0-.gitignore%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/","excerpt":"","text":".gitignore文件里面填写的文件名，在提交时，这些文件会被忽略掉。.gitignore文件中通常会写 系统自动生成的垃圾文件名、保密性的文件、自动生成的文件或文件夹 通常一个git仓库中，会自动生成.gitignore文件，该文件有一些默认的配置。 下面是一个模版的文件： 12345/node_modules.idea/.vscode/.DS_Store/routes/public/uploads/ &#x2F;node_modules文件夹没有必要上传，太大而且还可以根据package.json文件自动生成 .vscode&#x2F;vscode文件夹中有vsCode的配置文件，没有必要提交 .DS_Store 是苹果系统自带的文件 &#x2F;router&#x2F;public&#x2F;uploads 是上传的文件，没有必要上传到仓库","categories":[],"tags":[]},{"title":"React 16新特性","slug":"react学习-React进阶之路【笔记】","date":"2019-01-08T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2019/01/09/react学习-React进阶之路【笔记】/","permalink":"https://justsso1.github.io/2019/01/09/react%E5%AD%A6%E4%B9%A0-React%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91/","excerpt":"","text":"React 16 新特性Protals（先天的） 可以把组件渲染到当前组件树意外的DOM节点上。典型应用是弹框 ReactDOM.createPortal(child, container) 组件通信父子组件通信 props以及回调函数 兄弟组件通信 层级不多，可以同一个父组件传递props 层级很多，使用 context 通信。在提供context的组件内新增一个getChildContext方法，返回context对象，然后在组件的childContextTypes属性上定义context对象的属性的类型信息。 高阶组件（简称HOC）主要用来实现组件逻辑的抽象和复用。高阶组件接收React组件作为参数，并且返回一个新的React组件，高阶组件本质上而是一个函数，并不是一个组件 const EnhancedComponent = higherOrderComponent(WrappedComponent) 高阶组件主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好的被复用。高阶组件的这种实现方式本质上是装饰着设计模式。 继承式的组件","categories":[],"tags":[]},{"title":"微信裂变记录","slug":"微信开发-微信裂变记录","date":"2019-01-08T16:00:00.000Z","updated":"2024-10-12T08:40:56.549Z","comments":true,"path":"2019/01/09/微信开发-微信裂变记录/","permalink":"https://justsso1.github.io/2019/01/09/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E8%A3%82%E5%8F%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"微信裂变记录场景：已关注用户回复关键字获取自己的专属海报，邀请他人扫码海报，并关注本公众号，以达到微信粉丝增长的目的。 进行微信开发，首先是，基本开发中的服务器配置，建议大家参考入门指引，很简单，参照着设置一下很快就好了。不过最后要点击一下右上角的“启用”按钮，否则，微信服务器接受不到我们自己的服务器的响应，导致我们的服务器的url设置不成功。成功之后的截图如下： 然后设置好access_token , 微信开发离不开access_token的验证，才能使用微信提供的各种接口。微信服务器(公众平台)，自己的服务器，自己的项目前台的关系如下图所示： 配置好环境之后，可以开开心心的开发啦😄 第一步，接受到关注用户的请求。处理用户的请求的逻辑都在本服务器中进行，那么先要解决的事情是怎样让服务器接收到用户的消息呢？我的后台使用的是koa2搭建的，接受微信服务器发来的消息都是xml格式的,使用parsePostData就可以得到完整的xml数据了。 123456789101112131415161718// 解析上下文里 node 原生请求的 POST 参数function parsePostData(ctx) &#123; return new Promise((resovle, reject) =&gt; &#123; try &#123; let postData = &quot;&quot;; // ctx.req 是原生 HTTP 请求对象 ctx.req.on(&quot;data&quot;, (data) =&gt; &#123; postData += data; &#125;); ctx.req.on(&quot;end&quot;, () =&gt; &#123; resovle(postData); &#125;) &#125; catch (err) &#123; reject(err); &#125; &#125;);&#125; 接受文本消息当用户在公众号的对话框\b发送任何消息时，我们配置的服务器都会收到来自微信服务器的xml消息。 123456789&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[gh_69b9829760d6]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[o92L_1dye9BhzOpQEYARNLSgg0BM]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1538397268&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[托福备考]]&gt;&lt;/Content&gt; &lt;MsgId&gt;6607365954744739874&lt;/MsgId&gt;&lt;/xml&gt; 解释：createTime 是微信公众平台记录粉丝发送该消息的具体时间 text: 用于标记该xml 是文本消息，一般用于区别判断 托福备考: 说明该粉丝发给公众号的具体内容是托福备考 MsgId: 是公众平台为记录识别该消息的一个标记数值, 微信后台系统自动产生 为了方便的解析XML内容，我使用了xml2js这个包，写了一个函数来解析接受到的xml数据。 12345678910111213const &#123;parseString&#125; = require(&#x27;xml2js&#x27;);function parseXML(xml) &#123; try &#123; return new Promise((resolve, reject) =&gt; &#123; parseString(xml, (err, result) =&gt; &#123; err &amp;&amp; console.log(err); resolve(result); &#125;) &#125;) &#125;catch (e) &#123; throw (e); &#125;&#125; 当判断得到用户发来了关键字之后，就要回复用户一段文字和一张海报，我们先做到回复文字。 被动回复文本消息这些强烈推荐入门指引https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id&#x3D;mp1472017492_58YV5","categories":[{"name":"微信开发","slug":"微信开发","permalink":"https://justsso1.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"call apply bind","slug":"call apply bind","date":"2018-11-17T16:00:00.000Z","updated":"2024-10-12T08:40:56.538Z","comments":true,"path":"2018/11/18/call apply bind/","permalink":"https://justsso1.github.io/2018/11/18/call%20apply%20bind/","excerpt":"","text":"call()和apply()介绍这两个方法都是函数对象的方法，需要通过函数对象来调用。 当函数调用call()和apply()时，函数都会立即执行。 都可以用来改变函数的this对象的指向。 第一个参数都是this要指向的对象（函数执行时，this将指向这个对象），后续参数用来传实参。 显式绑定thisJS提供的绝大多数函数以及我们自己创建的所有函数，都可以使用call 和apply方法。 它们的第一个参数是一个对象。因为你可以直接指定 this 绑定的对象，因此我们称之为显式绑定。 例1： function foo() { console.log(this.a);} var obj &#x3D; { a: 2}; &#x2F;&#x2F; 将 this 指向 objfoo.apply(obj); &#x2F;&#x2F;打印结果：2第一个参数的传递1、thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。 2、传递一个别的函数名时，函数中的this将指向这个函数的引用。 3、传递的值为数字、布尔值、字符串时，this会指向这些基本类型的包装对象Number、Boolean、String。 4、传递一个对象时，函数中的this则指向传递的这个对象。 call()和apply()的区别call()和apply()方法都可以将实参在对象之后依次传递，但是apply()方法需要将实参封装到一个数组中统一传递（即使只有实参只有一个，也要放到数组中）。 比如针对下面这样的代码： var persion1 &#x3D; { name: “小王”, gender: “男”, age: 24, say: function (school, grade) { alert(this.name + “ , “ + this.gender + “ ,今年” + this.age + “ ,在” + school + “上” + grade); }}var person2 &#x3D; { name: “小红”, gender: “女”, age: 18}如果是通过call的参数进行传参，是这样的： persion1.say.call(persion2, “实验小学”, “六年级”);如果是通过apply的参数进行传参，是这样的： persion1.say.apply(persion2, [“实验小学”, “六年级”]);看到区别了吗，call后面的实参与say方法中是一一对应的，而apply传实参时，要封装成一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。 call()和apply()的作用改变this的指向 实现继承。Father.call(this) bind()都能改变this的指向 call()&#x2F;apply()是立即调用函数 bind()是将函数返回，因此后面还需要加()才能调用。 bind()传参的方式与call()相同。","categories":[],"tags":[]},{"title":"create react app脚手架","slug":"react学习-create react app 脚手架","date":"2018-11-09T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2018/11/10/react学习-create react app 脚手架/","permalink":"https://justsso1.github.io/2018/11/10/react%E5%AD%A6%E4%B9%A0-create%20react%20app%20%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"","text":"入门更新到新版本create-react-app被分成两个包。 create-react-app 是一个全局的命令行包，用来创建新的项目 react-scripts 是一个新创建的项目中的开发依赖 你几乎\b从来不需要更新create-react-app本身，它委托所有配置给react-scripts 当你运行create-react-app时，它总是用最新版本的react-scripts 创建项目。所以，你\b将自动的在新创建的app中使用新的特性。 将已有的项目更新到新版本的react-scripts,打开你文件目录\b中的package.json,迁移到新的版本。 开发设置编辑器如果正确的配置，create-react-app 附带了很多改善编辑体验的工具。这里是几条最大化生产力的技巧： 语法高亮\bdebug目前只有VS和webStorm支持刺功能。 Visual Studio Code和WebStorm支持使用Create React App开箱即用的调试。这使您作为开发人员可以在不离开编辑器的情况下编写和调试React代码，最重要的是，它使您能够拥有连续开发工作流，其中上下文切换最小，因为您不必在工具之间切换。 分离状态 开发组件分析打包体积source-map-explorer使用source maps 分析javascript包，这帮助你理解代码膨胀的来源。 npm install --save source-map-explorer 在package.json中增加一行 “scripts”: &#123; &quot;analyze&quot;: &quot;source-map-explorer build/static/js/main.*&quot; &#125;3. 执行打包命令和分析 命令 npm run build npm run analyze 开发中使用https你可能需要开发服务器通过https来提供页面。一个特殊的例子是，当api服务器本身是https服务时，使用代理功能将请求代理到api服务器，这可能非常有用。 \bWindows (cmd.exe) set HTTPS=true&amp;&amp; npm start Windows (Powershell) ($env:HTTPS = &quot;\btrue&quot;) -add (npm start)Linux, macOS(Bash) HTTPS=true npm start 请注意，服务器将使用自签名证书，因此您的Web浏览器在访问页面时几乎肯定会显示警告。 Style and Assets这个项目\b设置使用webpack处理各种资产，webpack提供了一种超越\bJavascript的自定义方式的扩展概念import。表示js文件依赖一个css文件，你需要import the css from the javascript file. import 引入 添加css模块css文件[name].module.css为扩展，则开启了css 模块。css模块使你在不同的文件中使用相同class名字，也不会报错，不会有命名冲突。 例子：Button.module.css 1234Button.module.css.error &#123; background-color: red;&#125; another-stylesheet.css 123.error &#123; color: red;&#125; Button.js 12345678910import React, &#123; Component &#125; from &#x27;react&#x27;;import styles from &#x27;./Button.module.css&#x27;; // Import css modules stylesheet as stylesimport &#x27;./another-stylesheet.css&#x27;; // Import regular stylesheetclass Button extends Component &#123; render() &#123; // reference as a js object return &lt;button className=&#123;styles.error&#125;&gt;Error Button&lt;/button&gt;; &#125;&#125; button真正的类名是 .Button_error__1gR1K 增加SASS 样式npm install node-sass --save 文件会被自动编译的，如果被引入的文件明拓展是.scss或者.sass sass还是可以自定义变量，使用@import 来引入文件 post-processing CSS自动添加\b浏览器前缀 添加图像，字体和文件使用 import 引入 .bmp .gif .jpeg .png ，大小小于10000字节的图像将返回数据uri, svg 文件可以直接被导入作为React组件。 1234567import &#123; ReactComponent as Logo &#125; from &#x27;./logo.svg&#x27;;const App = () =&gt; ( &lt;div&gt; &#123;/* Logo is an actual React component */&#125; &lt;Logo /&gt; &lt;/div&gt;); 使用public \b文件夹可以修改publick\b文件夹下的html文件，比如设置页面标题，&lt;script&gt;标签在打包的程序中会自动生成并添加到代码中。 使用\b import的好处： script和stylesheets被缩小和打包来减少额外的网络请求 缺少文件会导致编译错误，而不是4040错误 结果文件名包含内容哈希，因此您无需担心浏览器缓存旧版本 public文件下的内容不会被webpack打包的，public文件夹下的资源是会被复制到构建文件夹中的，要引用public文件夹中的资源，需要使用一个名为的特殊变量PUBLIC_URL &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt; 当运行时npm run build，Create React App将替换%PUBLIC_URL%为正确的绝对路径什么时候使用public文件夹 您需要在构建输出中具有特定名称的文件，例如manifest.webmanifest （原因可能是：webpack对它无法打包） 您有数千个图像，需要动态引入他们的路径 （原因可能是：减少import带来的编译成本） 希望在\b打包代码中包含一个小的脚本 有一些库可能和webpack有冲突，你没有别的选择只能用script标签引入 如果使用script 标签引入的话，\b是全局变量 代码拆分import()动态引入，进行代码分割。import()函数的形式将模块名称作为参数并返回一个Promise总是解析为模块的名称空间对象的形式。使用react路由进行代码拆分 [!https://serverless-stack.com/chapters/code-splitting-in-create-react-app.html] 构建你的App安装依赖生成的项目包括react和react dom 作为依赖，它还包括create-react-app 用作开发依赖项的椅子脚本。它还需要安装其他依赖： 1npm install --save react-router-dom 导入组件\b由于Webpack，该项目设置支持ES6模块。虽然你仍然可以使用require()和module.exports，我们鼓励您使用import和export替代。 一个文件最多\b只有一个默认导出和许多有名的exports 使用全局变量可以通过从window对象中显式读取全局变量来避免linter\b警告，因为 linter看不到变量的定义 1const $ = window.$; 增加Bootstrapnpm install --save reactstrap bootstrap@4 在src/index.js文件开头引入bootstrap css文件，和可选的bootstrap 主题 import &#39;bootstrap/dist/css/bootstrap.css&#39;; 在src/App.js文件活自定义文件中导入所需的reactstrap 组件 import &#123; Button &#125; from &#39;reactstrap&#39;; 增加Flownpm install --save flow-bin 它是分析打包之后的包中各个模块的体积大小的","categories":[],"tags":[]},{"title":"解决react中出现invalid host header问题","slug":"react实战-解决react中出现invalid host header 问题","date":"2018-10-11T16:00:00.000Z","updated":"2024-10-12T08:40:56.543Z","comments":true,"path":"2018/10/12/react实战-解决react中出现invalid host header 问题/","permalink":"https://justsso1.github.io/2018/10/12/react%E5%AE%9E%E6%88%98-%E8%A7%A3%E5%86%B3react%E4%B8%AD%E5%87%BA%E7%8E%B0invalid%20host%20header%20%E9%97%AE%E9%A2%98/","excerpt":"","text":"解决react中出现invalid host header问题这是我在使用react框架开发中遇到的问题。 我本地的127.0.0.1或者localhost需要一个代理域名，否则无法向服务器请求访问。因为微信的js-sdk使用时，前台的域名必须是合法的【需要配置的白名单里面，白名单的检查方式是只检查域名】,所以需要配host,将 127.0.0.1 配到rockcms.ibt.tel 解决方法：在config文件夹下的webpackDevServer.config.js 中，将disableHostCheck 的值改为 true","categories":[],"tags":[]},{"title":"一次痛苦又甜蜜的微信支付踩坑之旅","slug":"微信开发-H5微信支付","date":"2018-02-02T16:00:00.000Z","updated":"2024-10-14T04:02:45.824Z","comments":true,"path":"2018/02/03/微信开发-H5微信支付/","permalink":"https://justsso1.github.io/2018/02/03/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91-H5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/","excerpt":"","text":"一次痛苦又甜蜜的微信支付踩坑之旅 凡是和钱打交道的事，没有一样是容易的。这是我第一次接触微信支付，发现网上还是有很多同学在求助，XXX了怎么办？XXX是什么情况？为了帮助更多的小伙伴脱离“苦海”，我决定写下这次的踩坑之旅，给更多的人帮助。 介绍微信支付方式分为刷卡支付、公众号支付、扫码支付、APP支付、H5支付、小程序支付。 先从应用场景来各自说一说，这样，能够最快的判断出应该选择哪一种支付。 刷卡支付：使用扫描设备（扫描枪）多见于超市、便利店使用 公众号支付：嵌入公众号的H5页面 扫码支付：用户打开“微信扫一扫”，扫描商户的二维码并支付 APP支付：外部APP应用，用户触发支付时，转到微信内完成支付 H5支付：非微信内置浏览器请求微信支付 小程序支付：用户在微信小程序中使用微信支付 背景我们公司申请的是微信服务号，需要微信支付的是嵌入服务号内部的网页，所以根据介绍，应该选择“公众号支付”。 开发步骤首先不要被微信支付的开发吓着，其实它很简单。先仔细看公众号支付的文档，看不懂的多看几遍，还看不懂的，动手操作一下，试一试。 文档在此：微信支付统一下单 步骤一：统一下单 跟着文档，咱一点点来，搞明白每一步是为什么，就不会迷迷糊糊搞不清楚了。 首先说一下，这个接口是后台需要完成的，这个接口的目的就是获取prepay_id,它是预支付交易回话标识。将prepay_id传给前台，前台调用js-sdk，这属于步骤二的范围了，一会讲。 接口链接 https://api.mch.weixin.qq.com/pay/unifiedorder 在文档中说明了，必须使用post 方法请求微信给的接口链接，传入的数据也必须是xml格式，返回的也是xml的。醉了？不要醉，微信是这样的，支付宝也是这样的。手动微笑，接受吧。 接着来。 简单粗暴贴代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// &#x27;/addOrder&#x27;是留给前台的调用接口router.post(&#x27;/addOrder&#x27;,(req,res)=&gt;&#123;const addOrderUrl = &#x27;https://api.mch.weixin.qq.com/pay/unifiedorder&#x27;;var client_ip = &quot;&quot;;client_ip = req.body.ipaddr;var appid = &quot;1234567890&quot;; // 服务号|公众号的appidvar body = &quot;商品简单描述-测试&quot;; // 商品简单描述var mch_id= &quot;1234567890&quot;; // 商户号，申请微信支付，腾讯给的商户号// var device_info = &quot;WEB&quot;;var nonce_str = getRanId(32); // 随机字符串var out_trade_no = &quot;&quot; +new Date().getTime() + Math.floor( Math.random() * 10 ); //商户订单号var total_fee = req.body.total_fee; //支付金额，单位：分var sign = &quot;&quot;;var notify_url = &quot;http://123.456.789&quot;; //异步接收微信支付结果通知的回调地址var trade_type = &quot;JSAPI&quot;; // 交易类型var openid = req.session.openId;console.log(openid);var stringA = `appid=$&#123;appid&#125;&amp;body=$&#123;body&#125;&amp;mch_id=$&#123;mch_id&#125;&amp;nonce_str=$&#123;nonce_str&#125;&amp;notify_url=$&#123;notify_url&#125;&amp;openid=$&#123;openid&#125;&amp;out_trade_no=$&#123;out_trade_no&#125;&amp;spbill_create_ip=$&#123;client_ip&#125;&amp;total_fee=$&#123;total_fee&#125;&amp;trade_type=$&#123;trade_type&#125;`;var stringSighTemp = stringA+&quot;&amp;key=****#####jiaoyuguihuayuan----***&quot;; //32位的商户key,自定义的，这里为了隐私，我用的特殊符号给你们展示sign = md5(stringSighTemp).toUpperCase();var xml = `&lt;xml&gt;&lt;appid&gt;$&#123;appid&#125;&lt;/appid&gt;&lt;body&gt;$&#123;body&#125;&lt;/body&gt;&lt;mch_id&gt;$&#123;mch_id&#125;&lt;/mch_id&gt;&lt;nonce_str&gt;$&#123;nonce_str&#125;&lt;/nonce_str&gt;&lt;notify_url&gt;$&#123;notify_url&#125;&lt;/notify_url&gt;&lt;openid&gt;$&#123;openid&#125;&lt;/openid&gt;&lt;out_trade_no&gt;$&#123;out_trade_no&#125;&lt;/out_trade_no&gt;&lt;spbill_create_ip&gt;$&#123;client_ip&#125;&lt;/spbill_create_ip&gt;&lt;total_fee&gt;$&#123;total_fee&#125;&lt;/total_fee&gt; &lt;trade_type&gt;$&#123;trade_type&#125;&lt;/trade_type&gt;&lt;sign&gt;$&#123;sign&#125;&lt;/sign&gt;&lt;/xml&gt;`;var Res = res;axios(&#123; method: &#x27;post&#x27;, url: addOrderUrl, data: xml, responseType: &#x27;text/xml&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;text/xml&#x27; &#125; &#125;).then( res=&gt;&#123; console.log(res) Res.send(res.data) &#125;).catch( err=&gt;&#123; console.log( err)&#125;)&#125;) 说明client_ip 参数 是客户端的ip地址，本来我是在后台获取客户端ip地址的，因为我们使用了nginx代理，req.ip 返回的都是 ::ffff:127.0.0.1 这是IPV6格式的字符串。网上有一个答案对此做出了解释： stackoverflow.com&#x2F;questions&#x2F;2… 在这里，我用的一个网上的脚本在前台获取的， http://pv.sohu.com/cityjson?ie=utf-8使用方法： window.ipaddr &#x3D; returnCitySN[‘cip’];其他的参数，都是参考微信支付的要求去写的。 出现的错误 XML格式错误 而查看文档，原因是这样的 我：#&amp;(%#@+%)，也不给个详细点的说明… 这种错误需要“顿悟”，我突然发现了我的错误。是我理解错了！我给body标签加了一个 导致我的xml格式错误，其实是有detail字段才需要添加 &lt;[CDATA[]]&gt;， 其他的不需要。 我：咳咳，低级错误。注意看文档，按照要求来，既不多添什么，也不要少什么。 我把&lt;[CDATA[]]&gt;去掉之后，发现果真是这个原因，不再出现XML格式错误了，然而，还是高兴的太早，因为它报了签名错误。呵呵呵~ 签名错误 文档中说的签名计算很严格：第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1&#x3D;value1&amp;key2&#x3D;value2…）拼接成字符串stringA。 特别注意以下重要规则：第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1&#x3D;value1&amp;key2&#x3D;value2…）拼接成字符串stringA。 ◆ 参数名ASCII码从小到大排序（字典序）；◆ 如果参数的值为空不参与签名；◆ 参数名区分大小写； （公众号支付全是小写）◆ 验证调用返回或微信主动通知签名时，传送的sign参数不参与签名，将生成的签名与该sign值作校验。◆ 微信接口可能增加字段，验证签名时必须支持增加的扩展字段 第二步，在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue。 ◆ key设置路径：微信商户平台(pay.weixin.qq.com)–&gt;账户设置–&gt;API安全–&gt;密钥设置 这里我查阅了一些资料，看到过有这样几种错误情况：key 看错了，这里应该写商户的key,而这个key 是用户手动设置的，长32位。注意：自己保存一份，因为设置好了之后是没法打开查看的。 还有一种错误，我觉得很离谱啊，body里面不能有中文，然而，我把body中的文字改为英文，发现并不能改变现状，其实用中文是可以的。 … 总之，找到的这些错误，通通对我的情况没用！ 然后这又需要“顿悟”，原来stringA字符串我用了换行符把很长的字符隔开，这导致换行符被转换为Ascall码中的 \\n 写进了签名里面，所以，sign错误，所以要么，把换行符通通去掉，要么用“”连接，舍弃。我把换行都去掉之后，就没有签名错误了。 当当当当 ~ 终于完成了第一步，后台成功的返回了我们需要的prepay_id 这里为了安全，对于返回sign，和发送的sign进行对比，完全相等之后，才能把结果返回给前台。 步骤二：调用微信js-sdk接口 微信支付 发起一个微信支付请求 前台收到的是xml数据，要先解析一下，得到prepay_id 然后调用微信支付js-sdk，为了大家少走一些弯路，我先来正确的写法，关键步骤如下： 123456789101112131415161718192021var &#123;prepay_id,appid&#125; = getInfo(res.data); //从后台数据中获取appid 和 prepay_idnonceStr = getRanId(32);timeStamp = new Date().getTime();var stringA = &quot;appId=&quot;+appid+&quot;&amp;nonceStr=&quot;+nonceStr+&quot;&amp;package=prepay_id=&quot;+prepay_id+&quot;&amp;signType=MD5&amp;timeStamp=&quot;+timeStamp;var stringSignTemp = stringA+&quot;&amp;key=****#####jiaoyuguihuayuan----***&quot;;paySign = md5(stringSignTemp).toUpperCase();window.wx.chooseWXPay(&#123; timestamp: timeStamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: nonceStr, // 支付签名随机串，不长于 32 位 package: &quot;prepay_id=&quot; + prepay_id, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*） signType: &#x27;MD5&#x27;, // 签名方式，默认为&#x27;SHA1&#x27;，使用新版支付需传入&#x27;MD5&#x27; paySign: paySign, // 支付签名 success: function (res) &#123; // 支付成功后的回调函数 console.log(res) &#125;, fail: function(err)&#123; console.log(err) &#125;&#125;); 备注：prepay_id 通过微信支付统一下单接口拿到，paySign 采用统一的微信支付 Sign 签名生成方法，注意这里 appId 也要参与签名，appId 与 config 中传入的appId 一致，即最后参与签名的参数有appId, timeStamp, nonceStr,package, signType。 注意，我要讲个坑点~ 调用js-sdk时，签名中的字段都是小驼峰的写法，timeStamp是这样写的，但是wx.config中，timestamp 是全小写的，所以，亲们，千万不要搞错了，我在这里就被坑了好一会呢。* 写完签名之后，当你用微信web开发者工具去测试的话，就会看到，“不支持模拟”这样的提示。这个时候，不要犹豫，直接上真机去测试，这并不是我们的程序出现了问题。 小tips: 在真机上，我们是没有办法看到console出的一些调试信息，所以，要想个办法，可以用alert，也可以把调试信息打印在屏幕上面，我选择打印在屏幕上。这里要说一些，微信给的文档没有那么齐全，有一些是要试试才指导的，比如wx.config中的success和fail函数，参数信息怎么打印，其实是res.errMsg和err.errMsg. 上面我说的这些你都注意到了，但是微信支付的控件你依然调动不起来的话，可能是微信商户平台的开发配置出现了问题，在产品中心-开发配置-支付配置-公众号支付中进行配置，配置的时候，注意一定要到最后一级目录，比如我要在cms.123.456&#x2F;book&#x2F;list&#x2F;index.html页面中去进行微信支付，那么你的配置应该是 cms.123.456&#x2F;book&#x2F;list&#x2F; 好了，开发中基本上所有的坑都提到了，这是建立在你配置没有出错的情况下。接下来，看看到底能不能真的支付。 完成 大功告成，让我想起了，最近流行的一句话，你这磨人的小妖精，微信支付！ 希望能给你们带来帮助~","categories":[{"name":"微信开发","slug":"微信开发","permalink":"https://justsso1.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"}],"tags":[]}],"categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","permalink":"https://justsso1.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"javascript","slug":"javascript","permalink":"https://justsso1.github.io/categories/javascript/"},{"name":"css","slug":"css","permalink":"https://justsso1.github.io/categories/css/"},{"name":"微信开发","slug":"微信开发","permalink":"https://justsso1.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"},{"name":"es6","slug":"es6","permalink":"https://justsso1.github.io/categories/es6/"},{"name":"react","slug":"react","permalink":"https://justsso1.github.io/categories/react/"},{"name":"前端必备","slug":"前端必备","permalink":"https://justsso1.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://justsso1.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"数组","slug":"数组","permalink":"https://justsso1.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"安全","slug":"安全","permalink":"https://justsso1.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"开发者工具","slug":"开发者工具","permalink":"https://justsso1.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"},{"name":"事件循环","slug":"事件循环","permalink":"https://justsso1.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"koa2中间件","slug":"koa2中间件","permalink":"https://justsso1.github.io/tags/koa2%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"npm","slug":"npm","permalink":"https://justsso1.github.io/tags/npm/"},{"name":"异常","slug":"异常","permalink":"https://justsso1.github.io/tags/%E5%BC%82%E5%B8%B8/"},{"name":"爬虫","slug":"爬虫","permalink":"https://justsso1.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"proxy","slug":"proxy","permalink":"https://justsso1.github.io/tags/proxy/"}]}